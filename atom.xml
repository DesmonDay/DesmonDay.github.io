<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DesmonDay&#39;s Blog</title>
  
  <subtitle>一只小辣鸡的自我拯救之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DesmonDay/"/>
  <updated>2019-04-03T19:35:08.408Z</updated>
  <id>https://github.com/DesmonDay/</id>
  
  <author>
    <name>Desmon Day</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Seq-embedding</title>
    <link href="https://github.com/DesmonDay/2019/04/04/Seq-embedding/"/>
    <id>https://github.com/DesmonDay/2019/04/04/Seq-embedding/</id>
    <published>2019-04-03T19:28:33.000Z</published>
    <updated>2019-04-03T19:35:08.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用BERT生成句子向量"><a href="#用BERT生成句子向量" class="headerlink" title="用BERT生成句子向量"></a>用BERT生成句子向量</h1><p>一开始我用的是Linux虚拟机环境，后来发现内存不够，因此改为Windows10. 接下来是调用别人完成的一个接口。</p><ol><li><p>tensorflow版本要大于等于1.10, numpy也要更新</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install bert-serving-server  <span class="comment"># server</span></span><br><span class="line">pip install bert-serving-client  <span class="comment"># client, independent of `bert-serving-server`</span></span><br></pre></td></tr></table></figure></li><li><p>下载中文预训练模型，<a href="https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip，" target="_blank" rel="noopener">https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip，</a> 直接解压，得到对应的文件夹。</p></li><li><p>得到上面文件夹的绝对路径，输入命令（我用相对路径出错了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bert-serving-start -model_dir=绝对路径 -num_work=2</span><br></pre></td></tr></table></figure></li></ol><p>例如我的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bert-serving-start -model_dir=E:\PostGraduate\NLP\chinese_L-12_H-768_A-12\ -num_worker=1</span><br></pre></td></tr></table></figure></p><p>完成后即开启了BERT服务，此时的命令窗口不可关闭，否则相当于关闭服务。</p><ol start="5"><li>python运行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地运行</span></span><br><span class="line"><span class="keyword">from</span> bert_serving.client <span class="keyword">import</span> BertClient</span><br><span class="line">bc = BertClient()</span><br><span class="line">bc.encode([<span class="string">'开心的一天'</span>,<span class="string">'今天真开心'</span>,<span class="string">'开心！'</span>]) <span class="comment"># 文档建议一次性将需要的句子作为列表输入，而不是用for循环，这样效率较高</span></span><br></pre></td></tr></table></figure></li></ol><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-9cc6d50a847295d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="用ERNIE生成句子向量"><a href="#用ERNIE生成句子向量" class="headerlink" title="用ERNIE生成句子向量"></a>用ERNIE生成句子向量</h1><p>要用到PaddlePaddle，在Linux下似乎比较好，所以又转向了虚拟机…</p><ol><li>下载预训练模型: <a href="https://ernie.bj.bcebos.com/ERNIE_stable.tgz" target="_blank" rel="noopener">https://ernie.bj.bcebos.com/ERNIE_stable.tgz</a> 解压得到params文件夹</li><li>Linux安装PaddlePaddle: <a href="http://www.paddlepaddle.org/" target="_blank" rel="noopener">http://www.paddlepaddle.org/</a> 老师可以在此网站查看自己的电脑合适的安装方式，我是用pip装的。</li><li>下载需要的ERNIE源文件，需要的话我可以发给老师</li><li><p>完成脚本文件<br>注意：因为我没有cuda，所以use_cuda那里改为了false；${MODEL_PATH}我填的是模型的绝对路径；${TASK_DATA_PATH}我填的是数据的绝对路径，注意数据有特定的格式，而且必须是tsv文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FLAGS_sync_nccl_allreduce=1</span><br><span class="line"><span class="built_in">export</span> CUDA_VISIBLE_DEVICES=7</span><br><span class="line"></span><br><span class="line">python -u ernir_encoder.py \</span><br><span class="line">                   --use_cuda <span class="literal">true</span> \</span><br><span class="line">                   --batch_size 32 \</span><br><span class="line">                   --output_dir <span class="string">"./test"</span> \</span><br><span class="line">                   --init_pretraining_params <span class="variable">$&#123;MODEL_PATH&#125;</span>/params \</span><br><span class="line">                   --data_set <span class="variable">$&#123;TASK_DATA_PATH&#125;</span>/lcqmc/dev.tsv \</span><br><span class="line">                   --vocab_path config/vocab.txt \</span><br><span class="line">                   --max_seq_len 128 \</span><br><span class="line">                   --ernie_config_path config/ernie_config.json</span><br></pre></td></tr></table></figure></li><li><p>建立文件夹test，执行上述bash文件，可以分别得到cls_emb.npy（存储句子embeddings）和top_layer_emb.npy（存储句子的token embeddings）。</p></li><li>读取npy文件内容：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-45050b69f313f3b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><h1 id="相似度比较"><a href="#相似度比较" class="headerlink" title="相似度比较"></a>相似度比较</h1><p>测试的句子：</p><pre><code>- 我可以给您介绍一下免费拿手机的活动吗？ 您可以给我介绍一下免费拿手机的活动吗？- 我可以给您介绍一下不要钱就能拿手机的活动吗？ 我来给您介绍一下免费就能得到好手机的活动- 我该叫你妈妈什么？ 我应该怎么称呼你妈妈？- 爸爸的儿子我应该叫什么？ 儿子的爸爸我该怎么叫？</code></pre><p>三种方法的比对结果：</p><table><thead><tr><th>seq1</th><th>seq2</th><th>LASER</th><th>BERT</th><th>ERNIE</th></tr></thead><tbody><tr><td>我可以给您介绍一下免费拿手机的活动吗？</td><td>您可以给我介绍一下免费拿手机的活动吗？</td><td>0.9675291</td><td>0.9962016</td><td>0.9903929 </td></tr><tr><td>我可以给您介绍一下不要钱就能拿手机的活动吗？</td><td>我来给您介绍一下免费就能得到好手机的活动。</td><td>0.810219</td><td>0.94765455</td><td>0.8651513</td></tr><tr><td>我该叫你妈妈什么？</td><td>我应该怎么称呼你妈妈？</td><td>0.9234945</td><td>0.9519638</td><td>0.9113665 </td></tr><tr><td>爸爸的儿子我应该叫什么？</td><td>儿子的爸爸我该怎么叫？</td><td>0.9514671</td><td>0.9730811</td><td>0.9775459</td></tr></tbody></table><p>给我的感觉是，三种模型都是基于词来进行句子向量的实现的，而没有考虑到句子的含义，比如最后那一句，爸爸的儿子，儿子的爸爸，这两句三个模型的相似度都很高。感觉不太妥当。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用BERT生成句子向量&quot;&gt;&lt;a href=&quot;#用BERT生成句子向量&quot; class=&quot;headerlink&quot; title=&quot;用BERT生成句子向量&quot;&gt;&lt;/a&gt;用BERT生成句子向量&lt;/h1&gt;&lt;p&gt;一开始我用的是Linux虚拟机环境，后来发现内存不够，因此改为Win
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
      <category term="embedding" scheme="https://github.com/DesmonDay/tags/embedding/"/>
    
  </entry>
  
  <entry>
    <title>第三周-浅层神经网络</title>
    <link href="https://github.com/DesmonDay/2019/04/03/deep-learningw3/"/>
    <id>https://github.com/DesmonDay/2019/04/03/deep-learningw3/</id>
    <published>2019-04-03T11:04:06.000Z</published>
    <updated>2019-04-03T18:19:22.391Z</updated>
    
    <content type="html"><![CDATA[<p>下面进入第三周的学习内容。</p><h1 id="神经网络概述"><a href="#神经网络概述" class="headerlink" title="神经网络概述"></a>神经网络概述</h1><p><img src="https://upload-images.jianshu.io/upload_images/8636110-23bd9f4bd923a2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里将神经网络与Logistic回归进行了一个简单的对比，即神经网络也需要前向传播和后向传播。另外，每一层的参数用右上标的一个方括号表示，即方括号用来区分不同的层；如果右上标是圆括号，则指具体的一个样本。</p><h1 id="神经网络表示"><a href="#神经网络表示" class="headerlink" title="神经网络表示"></a>神经网络表示</h1><p>下图是一个简单的双层神经网络的表示（即单隐层网络），其中也包括了一些通用的符号标记方法。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-08d351090e1131ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="计算神经网络的输出"><a href="#计算神经网络的输出" class="headerlink" title="计算神经网络的输出"></a>计算神经网络的输出</h1><p>图中给出了第一层隐藏层的输入和输出过程，我们可以通过将参数w进行堆叠化，再与X向量相乘，与b向量相加，得到对应的输出Z^[1]和a^[1]。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-fe5a64b67e9273f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>更简单的一个解释如下图，可以看到W,a,b,z的维度的相同点与不同点。我们固定输入特征为列向量，则隐藏层参数的维数则为（隐藏层结点个数，特征总数）。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-42f3688fd171800f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="多个样本"><a href="#多个样本" class="headerlink" title="多个样本"></a>多个样本</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面进入第三周的学习内容。&lt;/p&gt;
&lt;h1 id=&quot;神经网络概述&quot;&gt;&lt;a href=&quot;#神经网络概述&quot; class=&quot;headerlink&quot; title=&quot;神经网络概述&quot;&gt;&lt;/a&gt;神经网络概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.j
      
    
    </summary>
    
      <category term="深度学习" scheme="https://github.com/DesmonDay/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>第二周-神经网络基础</title>
    <link href="https://github.com/DesmonDay/2019/04/01/deep-learningw2/"/>
    <id>https://github.com/DesmonDay/2019/04/01/deep-learningw2/</id>
    <published>2019-04-01T09:26:58.000Z</published>
    <updated>2019-04-03T09:38:39.472Z</updated>
    
    <content type="html"><![CDATA[<p>下面进入神经网络基础的学习，这部分大多已经学过了，这里就当作是一次复习。</p><h1 id="二元分类-Binary-Classification"><a href="#二元分类-Binary-Classification" class="headerlink" title="二元分类-Binary Classification"></a>二元分类-Binary Classification</h1><p>图片用红绿蓝三个通道，通过这些输入预测是否是猫。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-58570aa3a16bf715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>将这张猫的图片表示成输入的特征向量：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d344493c07cb5f2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对应的记号：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-075f444ce29f4d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>需要注意的是X是每个样本列向量的堆叠。</p><h1 id="Logistic回归-Logistic-Regression"><a href="#Logistic回归-Logistic-Regression" class="headerlink" title="Logistic回归-Logistic Regression"></a>Logistic回归-Logistic Regression</h1><p>logistic回归用于解决二元分类问题。这里要注意，P(y=1|x)指训练样本为x时，y为1的概率。在下图写的Output那里，最初我们是直接用一个线性分类器，但是因为我们希望输出的是概率，而w^T+b可能大于1，可能小于0，因此要添加sigmoid函数将其值域压缩到(0,1)。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-32b12b2fb0f2047d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>另外，红色部分那里是另一种表示形式，将b作为其中一个参数theta_0。在实现神经网络时，最好用蓝色部分的符号表示。</p><p>更清晰的表示如下：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-afc4b3675c063183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="logistic回归损失函数-Logistic-Regression-cost-function"><a href="#logistic回归损失函数-Logistic-Regression-cost-function" class="headerlink" title="logistic回归损失函数-Logistic Regression cost function"></a>logistic回归损失函数-Logistic Regression cost function</h1><p><img src="https://upload-images.jianshu.io/upload_images/8636110-f81af276c1811d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>具体公式推导可以见上图。我们可以发现，最开始我们写的损失函数L是误差平方公式，然而这个函数的优化形式是非凸函数，如果求解会有多个局部最优解。使用梯度下降可能就找不到全局最优解。因此需要进一步地对损失函数进行研究。</p><ol><li>损失函数(loss function)定义为 L(y’, y) = -(ylogy’+(1-y)log(1-y’))，并且当y=1时，希望y’尽量大；当y=0时，希望y’尽量小。损失函数仅适用于单个的训练样本。</li><li>代价函数(cost function)如上图中所写，是整个训练集的平均损失函数。我们的目标就是找到合适的参数w和b来最小化cost function的值。</li></ol><h1 id="梯度下降法-Gradient-Descent"><a href="#梯度下降法-Gradient-Descent" class="headerlink" title="梯度下降法-Gradient Descent"></a>梯度下降法-Gradient Descent</h1><p>梯度下降法，初始化参数时可以随机初始化，因为对应的成本函数是凸函数，因此总会到达全局最优解。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-fc767b037a75dcde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>更新公式：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f210c7aa4f359e44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这里要注意导数的符号表示，当变量为两个或多于两个时，使用花体符号；如果只有一个变量，可以用d表示。当我们要在代码中实现导数时，可以直接写成dw,db。</p><h1 id="计算图-Computation-Graph"><a href="#计算图-Computation-Graph" class="headerlink" title="计算图-Computation Graph"></a>计算图-Computation Graph</h1><p>一个简单的计算图例子：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-68afab65388cfbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其中，计算图是指用蓝色箭头画出来的从左到右的计算。</p><h1 id="计算图的导数计算-Derivatives-with-a-Computation-Graph"><a href="#计算图的导数计算-Derivatives-with-a-Computation-Graph" class="headerlink" title="计算图的导数计算-Derivatives with a Computation Graph"></a>计算图的导数计算-Derivatives with a Computation Graph</h1><p>这一小节，吴老师用一个简单的例子介绍了求导的链式法则以及反向传播的概念，并且也告诉我们在编程中如果需要求关于某个变量的导数，可以直接写作da, dvar之类的。 我们先求出了dv，然后利用dv求出da, du，接着再利用所求可以继续求出da, db, dc，即反向传播。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7825abe0a5eee6b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-b2ae3c7b8c474f00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>因此，一个计算图就是从左到右的计算成本函数J，再从反向计算导数。</p><h1 id="Logistic回归中的梯度下降-Logistic-Regression-Gradient-Descent"><a href="#Logistic回归中的梯度下降-Logistic-Regression-Gradient-Descent" class="headerlink" title="Logistic回归中的梯度下降-Logistic Regression Gradient Descent"></a>Logistic回归中的梯度下降-Logistic Regression Gradient Descent</h1><p>本节介绍的是单个样本的Logistic回归中的梯度下降过程。如图，从右往左计算导数，其中还用到了求导的链式法则。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7b061c83f3839af5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="M个样本上进行logistic回归的梯度下降过程"><a href="#M个样本上进行logistic回归的梯度下降过程" class="headerlink" title="M个样本上进行logistic回归的梯度下降过程"></a>M个样本上进行logistic回归的梯度下降过程</h1><p>首先，我们需要回忆logistic回归的cost function如下。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d070f51fd777450f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>假设我们要求dw1，对应的公式如下。可以发现，我们需要累加每个样本对应的dw，最后还需要求平均。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-2bf7423664b0b8c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>因此最终可以得到如下的更新过程：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-75dfcee80a8ec6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然而，这样的更新过程有两个缺点：一是需要遍历所有的样本(i=1,2,…,m)；二是需要遍历所有的特征(dw1,dw2)。也就是说，需要两个for循环，然而在代码中显式地使用for循环会使效果低下，因此我们的解决方法是：Vectorization，向量化。</p><h1 id="向量化-Vectorization"><a href="#向量化-Vectorization" class="headerlink" title="向量化-Vectorization"></a>向量化-Vectorization</h1><p>向量化通常是消除我们代码中显示for循环语句的艺术。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-075ab455f7acdfd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看到，左边是非向量化写法，即用for循环来实现矩阵乘法；而右边则是向量化写法，使用python中的numpy库来实现。下面给出在juypter notebook中实现的两种写法，对比其时间差异：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-2eb987492d9501b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>显然，向量化的计算快了许多。可扩展深度学习一般是在GPU上运行的，而jupyter notebook是基于CPU的。GPU擅长SIMD指令(Single Instruction Multiple Data，但之灵多数据流)，而CPU的表现也不差。因此，我们看到numpy的向量化可以加速代码运行。因此，我们可以得到一个经验法则：不要显式地使用for循环。</p><h2 id="More-exmaples"><a href="#More-exmaples" class="headerlink" title="More exmaples"></a>More exmaples</h2><p>Neural network programming guideline: Whenever possible, avoid explicit for-loops.</p><ol><li><p>一个矩阵和向量的乘法计算：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-0794a79f9ba514d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>计算向量中每个元素的指数运算：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-11142b52a693d999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>因此上述例子也告诉我们：在实现代码时，先看看我们能否用numpy的内置函数，而不是使用for循环。</p><p>接着，我们对logistic回归中的一个有关特征的循环进行向量化：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-23875c59a63e8893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="向量化Logistic回归"><a href="#向量化Logistic回归" class="headerlink" title="向量化Logistic回归"></a>向量化Logistic回归</h1><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p><img src="https://upload-images.jianshu.io/upload_images/8636110-7569387a10a5a5db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看到，我们可以将Z和A用向量化的方法得到对应的矩阵，即一次性计算了所有样本的w.T+b和a，而不需要使用for循环。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>首先，吴老师使用向量化计算出参数b和w的梯度db,dw：注意左边是for循环做法，右边是向量化做法。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d3a9af1f9958495a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接着是整个Logistic回归的向量化算法过程，将X作为矩阵参与计算：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-ffe6d306dac83a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以发现，最后梯度下降的迭代仍然需要一个for循环来实现，这部分则是无法向量化的。</p><h1 id="Python中的广播-Broadcasting-in-Python"><a href="#Python中的广播-Broadcasting-in-Python" class="headerlink" title="Python中的广播-Broadcasting in Python"></a>Python中的广播-Broadcasting in Python</h1><p>首先，周老师给出了一个计算百分比的例子，用来说明广播的作用：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-76c074e494865c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>对应的python代码如下，可以发现，我们先使用了sum函数，这里axis=0时表示按列相加，而axis=1则表示按行相加；另外，这里用到广播的地方是percentage的计算。而老师说这里的reshape是可以去掉的，但是这个reshape其实也起到了一个保证我们的矩阵维数不会出错的作用。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-066827da288afd80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>更多的广播例子：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7740e442d0adffd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>广播的一些常用法则：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-e79ce24e4500f7ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="A-note-on-python-numpy-vectors"><a href="#A-note-on-python-numpy-vectors" class="headerlink" title="A note on python/numpy vectors"></a>A note on python/numpy vectors</h1><h2 id="消除代码中秩为1的数组"><a href="#消除代码中秩为1的数组" class="headerlink" title="消除代码中秩为1的数组"></a>消除代码中秩为1的数组</h2><p>写向量时，不要这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># a.shape = (5,) # 既不是行向量，也不是列向量</span></span><br></pre></td></tr></table></figure></p><p>而如果我们要把上述a转换成向量，可以用reshape函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = a.reshape((<span class="number">5</span>,<span class="number">1</span>))</span><br><span class="line">a = a.reshape((<span class="number">1</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><p>应该这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.randn(<span class="number">5</span>,<span class="number">1</span>) <span class="comment"># a.shape=(5,1) column vector</span></span><br><span class="line">a = np.random.randn(<span class="number">1</span>,<span class="number">5</span>) <span class="comment"># a.shape=(1,5) row vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(a.shape == (<span class="number">5</span>,<span class="number">1</span>)) <span class="comment"># 确保这是一个向量，而且执行速度很快</span></span><br></pre></td></tr></table></figure></p><h2 id="不要害羞，使用reshape或assert来保证维度不出错"><a href="#不要害羞，使用reshape或assert来保证维度不出错" class="headerlink" title="不要害羞，使用reshape或assert来保证维度不出错"></a>不要害羞，使用reshape或assert来保证维度不出错</h2><h1 id="Logistic回归中成本函数的证明"><a href="#Logistic回归中成本函数的证明" class="headerlink" title="Logistic回归中成本函数的证明"></a>Logistic回归中成本函数的证明</h1><p>Lost function函数的来由，我们最小化L(a,y)，实际上就是最大化logP(y|x)<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7ce97fae643e8ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>而对于整个训练集的成本函数：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-73f51176fb37e694.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在假设样本集为独立同分布的前提下，通过最大似然估计，可以知道我们在最小化cost function的同时，也在最大化似然估计。</p><h1 id="本周作业"><a href="#本周作业" class="headerlink" title="本周作业"></a>本周作业</h1><p>参考别人记录的作业内容，这里就顺便抄题目了！</p><h2 id="Part-1-Python-Basics-with-Numpy-optional-assignment"><a href="#Part-1-Python-Basics-with-Numpy-optional-assignment" class="headerlink" title="Part 1: Python Basics with Numpy (optional assignment)"></a>Part 1: Python Basics with Numpy (optional assignment)</h2><p>What we need to Remember:</p><ul><li>np.exp(x) works for any np.array x and applies the exponential function to every coordinate</li><li><p>the sigmoid function and its gradient</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: sigmoid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># this means you can access numpy functions by writing np.function() instead of numpy.function()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute the sigmoid of x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    x -- A scalar or numpy array of any size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    s -- sigmoid(x)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    s = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_derivative</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute the gradient (also called the slope or derivative) of the sigmoid function with respect to its input x.</span></span><br><span class="line"><span class="string">    You can store the output of the sigmoid function into variables and then use it to calculate the gradient.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    x -- A scalar or numpy array</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    ds -- Your computed gradient.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    s = sigmoid(x)</span><br><span class="line">    ds = s*(<span class="number">1</span>-s)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ds</span><br></pre></td></tr></table></figure></li><li><p>image2vector is commonly used in deep learning</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: image2vector</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2vector</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    image -- a numpy array of shape (length, height, depth)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    v -- a vector of shape (length*height*depth, 1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    v = image.reshape(image.shape[<span class="number">0</span>]*image.shape[<span class="number">1</span>]*image.shape[<span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure></li><li><p>np.reshape is widely used. In the future, you’ll see that keeping your matrix/vector dimensions straight will go toward eliminating a lot of bugs.</p></li><li>numpy has efficient built-in functions</li><li>broadcasting is extremely useful</li><li>Note that np.dot() performs a matrix-matrix or matrix-vector multiplication. This is different from np.multiply() and the * operator (which is equivalent to .* in Matlab/Octave), which performs an element-wise multiplication.</li><li>np.dot(x,x) = 所有对应位置元素相乘之和。</li><li>Vectorization is very important in deep learning. It provides computational efficiency and clarity.</li><li><p>You have reviewed the L1 and L2 loss.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1</span><span class="params">(yhat, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    yhat -- vector of size m (predicted labels)</span></span><br><span class="line"><span class="string">    y -- vector of size m (true labels)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    loss -- the value of the L1 loss function defined above</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    loss = np.sum(abs(y - yhat))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2</span><span class="params">(yhat, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    yhat -- vector of size m (predicted labels)</span></span><br><span class="line"><span class="string">    y -- vector of size m (true labels)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    loss -- the value of the L2 loss function defined above</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    loss = np.dot(y-yhat, y-yhat)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure></li><li><p>You are familiar with many numpy functions such as np.sum, np.dot, np.multiply, np.maximum, etc…</p></li></ul><h3 id="np-dot-np-outer-np-multiply"><a href="#np-dot-np-outer-np-multiply" class="headerlink" title="np.dot(),np.outer(),np.multiply(),*"></a>np.dot(),np.outer(),np.multiply(),*</h3><ol><li>np.dot()如果碰到的是秩为1的数组，那么执行的是对应位置的元素相乘再相加；如果遇到的是秩不为1的数组，那么执行的是矩阵相乘。需要注意的是矩阵与矩阵相乘是秩为2，矩阵和向量相乘秩为1。</li><li>np.multiply()表示的是数据和矩阵相应位置相乘，输出和输出的结果shape一致。</li><li>np.outer()表示的是两个向量相乘，拿第一个向量的元素<strong>分别</strong>与第二个向量所有元素相乘得到结果的一行。</li><li>*对数组执行的是对应位置相乘（成本函数里的就是这么计算！！！而不是用np.dot），对矩阵执行的是矩阵相乘。</li></ol><h2 id="Part-2-Logistic-Regression-with-a-Neural-Network-mindset"><a href="#Part-2-Logistic-Regression-with-a-Neural-Network-mindset" class="headerlink" title="Part 2: Logistic Regression with a Neural Network mindset"></a>Part 2: Logistic Regression with a Neural Network mindset</h2><p>这部分作业是完成一个Logistic回归算法，来分辨图片是否为猫。</p><h3 id="数据集预处理"><a href="#数据集预处理" class="headerlink" title="数据集预处理"></a>数据集预处理</h3><p>很多时候，我们经常会遇到的bug是有关于矩阵/向量维数的，因此我们必须保证清楚了解自己设置的矩阵维数是否正确。因此在写代码的过程中，时不时使用X.shape查看矩阵/向量的维数。</p><p>有关X.reshape()的一个小技巧：A trick when you want to flatten a matrix X of shape (a,b,c,d) to a matrix X_flatten of shape (b ∗ c ∗ d, a) is to use: 这样子之后，矩阵的每一列都是一个样本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_flatten = X.reshape(X.shape[<span class="number">0</span>], <span class="number">-1</span>).T      <span class="comment"># X.T is the transpose of X</span></span><br></pre></td></tr></table></figure></p><p><strong>What we need to remember:</strong><br>Common steps for pre-processing a new dataset are:</p><ul><li>Figure out the dimensions and shapes of the problem (m_train, m_test, num_px, …)</li><li>Reshape the datasets such that each example is now a vector of size(num_px*num_px*3,1)</li><li>“Standardize” the data 标准化</li></ul><h3 id="Gereral-Architecture-of-the-learning-algorithm"><a href="#Gereral-Architecture-of-the-learning-algorithm" class="headerlink" title="Gereral Architecture of the learning algorithm"></a>Gereral Architecture of the learning algorithm</h3><p><img src="https://upload-images.jianshu.io/upload_images/8636110-20e5400369b44374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-7ac0d47a6a9ba9c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>关键步骤：</p><ul><li>Initialize the parameters of the model</li><li>Learn the parameters for the model by minimizing the cost  </li><li>Use the learned parameters to make predictions (on the test set)</li><li>Analyse the results and conclude</li></ul><h3 id="算法的各个模块"><a href="#算法的各个模块" class="headerlink" title="算法的各个模块"></a>算法的各个模块</h3><p>主要步骤：</p><ol><li>Define the model structure (such as number of input features)</li><li>Initialize the model’s parameters</li><li>Loop:<ul><li>Calculate current loss (forward propagation)</li><li>Calculate current gradient (backward propagation)</li><li>Update parameters (gradient descent)</li></ul></li></ol><h4 id="Helper-functions-Sigmoid"><a href="#Helper-functions-Sigmoid" class="headerlink" title="Helper functions-Sigmoid"></a>Helper functions-Sigmoid</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute the sigmoid of z</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    z -- A scalar or numpy array of any size.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    s -- sigmoid(z)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    s = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="初始化参数-Initializing-parameters"><a href="#初始化参数-Initializing-parameters" class="headerlink" title="初始化参数-Initializing parameters"></a>初始化参数-Initializing parameters</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_with_zeros</span><span class="params">(dim)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function creates a vector of zeros of shape (dim, 1) for w and initializes b to 0.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Argument:</span></span><br><span class="line"><span class="string">    dim -- size of the w vector we want (or number of parameters in this case)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    w -- initialized vector of shape (dim, 1)</span></span><br><span class="line"><span class="string">    b -- initialized scalar (corresponds to the bias)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    w = np.zeros((dim, <span class="number">1</span>))</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(w.shape == (dim, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">assert</span>(isinstance(b, float) <span class="keyword">or</span> isinstance(b, int))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure><h4 id="Forward-and-Backward-propagation"><a href="#Forward-and-Backward-propagation" class="headerlink" title="Forward and Backward propagation"></a>Forward and Backward propagation</h4><p>要用到的公式：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f065864226e11d7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这里有个地方我以前经常搞混，就是不知道什么时候用np.dot，np.multiply和*，现在清楚了：普通的矩阵乘法就是用np.dot，而对应位置相乘，如上图里面cost function的计算，则要用到np.multiply或者*。弄清楚了就不会错了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implement the cost function and its gradient for the propagation explained above</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string">    b -- bias, a scalar</span></span><br><span class="line"><span class="string">    X -- data of size (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string">    Y -- true "label" vector (containing 0 if non-cat, 1 if cat) of size (1, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    cost -- negative log-likelihood cost for logistic regression</span></span><br><span class="line"><span class="string">    dw -- gradient of the loss with respect to w, thus same shape as w</span></span><br><span class="line"><span class="string">    db -- gradient of the loss with respect to b, thus same shape as b</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Tips:</span></span><br><span class="line"><span class="string">    - Write your code step by step for the propagation. np.log(), np.dot()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    m = X.shape[<span class="number">1</span>] <span class="comment"># 样本数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># FORWARD PROPAGATION (FROM X TO COST)</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    A = sigmoid(np.dot(w.T, X) + b)</span><br><span class="line">    cost = -(<span class="number">1.0</span>/m) * np.sum(Y*np.log(A) + (<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A))</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># BACKWARD PROPAGATION (TO FIND GRAD)</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">    dw = np.dot(X, (A-Y).T) / m</span><br><span class="line">    db = np.sum(A-Y) / m</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="keyword">assert</span>(dw.shape == w.shape)</span><br><span class="line">    <span class="keyword">assert</span>(db.dtype == float)</span><br><span class="line">    cost = np.squeeze(cost)</span><br><span class="line">    <span class="keyword">assert</span>(cost.shape == ())</span><br><span class="line">    </span><br><span class="line">    grads = &#123;<span class="string">"dw"</span>: dw,</span><br><span class="line">             <span class="string">"db"</span>: db&#125;</span><br><span class="line">    <span class="keyword">return</span> grads, cost</span><br></pre></td></tr></table></figure><h4 id="Optimization-更新"><a href="#Optimization-更新" class="headerlink" title="Optimization-更新"></a>Optimization-更新</h4><p>利用更新公式: theta = theta - alpha * dtheta<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(w, b, X, Y, num_iterations, learning_rate, print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This function optimizes w and b by running a gradient descent algorithm</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string">    b -- bias, a scalar</span></span><br><span class="line"><span class="string">    X -- data of shape (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string">    Y -- true "label" vector (containing 0 if non-cat, 1 if cat), of shape (1, number of examples)</span></span><br><span class="line"><span class="string">    num_iterations -- number of iterations of the optimization loop</span></span><br><span class="line"><span class="string">    learning_rate -- learning rate of the gradient descent update rule</span></span><br><span class="line"><span class="string">    print_cost -- True to print the loss every 100 steps</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    params -- dictionary containing the weights w and bias b</span></span><br><span class="line"><span class="string">    grads -- dictionary containing the gradients of the weights and bias with respect to the cost function</span></span><br><span class="line"><span class="string">    costs -- list of all the costs computed during the optimization, this will be used to plot the learning curve.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Tips:</span></span><br><span class="line"><span class="string">    You basically need to write down two steps and iterate through them:</span></span><br><span class="line"><span class="string">        1) Calculate the cost and the gradient for the current parameters. Use propagate().</span></span><br><span class="line"><span class="string">        2) Update the parameters using gradient descent rule for w and b.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    costs = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Cost and gradient calculation (≈ 1-4 lines of code)</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### </span></span><br><span class="line">        grads, cost = propagate(w, b, X, Y)</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Retrieve derivatives from grads</span></span><br><span class="line">        dw = grads[<span class="string">"dw"</span>]</span><br><span class="line">        db = grads[<span class="string">"db"</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># update rule (≈ 2 lines of code)</span></span><br><span class="line">        <span class="comment">### START CODE HERE ###</span></span><br><span class="line">        w = w - learning_rate*dw</span><br><span class="line">        b = b - learning_rate*db</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Record the costs</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            costs.append(cost)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Print the cost every 100 training examples</span></span><br><span class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</span><br><span class="line">    </span><br><span class="line">    params = &#123;<span class="string">"w"</span>: w,</span><br><span class="line">              <span class="string">"b"</span>: b&#125;</span><br><span class="line">    </span><br><span class="line">    grads = &#123;<span class="string">"dw"</span>: dw,</span><br><span class="line">             <span class="string">"db"</span>: db&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> params, grads, costs</span><br></pre></td></tr></table></figure></p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, b, X)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    w -- weights, a numpy array of size (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string">    b -- bias, a scalar</span></span><br><span class="line"><span class="string">    X -- data of size (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m))</span><br><span class="line">    w = w.reshape(X.shape[<span class="number">0</span>], <span class="number">1</span>) <span class="comment"># 保证维数正确</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute vector "A" predicting the probabilities of a cat being present in the picture</span></span><br><span class="line">    <span class="comment">### START CODE HERE ### (≈ 1 line of code)</span></span><br><span class="line">    A = sigmoid(np.dot(w.T,X) + b)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Convert probabilities A[0,i] to actual predictions p[0,i]</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### (≈ 4 lines of code)</span></span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>][i] &gt; <span class="number">0.5</span>: </span><br><span class="line">            Y_prediction[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Y_prediction[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>, m))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Y_prediction</span><br></pre></td></tr></table></figure><h3 id="合并模块-Merge-all-functions-into-a-model"><a href="#合并模块-Merge-all-functions-into-a-model" class="headerlink" title="合并模块-Merge all functions into a model"></a>合并模块-Merge all functions into a model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train, Y_train, X_test, Y_test, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.5</span>, print_cost = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Builds the logistic regression model by calling the function you've implemented previously</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X_train -- training set represented by a numpy array of shape (num_px * num_px * 3, m_train)</span></span><br><span class="line"><span class="string">    Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train)</span></span><br><span class="line"><span class="string">    X_test -- test set represented by a numpy array of shape (num_px * num_px * 3, m_test)</span></span><br><span class="line"><span class="string">    Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test)</span></span><br><span class="line"><span class="string">    num_iterations -- hyperparameter representing the number of iterations to optimize the parameters</span></span><br><span class="line"><span class="string">    learning_rate -- hyperparameter representing the learning rate used in the update rule of optimize()</span></span><br><span class="line"><span class="string">    print_cost -- Set to true to print the cost every 100 iterations</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    d -- dictionary containing information about the model.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize parameters with zeros (≈ 1 line of code)</span></span><br><span class="line">    w, b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Gradient descent (≈ 1 line of code)</span></span><br><span class="line">    params, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve parameters w and b from dictionary "parameters"</span></span><br><span class="line">    w = params[<span class="string">"w"</span>]</span><br><span class="line">    b = params[<span class="string">"b"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Predict test/train set examples (≈ 2 lines of code)</span></span><br><span class="line">    Y_prediction_train = predict(w, b, X_train)</span><br><span class="line">    Y_prediction_test = predict(w, b, X_test)</span><br><span class="line"></span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print train/test Errors</span></span><br><span class="line">    print(<span class="string">"train accuracy: &#123;&#125; %"</span>.format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_train - Y_train)) * <span class="number">100</span>))</span><br><span class="line">    print(<span class="string">"test accuracy: &#123;&#125; %"</span>.format(<span class="number">100</span> - np.mean(np.abs(Y_prediction_test - Y_test)) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    d = &#123;<span class="string">"costs"</span>: costs,</span><br><span class="line">         <span class="string">"Y_prediction_test"</span>: Y_prediction_test, </span><br><span class="line">         <span class="string">"Y_prediction_train"</span> : Y_prediction_train, </span><br><span class="line">         <span class="string">"w"</span> : w, </span><br><span class="line">         <span class="string">"b"</span> : b,</span><br><span class="line">         <span class="string">"learning_rate"</span> : learning_rate,</span><br><span class="line">         <span class="string">"num_iterations"</span>: num_iterations&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="keyword">True</span>) <span class="comment">#训练</span></span><br></pre></td></tr></table></figure><h3 id="有关学习率的进一步学习"><a href="#有关学习率的进一步学习" class="headerlink" title="有关学习率的进一步学习"></a>有关学习率的进一步学习</h3><p>If the learning rate is too large we may “overshoot” the optimal value. Similarly, if it is too small we will need too many iterations to converge to the best values. That’s why it is crucial to use a well-tuned(精心调整) learning rate.</p><p>In deep learning, 我们建议：</p><ol><li>Choose the learning rate that better minimizes the cost function. 选择合适的学习率。</li><li>If your model overfits, use other techniques to reduce overfitting. (We’ll talk about this in later videos.) 减少过拟合。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次任务，我们学习到：</p><ol><li>Preprocessing the dataset is important.</li><li>You implemented each function separately: initialize(), propagate(), optimize(). Then you built a model().</li><li>Tuning the learning rate (which is an example of a “hyperparameter”) can make a big difference to the algorithm. You will see more examples of this later in this course!</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面进入神经网络基础的学习，这部分大多已经学过了，这里就当作是一次复习。&lt;/p&gt;
&lt;h1 id=&quot;二元分类-Binary-Classification&quot;&gt;&lt;a href=&quot;#二元分类-Binary-Classification&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="深度学习" scheme="https://github.com/DesmonDay/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>第一周-深度学习概论</title>
    <link href="https://github.com/DesmonDay/2019/04/01/deep-learningw1/"/>
    <id>https://github.com/DesmonDay/2019/04/01/deep-learningw1/</id>
    <published>2019-04-01T07:48:01.000Z</published>
    <updated>2019-04-01T09:15:16.373Z</updated>
    
    <content type="html"><![CDATA[<p>今天，愚人节。开始学习吴恩达的deep learning课程！！（这个不是愚人节节目）因为学费还是有点贵，所以打算在网易云课堂看对应的免费课程，只是这样就没法交作业批改了。因此作业这块会去看看别人博客里记录的作业内容，自己完成后对比一下别人的结果就好。哇，省了一大笔钱，真好。</p><h1 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h1><p>“深度学习”指的是训练神经网络，并且神经网络的规模比较大。依旧是房价预测的例子：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-a4c69d5a968935fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到右下角，我们可以称其为最简单的神经网络结构，即单神经元网络(single neural network)。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-8916348065e0eb14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>更大一点的神经网络，则将这些神经元进行堆叠，得到大一点的神经网络。仍然以房价预测为例，假设我们不仅知道size，还知道bedroom的数量，邮编(zip code / posted code)，wealth等等，得到以下神经网络：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-491f70f358ed02a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其中x是神经网络的输入，而y则是输出，中间节电成为隐藏结点。画成更简洁的形式如下：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-96dfed4dea7195ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>给定足够的训练数据(x,y)(training examples)，那么神经网络非常擅长于计算从X到Y的精准映射函数(figuring out functions that accurately map from x to y)。</p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>简单例子：神经网络在在线网络(online ad)取得了很大成功，同样的也是计算机视觉、语音识别、机器翻译、无人驾驶等领域有着巨大应用。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-a54dd1376b4fd78d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>因此我们需要机智且正确的选择X和y，才能解决我们特定的问题。房地产和在线广告，用的是相对标准的神经网络；图像邻域则常用卷积神经网络(CNN)；对于序列数据，如音频含有时间成分(一维时间序列)，语言，经常使用RNN；而无人驾驶(计算机视觉,radar)则需要更多复杂的神经网络。RNN非常适合用来处理一维序列数据（包含时间成分）。部分网络结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-5d488b501cd48aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>结构化数据和非结构化数据的区分：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-55d0951d45f80c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="为什么深度学习会兴起"><a href="#为什么深度学习会兴起" class="headerlink" title="为什么深度学习会兴起"></a>为什么深度学习会兴起</h1><p>普通机器学习无法处理大规模数据，而如今我们已经获得了海量数据，因此需要使用深度学习来进行大型训练。如以下例子:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-a301992dbb2aaf97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>因此我们说，“规模”不断推动着神经网络的进步，这里的“规模”既指神经网络本身的规模（更多的隐藏层结点，更多的权重和连接），也指数据规模。符号标记：(X,y)训练数据，m表示数据集规模。当数据集较小时，一般比较手工设计组件(hand engineer feature)，如SVM表现上更好。因此在此图左侧，每个算法的性能定义得并不明确，更多取决于设计细节；只有在大数据邻域，我们可以看到神经网络稳定超越其他算法。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-54c712695baf94e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>除了有数据规模的扩大和计算能力的增强，我们的算法也不断得到优化。如上图中举例Sigmoid函数和ReLu函数，因为Sigmoid函数在后半段的梯度接近0，因此会导致学习速度减慢（梯度下降法），因此通过改变激活函数为ReLu，可以使梯度下降的速度加快。</p><p>在实现神经网络时，迭代速度对效率影响很大，因此计算速度的提升有利于提高迭代速度。</p><h1 id="本部分的学习内容"><a href="#本部分的学习内容" class="headerlink" title="本部分的学习内容"></a>本部分的学习内容</h1><p><img src="https://upload-images.jianshu.io/upload_images/8636110-90d9e634b92545a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="第一周作业"><a href="#第一周作业" class="headerlink" title="第一周作业"></a>第一周作业</h1><p>十道选择题，这里就不贴了。记录一些关键点：</p><ol><li>一个表现很好的深度学习模型，并不是仅靠经验就能立马找到的。虽然经验很重要，但要找到一个表现很好的模型，都需要尝试，修复，不断完善的一个过程。</li><li>一个团队如果能更快的用代码实现想法，或者写出来的代码（算法）更好，或者科学家研究出了更优秀的算法，上述循环过程都会更短，从而提高效率。</li><li>Leaky ReLu:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-41c4532d2e603676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>激活函数相关：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7e7cda8575746ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>RNN相关：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-bfd240bf75000aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>选择AC。此题考查我们对RNN（循环神经网络）的了解。RNN在语音识别，语言建模，翻译，图片描述等问题上已经取得一定成功。它是一种监督学习，比如输入数据英文，标签为法文。RNN 可以被看做是同一神经网络的多次赋值，每个神经网络模块会把消息传递给下一个，所以它是链式的，链式的特征揭示了 RNN 本质上是与序列和列表相关的，所以它在解决sequence上是毫无问题的。要说哪个完全比另一个强，基本都是错的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，愚人节。开始学习吴恩达的deep learning课程！！（这个不是愚人节节目）因为学费还是有点贵，所以打算在网易云课堂看对应的免费课程，只是这样就没法交作业批改了。因此作业这块会去看看别人博客里记录的作业内容，自己完成后对比一下别人的结果就好。哇，省了一大笔钱，真好
      
    
    </summary>
    
      <category term="深度学习" scheme="https://github.com/DesmonDay/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>LASER-句子嵌入</title>
    <link href="https://github.com/DesmonDay/2019/04/01/LASER/"/>
    <id>https://github.com/DesmonDay/2019/04/01/LASER/</id>
    <published>2019-04-01T03:04:42.000Z</published>
    <updated>2019-04-01T07:47:51.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>最好是Linux环境，Windows没有试。</p><p>老师直接下载邮件附件的LASER压缩包(里面包括了已经下载好的模型)即可，直接Extract here。解压出来为LASER文件夹，文件夹的位置即为其安装位置，后面环境变量会用到。文件夹内部内容为下图：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-13a57c3e4782eb58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h1><ol><li>python 3.6, numpy</li><li><p>pytorch 1.0(这个老师应该装了吧？)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu版本: conda install pytorch-cpu torchvision-cpu(我用的Anaconda，且环境是虚拟机，所以用的是这个命令)</span><br><span class="line">gpu版本: pip install torch torchvision</span><br></pre></td></tr></table></figure></li><li><p>Faiss(需要把镜像源换成 mirrors.ustc.edu.cn/ubuntu/ 才能正常下载)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install faiss</span><br></pre></td></tr></table></figure></li><li><p>jieba，中文分词器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br></pre></td></tr></table></figure></li></ol><h1 id="其他必要步骤"><a href="#其他必要步骤" class="headerlink" title="其他必要步骤"></a>其他必要步骤</h1><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">在文件末尾添加，双引号内为LASER的安装目录</span><br><span class="line">LASER=&quot;/home/desmon/LASER&quot; </span><br><span class="line"></span><br><span class="line">source .baserc</span><br></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>因为老师只需要得到句子的嵌入和两个句子之间的相似度，这里我只介绍在embed文件夹中如何使用其预训练模型（其他的我也没试过，囧）。</p><ol><li>进入tasks/embed文件夹，将要计算相似度的句子写成文件，如下图input文件（这里举例为中文，也可以多个句子，每个句子要自成一行）。<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f2c34371ba5cc00c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li><p>命令：input-file和output-file即我们对应的输入输出文件，由于输出的格式为二进制，所以之后要处理。而LANGUAGE则为对应的语言，如 中文对应cmn, 英文对应eng，法语对应fr等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash ./embed.sh INPUT-FILE LANGUAGE OUTPUT-FILE</span><br><span class="line"></span><br><span class="line">例如：bash ./embed.sh input cmn output</span><br></pre></td></tr></table></figure></li><li><p>将二进制输出可视化，对应embed文件夹里的main.py，老师需要将里面的output改为自己设置的输出名字。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line"></span><br><span class="line">dim = <span class="number">1024</span></span><br><span class="line">X = np.fromfile(<span class="string">"output"</span>,dtype=np.float32,count=<span class="number">-1</span>)</span><br><span class="line">X.resize(X.shape[<span class="number">0</span>]//dim, dim)</span><br><span class="line">print(cosine_similarity(X))</span><br></pre></td></tr></table></figure><p>修改正确后直接运行此py文件，即可得到对应的余弦相似度矩阵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;&lt;p&gt;最好是Linux环境，Windows没有试。&lt;/p&gt;
&lt;p&gt;老师直接下载邮件附件的LASER压缩包(里面包括了已经下载好的模型)即可，直接E
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
      <category term="embedding" scheme="https://github.com/DesmonDay/tags/embedding/"/>
    
  </entry>
  
  <entry>
    <title>hdoj3342-拓扑排序</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj3342/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj3342/</id>
    <published>2019-03-10T04:05:51.000Z</published>
    <updated>2019-03-10T04:08:09.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述-Legal-or-not"><a href="#题目描述-Legal-or-not" class="headerlink" title="题目描述-Legal or not"></a>题目描述-Legal or not</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many “holy cows” like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost “master”, and Lost will have a nice “prentice”. By and by, there are many pairs of “master and prentice”. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?</p><p>We all know a master can have many prentices and a prentice may have a lot of masters too, it’s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian’s master and, at the same time, 3xian is HH’s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not. </p><p>Please note that the “master and prentice” relation is transitive. It means that if A is B’s master ans B is C’s master, then A is C’s master.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y’s master and y is x’s prentice. The input is terminated by N = 0.<br>TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,…, N-1). We use their numbers instead of their names.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, print in one line the judgement of the messy relationship.<br>If it is legal, output “YES”, otherwise “NO”.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>判断是否为有向无环图，使用拓扑排序的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[<span class="number">110</span>];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> inDegree[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty()) S.pop();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            inDegree[b]++;</span><br><span class="line">            edge[a].push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                S.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[x].size(); i++)&#123;</span><br><span class="line">                j = edge[x][i];</span><br><span class="line">                inDegree[j]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[j] == <span class="number">0</span>) S.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == n) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述-Legal-or-not&quot;&gt;&lt;a href=&quot;#题目描述-Legal-or-not&quot; class=&quot;headerlink&quot; title=&quot;题目描述-Legal or not&quot;&gt;&lt;/a&gt;题目描述-Legal or not&lt;/h1&gt;&lt;h2 id=&quot;Probl
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj2544-最短路径</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj2544/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj2544/</id>
    <published>2019-03-10T03:59:32.000Z</published>
    <updated>2019-03-10T04:12:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述-最短路"><a href="#题目描述-最短路" class="headerlink" title="题目描述-最短路"></a>题目描述-最短路</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>此题的结点数量为100，可以使用Floyed算法来解决，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000 <span class="comment">// we can use -1</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        fill(dist[<span class="number">0</span>],dist[<span class="number">0</span>]+<span class="number">101</span>*<span class="number">101</span>, INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dist[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;;</span><br><span class="line">            dist[a][b] = c;</span><br><span class="line">            dist[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)&#123; <span class="comment">//k,i,j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[i][k] == INF || dist[k][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dist[i][j] == INF || dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dist[<span class="number">1</span>][n]&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，也可以用Dijkstra算法来写。Dijkstra算法适合单源最短路径，当结点数量比较大时得使用这种算法，只是写起来会相对比较麻烦。注意下面的newP这个点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next; <span class="comment">//neighbor</span></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">//weight</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;E&gt; edge[<span class="number">101</span>]; <span class="comment">//LinkedList</span></span><br><span class="line"><span class="keyword">bool</span> mark[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) edge[i].clear();<span class="comment">//initialize</span></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            E temp;</span><br><span class="line">            temp.c = c;</span><br><span class="line">            temp.next = b;</span><br><span class="line">            edge[a].push_back(temp);</span><br><span class="line">            temp.next = a;</span><br><span class="line">            edge[b].push_back(temp);<span class="comment">//non-directional</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            dis[i] = <span class="number">-1</span>; <span class="comment">// not access</span></span><br><span class="line">            mark[i] = <span class="literal">false</span>; <span class="comment">// no belong to set K</span></span><br><span class="line">        &#125;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//length = 0, the most near point</span></span><br><span class="line">        mark[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> newP = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;<span class="comment">//to define the rest n-1 point</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;edge[newP].size(); j++)&#123; <span class="comment">//遍历邻居</span></span><br><span class="line">                <span class="keyword">int</span> t = edge[newP][j].next;</span><br><span class="line">                <span class="keyword">int</span> c = edge[newP][j].c;</span><br><span class="line">                <span class="keyword">if</span>(mark[t] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[t] == <span class="number">-1</span> || dis[t] &gt; dis[newP] + c)&#123;</span><br><span class="line">                    dis[t] = dis[newP] + c;<span class="comment">//update dis</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">123123123</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[j] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[j] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dis[j] &lt; min)&#123; <span class="comment">//找距离最短的点</span></span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    newP = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mark[newP] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述-最短路&quot;&gt;&lt;a href=&quot;#题目描述-最短路&quot; class=&quot;headerlink&quot; title=&quot;题目描述-最短路&quot;&gt;&lt;/a&gt;题目描述-最短路&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-De
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj2094-拓扑排序</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj2094/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj2094/</id>
    <published>2019-03-10T03:54:26.000Z</published>
    <updated>2019-03-10T03:59:08.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述-产生冠军"><a href="#题目描述-产生冠军" class="headerlink" title="题目描述-产生冠军"></a>题目描述-产生冠军</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Alice Bob</span><br><span class="line">Smith John</span><br><span class="line">Alice Smith</span><br><span class="line">5</span><br><span class="line">a c</span><br><span class="line">c d</span><br><span class="line">d e</span><br><span class="line">b e</span><br><span class="line">a d</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>这题貌似只要入度为0的点唯一，就能产生冠军了。。而按照拓扑排序的原先步骤那样写的话，结果又是不正确的，不明白。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hdoj 2094</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入度为0的点唯一说明有冠军</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> inDegree[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        M.clear();</span><br><span class="line">        <span class="comment">//S.clear(); 没有此函数</span></span><br><span class="line">        <span class="keyword">while</span>(!S.empty()) S.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n; i++)&#123;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(M.count(a) == <span class="number">0</span>) M[a] = k++;</span><br><span class="line">            <span class="keyword">if</span>(M.count(b) == <span class="number">0</span>) M[b] = k++;</span><br><span class="line">            inDegree[M[b]] += <span class="number">1</span>;</span><br><span class="line">            edge[M[a]].push_back(M[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;k; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(inDegree[i] == 0) S.push(i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int cnt = 0;</span></span><br><span class="line"><span class="comment">        while(!S.empty())&#123;</span></span><br><span class="line"><span class="comment">            int x = S.top();</span></span><br><span class="line"><span class="comment">            S.pop();</span></span><br><span class="line"><span class="comment">            cnt++;</span></span><br><span class="line"><span class="comment">            for(int i=0; i&lt;edge[x].size(); i++)&#123;</span></span><br><span class="line"><span class="comment">                inDegree[edge[x][i]]--;</span></span><br><span class="line"><span class="comment">                if(inDegree[edge[x][i]] == 0) S.push(edge[x][i]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;k; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; inDegree[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述-产生冠军&quot;&gt;&lt;a href=&quot;#题目描述-产生冠军&quot; class=&quot;headerlink&quot; title=&quot;题目描述-产生冠军&quot;&gt;&lt;/a&gt;题目描述-产生冠军&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Proble
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj2037-贪心</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj2037/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj2037/</id>
    <published>2019-03-10T03:48:22.000Z</published>
    <updated>2019-03-10T03:53:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述-今年暑假不AC"><a href="#题目描述-今年暑假不AC" class="headerlink" title="题目描述-今年暑假不AC"></a>题目描述-今年暑假不AC</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%…”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">0 7</span><br><span class="line">3 8</span><br><span class="line">15 19</span><br><span class="line">15 20</span><br><span class="line">10 15</span><br><span class="line">8 18</span><br><span class="line">6 12</span><br><span class="line">5 10</span><br><span class="line">4 14</span><br><span class="line">2 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>使用贪心法则，比较麻烦的是怎么做最贪心，且结果最好，因为贪心策略并不是每次都显而易见的。可以通过分析知道，最优解中，第一个观看的节目一定是所有节目里结束时间最早的节目。因此，要按照结束时间进行升序排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TVshow</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> TVshow &amp;A) <span class="keyword">const</span>&#123; <span class="comment">//用于排序，结束时间越早排前面</span></span><br><span class="line">        <span class="keyword">return</span> end &lt; A.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;buf[i].start, &amp;buf[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(buf, buf+n);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, currentTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentTime &lt;= buf[idx].start)&#123;</span><br><span class="line">                currentTime = buf[idx].end;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述-今年暑假不AC&quot;&gt;&lt;a href=&quot;#题目描述-今年暑假不AC&quot; class=&quot;headerlink&quot; title=&quot;题目描述-今年暑假不AC&quot;&gt;&lt;/a&gt;题目描述-今年暑假不AC&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1856-并查集</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1856/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1856/</id>
    <published>2019-03-10T03:43:00.000Z</published>
    <updated>2019-03-10T03:47:52.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述-More-is-better"><a href="#题目描述-More-is-better" class="headerlink" title="题目描述-More is better"></a>题目描述-More is better</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Mr Wang wants some boys to help him with a project. Because the project is rather complex, the more boys come, the better it will be. Of course there are certain requirements.</p><p>Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of the input contains an integer n (0 ≤ n ≤ 100 000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A ≠ B, 1 ≤ A, B ≤ 10000000)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep. </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">1 6</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Hint</p><p>A and B are friends(direct or indirect), B and C are friends(direct or indirect),<br>then A and C are also friends(indirect).</p><p>In the first sample {1,2,5,6} is the result.<br>In the second sample {1,2},{3,4},{5,6},{7,8} are four kinds of answers.</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>本题使用并查集来解决。就是看这题能够形成的最大簇的数量是多少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Tree[N];</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRoot</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree[i] == <span class="number">-1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = FindRoot(Tree[i]);</span><br><span class="line">        Tree[i] = temp;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">            Tree[i] = <span class="number">-1</span>;  <span class="comment">//全部初始化为-1</span></span><br><span class="line">            sum[i] = <span class="number">1</span>; <span class="comment">//初始化为1 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            a = FindRoot(a); <span class="comment">// a结点所在的根 </span></span><br><span class="line">            b = FindRoot(b);</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                Tree[a] = b; <span class="comment">//b是根节点！ </span></span><br><span class="line">                sum[b] += sum[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">// 至少有1个男孩 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Tree[i] == <span class="number">-1</span> &amp;&amp; ans &lt; sum[i])  <span class="comment">//搞清楚谁大于，谁小于！ </span></span><br><span class="line">                ans = sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述-More-is-better&quot;&gt;&lt;a href=&quot;#题目描述-More-is-better&quot; class=&quot;headerlink&quot; title=&quot;题目描述-More is better&quot;&gt;&lt;/a&gt;题目描述-More is better&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1285-拓扑排序</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1285/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1285/</id>
    <published>2019-03-10T03:38:02.000Z</published>
    <updated>2019-03-10T03:42:21.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>本次用拓扑排序来解决。设置一个vector数组来保存有向图，另外需要设置入度数组来查找入度为0的点。同时，设置一个队列来进行遍历，另外注意，符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前，因此使用小顶堆，优先弹出的是入度为0且编号较小的号码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[<span class="number">501</span>];</span><br><span class="line">    <span class="comment">//符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；</span></span><br><span class="line">    <span class="comment">//因此使用小顶堆，优先弹出的是入度为0且编号较小的号码。 </span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> inDegree[<span class="number">501</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//n为队伍个数，m为输入行数 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        res.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            inDegree[b] += <span class="number">1</span>;</span><br><span class="line">            edge[a].push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> newP = q.top(); <span class="comment">// 优先队列的顶部用top()，而不是用front()</span></span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(newP);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[newP].size(); i++)&#123;</span><br><span class="line">                inDegree[edge[newP][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[edge[newP][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.push(edge[newP][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1253-BFS</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1253/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1253/</id>
    <published>2019-03-10T03:31:09.000Z</published>
    <updated>2019-03-10T03:46:57.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A*B*C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-c87493aba0e9347c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p><p>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>这题相当于走迷宫的题，走迷宫一般用广搜！！广度优先搜索，即在遍历解答树时使每次状态转移时扩展出尽可能多的新状态，并且按照各个状态出现的先后顺序依次扩展它们。当搜索过程中第一次查找到状态中坐标为终点的结点，其记录的时间即为所需最短时间。</p><p>另外，广搜使用队列来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索，同时，在扩展的时候注意剪枝，即将不可能的状态不进行扩展。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了实现各个状态按照其被查找到的顺序依次转移扩展，使用队列;</span></span><br><span class="line"><span class="comment">// 即将每次扩展得到的新状态放入队列中，待排在其之前的状态都被扩展完成后，该状态才能得到扩展</span></span><br><span class="line"><span class="keyword">bool</span> mark[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">//标记数组，如果已经得到过包含坐标(x,y,z)的状态后，则置为true </span></span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">//保存立方体信息 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体保存每一个状态 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z; <span class="comment">//位置坐标</span></span><br><span class="line">    <span class="keyword">int</span> t; <span class="comment">// 所需时间 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;State&gt; Q; <span class="comment">//队列，队列中的元素为状态</span></span><br><span class="line"><span class="keyword">int</span> go[][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">//坐标变换数组(x+go[i][0],y+go[i][1],z+go[i][2])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="comment">//广度优先搜索 </span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        State now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123; <span class="comment">//依次扩展其六个相邻结点 </span></span><br><span class="line">            <span class="keyword">int</span> nx = now.x + go[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny = now.y + go[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> nz = now.z + go[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= a || ny &lt; <span class="number">0</span> || ny &gt;= b || nz &lt; <span class="number">0</span> || nz &gt;= c) <span class="keyword">continue</span>; <span class="comment">//丢弃该坐标</span></span><br><span class="line">            <span class="keyword">if</span>(maze[nx][ny][nz] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//若该位置为墙，丢弃</span></span><br><span class="line">            <span class="keyword">if</span>(mark[nx][ny][nz] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">//若包含该坐标的状态已经被得到过，丢弃</span></span><br><span class="line">            State tmp;</span><br><span class="line">            tmp.x = nx;</span><br><span class="line">            tmp.y = ny;</span><br><span class="line">            tmp.z = nz;</span><br><span class="line">            tmp.t = now.t + <span class="number">1</span>;</span><br><span class="line">            Q.push(tmp);</span><br><span class="line">            mark[nx][ny][nz] = <span class="literal">true</span>; <span class="comment">//标记该坐标</span></span><br><span class="line">            <span class="keyword">if</span>(nx == a<span class="number">-1</span> &amp;&amp; ny == b<span class="number">-1</span> &amp;&amp; nz == c<span class="number">-1</span>) <span class="keyword">return</span> tmp.t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;b; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;c; k++)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;maze[i][j][k]);</span><br><span class="line">                    mark[i][j][k] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">        mark[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">//标记起点</span></span><br><span class="line">        State tmp;</span><br><span class="line">        tmp.t = tmp.y = tmp.x = tmp.z = <span class="number">0</span>; <span class="comment">//初始化状态</span></span><br><span class="line">        Q.push(tmp);</span><br><span class="line">        <span class="keyword">int</span> rec = BFS(a, b, c);</span><br><span class="line">        <span class="keyword">if</span>(rec &lt;= t) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rec);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1016-素数环递归</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1016/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1016/</id>
    <published>2019-03-10T03:25:54.000Z</published>
    <updated>2019-03-10T03:30:22.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>A ring is compose of n circles as shown in diagram. Put natural number 1, 2, …, n into each circle separately, and the sum of numbers in two adjacent circles should be a prime.</p><p>Note: the number of first circle should always be 1.</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-b21057e80ad98f20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>n (0 &lt; n &lt; 20).</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.</p><p>You are to write a program that completes above process.</p><p>Print a blank line after each case.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">1 4 3 2 5 6</span><br><span class="line">1 6 5 2 3 4</span><br><span class="line"></span><br><span class="line">Case 2:</span><br><span class="line">1 2 3 8 5 6 7 4</span><br><span class="line">1 2 5 8 3 4 7 6</span><br><span class="line">1 4 7 6 5 8 3 2</span><br><span class="line">1 6 7 4 3 8 5 2</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>这题对我来说有些难，最主要是这个递归的过程有点难懂。还是要多看看代码才行，贴出来的代码还是能懂的，但是自己写却比较困难了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> prime[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgePrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(judgePrime(<span class="number">1</span>+ans[n]))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i] &amp;&amp; judgePrime(i + ans[x]))&#123;</span><br><span class="line">                visit[i] = <span class="number">1</span>;</span><br><span class="line">                ans[x+<span class="number">1</span>] = i;</span><br><span class="line">                DFS(x+<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="number">0</span>; <span class="comment">// 这里需要重置为0，以便于下次递归入口使用。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) !=EOF)&#123;</span><br><span class="line">        cas++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">22</span>; i++) visit[i] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, cas);</span><br><span class="line">        visit[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        DFS(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1009-贪心</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1009/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1009/</id>
    <published>2019-03-10T03:17:58.000Z</published>
    <updated>2019-03-10T03:22:17.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]<em> a% pounds of JavaBeans if he pays F[i]</em> a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">7 2</span><br><span class="line">4 3</span><br><span class="line">5 2</span><br><span class="line">20 3</span><br><span class="line">25 18</span><br><span class="line">24 15</span><br><span class="line">15 10</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13.333</span><br><span class="line">31.500</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>题目不难，使用贪心解决即可。但最关键的是，如何找到一个合适的贪心策略。比如这里，最合适的当然是能够找到用更少的钱买到更多的食物，因此还需要计算物品的性价比。再将性价比降序排序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> j; <span class="comment">//该物品总重</span></span><br><span class="line">    <span class="keyword">double</span> f; <span class="comment">//该物品总价值</span></span><br><span class="line">    <span class="keyword">double</span> s; <span class="comment">//该物品性价比</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> goods &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s &gt; A.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;buf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> m; <span class="comment">//总钱数</span></span><br><span class="line">    <span class="keyword">int</span> n;    <span class="comment">//n种物品</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">-1</span> &amp;&amp; n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;buf[i].j, &amp;buf[i].f);</span><br><span class="line">            buf[i].s = buf[i].j / buf[i].f; <span class="comment">//计算性价比</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(buf, buf+n); <span class="comment">//性价比降序排序，贪心算法</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span> &amp;&amp; idx &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &gt;= buf[idx].f)&#123;</span><br><span class="line">                ans += buf[idx].j;</span><br><span class="line">                m -= buf[idx].f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans += m*buf[idx].s;</span><br><span class="line">                m = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hdoj1241-DFS</title>
    <link href="https://github.com/DesmonDay/2019/03/10/hdoj1241/"/>
    <id>https://github.com/DesmonDay/2019/03/10/hdoj1241/</id>
    <published>2019-03-10T03:14:23.000Z</published>
    <updated>2019-03-10T03:47:17.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. </p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either <code>*&#39;, representing the absence of oil, or</code>@’, representing an oil pocket.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">*</span><br><span class="line">3 5</span><br><span class="line">*@*@*</span><br><span class="line">**@**</span><br><span class="line">*@*@*</span><br><span class="line">1 8</span><br><span class="line">@@****@*</span><br><span class="line">5 5 </span><br><span class="line">****@</span><br><span class="line">*@@*@</span><br><span class="line">*@**@</span><br><span class="line">@@@*@</span><br><span class="line">@@**@</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>使用DFS深搜即可解决，要注意的是，相邻点不仅仅包括直接相邻，还包括间接相邻。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到不合理的，则跳过，不用进行遍历 </span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">char</span> grid[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> mark[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上应该为8个相邻点，而不单纯指直接相邻 </span></span><br><span class="line"><span class="keyword">int</span> go[][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    mark[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + go[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ny = y + go[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(mark[nx][ny] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[nx][ny] == <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(nx, ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; grid[i][j];</span><br><span class="line">                mark[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark[i][j] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'*'</span>) <span class="keyword">continue</span>; <span class="comment">//跳过，无油 </span></span><br><span class="line">                DFS(i, j);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class
      
    
    </summary>
    
      <category term="hdoj" scheme="https://github.com/DesmonDay/categories/hdoj/"/>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习-day7</title>
    <link href="https://github.com/DesmonDay/2019/03/08/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-day7/"/>
    <id>https://github.com/DesmonDay/2019/03/08/python爬虫学习-day7/</id>
    <published>2019-03-08T01:39:50.000Z</published>
    <updated>2019-03-08T02:18:52.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="丁香园大作战"><a href="#丁香园大作战" class="headerlink" title="丁香园大作战"></a>丁香园大作战</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bs = webdriver.Chrome()</span><br><span class="line">bs.get(<span class="string">"http://www.dxy.cn"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bs.find_element_by_link_text(<span class="string">'登录'</span>).click()</span><br><span class="line">bs.find_element_by_link_text(<span class="string">'返回电脑登录'</span>).click()</span><br><span class="line">user = bs.find_element_by_name(<span class="string">'username'</span>).send_keys(<span class="string">'dxy_lfrcym19'</span>)</span><br><span class="line">password = bs.find_element_by_name(<span class="string">'password'</span>).send_keys(<span class="string">'daisiming830'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'登录'</span>)</span><br><span class="line">bs.find_element_by_xpath(<span class="string">'//button'</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">print(<span class="string">'获取信息'</span>)</span><br><span class="line">elems = bs.find_element_by_css_selector(<span class="string">".auth"</span>)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> elems:</span><br><span class="line">    auth = elem.find_element_by_tag_name(<span class="string">"a"</span>)</span><br><span class="line">    print(auth_text)</span><br></pre></td></tr></table></figure><p>没能完成，只能占坑了。我要去复习了，再见！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;丁香园大作战&quot;&gt;&lt;a href=&quot;#丁香园大作战&quot; class=&quot;headerlink&quot; title=&quot;丁香园大作战&quot;&gt;&lt;/a&gt;丁香园大作战&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习-day6-IP代理</title>
    <link href="https://github.com/DesmonDay/2019/03/06/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-day6-IP%E4%BB%A3%E7%90%86/"/>
    <id>https://github.com/DesmonDay/2019/03/06/python爬虫学习-day6-IP代理/</id>
    <published>2019-03-06T15:18:13.000Z</published>
    <updated>2019-03-06T15:53:23.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是IP"><a href="#什么是IP" class="headerlink" title="什么是IP"></a>什么是IP</h1><p>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语：IP Address），是分配给用户上网使用的网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为IPv4与IPv6两大类，但是也有其他不常用的小分类。</p><h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><h2 id="Internet体系结构"><a href="#Internet体系结构" class="headerlink" title="Internet体系结构"></a>Internet体系结构</h2><p>一个TCP/IP互联网提供了三组服务。最底层提供无连接的传送服务为其他层的服务提供了基础。第二层一个可靠的传送服务为应用层提供了一个高层平台。最高层是应用层服务。</p><h2 id="IP协议三个定义："><a href="#IP协议三个定义：" class="headerlink" title="IP协议三个定义："></a>IP协议三个定义：</h2><p>　　1. IP定义了在TCP/IP互联网上数据传送的基本单元和数据格式。<br>　　2. IP软件完成路由选择功能，选择数据传送的路径。<br>　　3. IP包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</p><h1 id="为什么会出现IP被封"><a href="#为什么会出现IP被封" class="headerlink" title="为什么会出现IP被封"></a>为什么会出现IP被封</h1><ol><li>国内服务器不可访问。</li><li>当与我们共用同一IP的其他网站上出现了违反法律法规的内容或其他不和谐内容时，国家会采取屏蔽海外服务器IP的方式，避免对国内用户造成不良影响。</li></ol><h1 id="如何应对IP被封问题"><a href="#如何应对IP被封问题" class="headerlink" title="如何应对IP被封问题"></a>如何应对IP被封问题</h1><p>参考：<a href="https://blog.csdn.net/qq_31975963/article/details/82882456" target="_blank" rel="noopener">https://blog.csdn.net/qq_31975963/article/details/82882456</a></p><ol><li>可动态设置user agent</li><li>禁用cookies</li><li>设置延迟下载</li><li>使用Google Cache</li><li>使用IP地址池（代理IP、VPN等）</li><li>使用Crawlera</li></ol><h1 id="Task：抓取西刺代理，构建自己的代理池"><a href="#Task：抓取西刺代理，构建自己的代理池" class="headerlink" title="Task：抓取西刺代理，构建自己的代理池"></a>Task：抓取西刺代理，构建自己的代理池</h1><p>参考：<a href="https://blog.csdn.net/mjp_erhuo/article/details/81332824" target="_blank" rel="noopener">https://blog.csdn.net/mjp_erhuo/article/details/81332824</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">url = <span class="string">'http://www.xicidaili.com/nn'</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.3'</span></span><br><span class="line">                         <span class="string">'6 (KHTML, like Gecko) Ubuntu Chromium/56.0.2924.7'</span></span><br><span class="line">                         <span class="string">'6 Chrome/56.0.2924.76 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_agent</span><span class="params">()</span>:</span> //动态设置user_agent</span><br><span class="line">    user_agents=[</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20"</span>,</span><br><span class="line">        <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER"</span></span><br><span class="line">    ]</span><br><span class="line">    user_agent = random.choice(user_agents)</span><br><span class="line">    <span class="keyword">return</span> user_agent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxies</span><span class="params">()</span>:</span> //抓取西刺代理的匿名代理IP</span><br><span class="line">    html = requests.get(url=url, headers=headers).text</span><br><span class="line">    pattern = <span class="string">'(\d+\.\d+\.\d+\.\d+)&lt;/td&gt;\s*&lt;td&gt;(\d+)'</span></span><br><span class="line">    re_list = re.findall(pattern, html)</span><br><span class="line">    ip_list = []</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> re_list:</span><br><span class="line">        ip = ip[<span class="number">0</span>] + <span class="string">':'</span> + ip[<span class="number">1</span>]</span><br><span class="line">        ip_list.append(ip)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_proxy</span><span class="params">(ip)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    功能: 利用百度逐个验证IP的有效性</span></span><br><span class="line"><span class="string">    :param ip: 当前被验证的IP</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    tar_url = <span class="string">"http://www.tjcu.edu.cn/"</span></span><br><span class="line">    user_agent = get_user_agent()</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: user_agent</span><br><span class="line">    &#125;</span><br><span class="line">    proxies = &#123;</span><br><span class="line">        <span class="string">"http"</span>: ip,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.get(tar_url, proxies=proxies, headers=headers, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            tmp_proxies.append(ip)</span><br><span class="line">            <span class="keyword">return</span> ip</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.raise_for_status()  <span class="comment"># 如果响应状态码不是200,主动抛出异常</span></span><br><span class="line">    <span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"验证代理IP"</span> + ip + <span class="string">"时发生如下错误 :"</span>)</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    init_proxies = get_proxies()  <span class="comment"># 获取原始代理IP</span></span><br><span class="line">    tmp_proxies = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> init_proxies:</span><br><span class="line">        tmp_proxy = test_proxy(i)  <span class="comment"># 逐个验证</span></span><br><span class="line">    print(tmp_proxies)</span><br></pre></td></tr></table></figure><p>由于自己真的很少时间学，快要复试了。所以只能学习别人的代码，等之后再重新梳理爬虫的整个流程。很抱歉！抓取结果显示如下，基本都是拒绝，想必我可能被发现了。。。(捂脸<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f373d9418206b3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>再试一下，试试代理IP：</p><p>失败，等之后再学习其他同学的好了。希望我考研复试顺利，毕设顺利，顺利毕业，顺利当上研究生！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是IP&quot;&gt;&lt;a href=&quot;#什么是IP&quot; class=&quot;headerlink&quot; title=&quot;什么是IP&quot;&gt;&lt;/a&gt;什么是IP&lt;/h1&gt;&lt;p&gt;互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为IP地址（英语
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习-day5-selenium</title>
    <link href="https://github.com/DesmonDay/2019/03/05/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-day5-selenium/"/>
    <id>https://github.com/DesmonDay/2019/03/05/python爬虫学习-day5-selenium/</id>
    <published>2019-03-05T13:25:03.000Z</published>
    <updated>2019-03-05T14:15:27.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selenium学习-待补充"><a href="#Selenium学习-待补充" class="headerlink" title="Selenium学习(待补充)"></a>Selenium学习(待补充)</h1><p>安装selenium并学习，使用该工具模拟登陆163邮箱。</p><p>首先需要下载GoogleDriver，需要与自己的Chrome版本对应。由于某些原因，官网<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a> 无法下载，于是我去国内镜像找，<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a> ，然而没有找到与自己对应的版本（好奇怪。。）迫不得已，下了个当前版本后缀最新的一个。另外，要将下载后的exe放入Chrome安装目录，同时修改环境变量。</p><p>测试成功：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7b0d96ab09585c70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-cad0b552a7d76251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="利用Selenium登录163邮箱"><a href="#利用Selenium登录163邮箱" class="headerlink" title="利用Selenium登录163邮箱"></a>利用Selenium登录163邮箱</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">bs = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://mail.163.com'</span></span><br><span class="line">bs.maximize_window()</span><br><span class="line">bs.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意，163邮箱账号密码区域的id是自动生成的，无法用于定位标签。</span></span><br><span class="line"><span class="comment"># 使用网上看来的方法：https://www.cnblogs.com/wxjly/p/7920391.html</span></span><br><span class="line"></span><br><span class="line">bs.switch_to.frame(<span class="number">0</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bs.find_element_by_name(<span class="string">"email"</span>).send_keys(<span class="string">"***@163.com"</span>)<span class="comment">#输入邮箱</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bs.find_element_by_name(<span class="string">"password"</span>).send_keys(<span class="string">"***"</span>)<span class="comment">#输入密码</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">bs.find_element_by_id(<span class="string">"dologin"</span>).click()</span><br></pre></td></tr></table></figure><p>成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Selenium学习-待补充&quot;&gt;&lt;a href=&quot;#Selenium学习-待补充&quot; class=&quot;headerlink&quot; title=&quot;Selenium学习(待补充)&quot;&gt;&lt;/a&gt;Selenium学习(待补充)&lt;/h1&gt;&lt;p&gt;安装selenium并学习，使用该工具模
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习-day4-Xpath</title>
    <link href="https://github.com/DesmonDay/2019/03/04/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-day4/"/>
    <id>https://github.com/DesmonDay/2019/03/04/python爬虫学习-day4/</id>
    <published>2019-03-04T13:22:31.000Z</published>
    <updated>2019-03-04T14:43:59.431Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习xpath，相对比较简单（也有可能是因为任务简单），直接开始操作。</p><h1 id="Xpath简单介绍"><a href="#Xpath简单介绍" class="headerlink" title="Xpath简单介绍"></a>Xpath简单介绍</h1><p>XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。 XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。其官方教程为<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a>. 我认为最重要的知识如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-a289d0dce88f9625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面为基本步骤</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://www.dxy.cn/bbs/thread/626626#626626'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(url, headers=headers)</span><br><span class="line">res.encoding = res.apparent_encoding</span><br><span class="line">html = etree.HTML(res.text)</span><br><span class="line"></span><br><span class="line">comments = html.xpath(<span class="string">'//td[@class="postbody"]/text()'</span>)</span><br><span class="line">names = html.xpath(<span class="string">'//div[@class="auth"]/a/text()'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(comments)):</span><br><span class="line">    comments[i] = comments[i].replace(<span class="string">"\n"</span>,<span class="string">""</span>).replace(<span class="string">"\t"</span>,<span class="string">""</span>).replace(<span class="string">" "</span>,<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> con, name <span class="keyword">in</span> zip(comments, names):</span><br><span class="line">    print(<span class="string">"名字：&#123;&#125;"</span>.format(name), <span class="string">" 评论：&#123;&#125;"</span>.format(con))</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>最终显示结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-439ba90f716de0b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>貌似不太对啊！！！没时间弄了，再说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习xpath，相对比较简单（也有可能是因为任务简单），直接开始操作。&lt;/p&gt;
&lt;h1 id=&quot;Xpath简单介绍&quot;&gt;&lt;a href=&quot;#Xpath简单介绍&quot; class=&quot;headerlink&quot; title=&quot;Xpath简单介绍&quot;&gt;&lt;/a&gt;Xpath简单介绍&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习-day3-BeautifulSoup</title>
    <link href="https://github.com/DesmonDay/2019/03/03/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0-day3/"/>
    <id>https://github.com/DesmonDay/2019/03/03/python爬虫学习-day3/</id>
    <published>2019-03-03T13:12:55.000Z</published>
    <updated>2019-03-03T13:55:30.980Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习BeautifulSoup，并且利用此工具爬取丁香园跟帖。BeautifulSoup官方教程：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p><p>由于教程本身很详细，这里不再进行细讲，直接开始任务的实现。进入给定的网站<a href="http://3g.dxy.cn/bbs/topic/509959#!_id=626626" target="_blank" rel="noopener">http://3g.dxy.cn/bbs/topic/509959#!_id=626626</a> ，可以发现此网站需要登录才能够阅览完整信息，因此我们需要设置Cookie。参考：<a href="https://blog.csdn.net/eye_water/article/details/78484217" target="_blank" rel="noopener">https://blog.csdn.net/eye_water/article/details/78484217</a></p><p>在爬取网页时没有传入Cookie，服务器不能识别用户身份，网页不能显示给没有用户身份的请求，所以网页源码会被隐藏。如何获取Cookie？如下方步骤所示，使用一个txt文件进行保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件来存储Cookie</span></span><br><span class="line">filename = <span class="string">'cookie.txt'</span></span><br><span class="line"><span class="comment"># 创建一个MozillaCookieJar()对象实例来保存Cookie</span></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)</span><br><span class="line"><span class="comment"># 创建Cookie处理器</span></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line"><span class="comment"># 构建opener</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">"http://3g.dxy.cn/bbs/"</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>打开Cookie文件，可以发现对应的内容：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-c1599bf6814c57ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接下来，在访问论坛时，从文件中读取Cookie，在进行网页请求时添加Cookie即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar()</span><br><span class="line"><span class="comment">#加载Cookie</span></span><br><span class="line">cookie.load(<span class="string">'cookie.txt'</span>, ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br><span class="line">url = <span class="string">'http://3g.dxy.cn/bbs/topic/509959#!_id=626626'</span></span><br><span class="line">res = requests.get(url, cookies=cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出:</span></span><br><span class="line">soup = bs(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到对应的元素位置</span></span><br><span class="line">name = soup.select(<span class="string">".auth"</span>)</span><br><span class="line">cont = soup.select(<span class="string">".postbody"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(name)<span class="number">-1</span>):</span><br><span class="line">    print(<span class="string">"用户:&#123;&#125;"</span>.format(name[i].get_text()))</span><br><span class="line">    print(<span class="string">"跟帖:&#123;&#125;"</span>.format(cont[i].get_text()))</span><br></pre></td></tr></table></figure></p><p>比较奇怪的是，我登录丁香园后获取到的Cookie仍然显示是游客身份，因此对应的网页中无法发现需要的内容。因此，还需要进一步实现，时间关系，先进行打卡操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天学习BeautifulSoup，并且利用此工具爬取丁香园跟帖。BeautifulSoup官方教程：&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
</feed>
