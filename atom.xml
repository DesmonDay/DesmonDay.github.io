<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DesmonDay&#39;s Blog</title>
  
  <subtitle>一只小辣鸡的自我拯救之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DesmonDay/"/>
  <updated>2019-01-11T08:52:46.850Z</updated>
  <id>https://github.com/DesmonDay/</id>
  
  <author>
    <name>Desmon Day</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tensorflow重新开始-1</title>
    <link href="https://github.com/DesmonDay/2019/01/11/Tensorflow1/"/>
    <id>https://github.com/DesmonDay/2019/01/11/Tensorflow1/</id>
    <published>2019-01-11T08:29:38.000Z</published>
    <updated>2019-01-11T08:52:46.850Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾经学习过一阵子，但是时间赶，并没有懂得什么东西，甚至于当时由于在C盘跑深度学习程序而把电脑的重要文件给误删了。这阵子打算重新开始学习Tensorflow，主要基于《Tensorflow实战Google深度学习框架》这本书。</p><p>最开始的简单程序：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-b0027e3f3b6ed3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过TensorBoard可视化向量相加的计算图：<br><img src="https://upload-images.jianshu.io/upload_images/8636110-757943af22bd3113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">（matrix1对应a, matrix2对应b，product对应add)</p><p>#Tensorflow三大模型</p><p>包括计算模型、数据模型和运行模型</p><p>##Tensorflow计算模型：计算图</p><p>Tensorflow是一个通过计算图的形式来表述计算的编程系统。Tensorflow中的每一个计算都是计算图上的一个节点，而节点之间的边描述了计算之间的依赖关系。如上图，所有Tensorflow的程序都可以通过类似上图的计算图的形式来表示，这便是TensorFlow的基本计算模型。</p><p>###计算图的使用<br>两个阶段：定义计算阶段，执行计算阶段</p><p>计算阶段：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-b0027e3f3b6ed3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过tf.get_default_graph函数可以获取当前默认的计算图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-803f460a7f4808fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前曾经学习过一阵子，但是时间赶，并没有懂得什么东西，甚至于当时由于在C盘跑深度学习程序而把电脑的重要文件给误删了。这阵子打算重新开始学习Tensorflow，主要基于《Tensorflow实战Google深度学习框架》这本书。&lt;/p&gt;
&lt;p&gt;最开始的简单程序：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Tensorflow" scheme="https://github.com/DesmonDay/categories/Tensorflow/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>算法阅读笔记--排序</title>
    <link href="https://github.com/DesmonDay/2018/07/15/%E7%AE%97%E6%B3%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F/"/>
    <id>https://github.com/DesmonDay/2018/07/15/算法阅读笔记-排序/</id>
    <published>2018-07-15T12:00:40.000Z</published>
    <updated>2018-07-15T12:39:44.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>对一个序列A中的元素A[1]到A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会与当前有序区间[1,i-1]形成新的有序区间[1,i]。<br>总时间复杂度为O(n^2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=i;</span><br><span class="line"><span class="keyword">for</span>(j=i; j&lt;=n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[j]&lt;A[k])&#123;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = A[i];</span><br><span class="line">A[i] = A[k];</span><br><span class="line">A[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[maxn], n; <span class="comment">//n为元素个数，数组下标为1到n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[i], j=i;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">1</span> &amp;&amp; temp&lt;A[j<span class="number">-1</span>])&#123;</span><br><span class="line">A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;p&gt;对一个序列A中的元素A[1]到A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其与待
      
    
    </summary>
    
      <category term="笔记" scheme="https://github.com/DesmonDay/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记(2)--线性表</title>
    <link href="https://github.com/DesmonDay/2018/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://github.com/DesmonDay/2018/06/19/数据结构笔记-2/</id>
    <published>2018-06-19T10:38:52.000Z</published>
    <updated>2018-06-20T04:38:27.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是最常用且最简单的一种数据结构。在稍复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含有大量记录的线性表又称文件。</p><p>线性表是一个相当灵活的数据结构，它的长度可以根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可以进行插入和删除等。</p><h2 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************线性链表***********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList; <span class="comment">//定义别名LinkList，则可以直接LinkList a;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位置查找</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="comment">// L为带头结点的单链表的头指针</span></span><br><span class="line"><span class="comment">// 当第i个元素存在时，其值赋给e并返回ok，否则返回error</span></span><br><span class="line">p = L-&gt;next;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p || j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置前插入e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">p = L;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p &amp;&amp; j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">s = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//生成新结点</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">p = L;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">e = q-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表尾到表头逆向建立单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=n; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">scanf</span>(&amp;p-&gt;data);</span><br><span class="line">p-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并有序链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">pa = La-&gt;next;</span><br><span class="line">pb = Lb-&gt;next;</span><br><span class="line">Lc = pc = La;</span><br><span class="line"><span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">pc-&gt;next = pa;</span><br><span class="line">pc = pa;</span><br><span class="line">pa = pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pc-next = pb;</span><br><span class="line">pc = pb;</span><br><span class="line">pb = pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;next = pa?pa:pb;</span><br><span class="line"><span class="built_in">free</span>(Lb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**************静态链表**************/</span></span><br><span class="line"><span class="comment">// 借用一维数组来描述线性链表，称为静态链表</span></span><br><span class="line"><span class="comment">// 需预先分配空间，插入删除方便(仅需修改指针)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">//链表最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">&#125;component, SLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_SL</span><span class="params">(SLinkList S, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="comment">// 在静态单链线性表L中查找第1个值为e的元素</span></span><br><span class="line"><span class="comment">// 若找到，则返回其在L中的次序，否则返回0.</span></span><br><span class="line">i = S[<span class="number">0</span>].cur;</span><br><span class="line"><span class="keyword">while</span>(i &amp;&amp; S[i].data!=e)&#123;</span><br><span class="line">i = S[i].cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合运算(A-B)U(B-A)</span></span><br><span class="line"><span class="comment">// 1. 将整个数组空间初始化一个链表</span></span><br><span class="line"><span class="comment">// 2. 从备用空间取得一个结点</span></span><br><span class="line"><span class="comment">// 3. 将空闲结点链接到备用链表上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSpace_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line"><span class="comment">// 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针</span></span><br><span class="line"><span class="comment">// "0"表示空指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)&#123;</span><br><span class="line">space[i].cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line"><span class="comment">// 若备用空间链表非空，则返回分配的结点下标，否则返回0</span></span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur;</span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur) space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">// 将下标为k的空闲结点回收到备用链接</span></span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;</span><br><span class="line">space[<span class="number">0</span>].cur = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> &amp;S)</span></span>&#123;</span><br><span class="line"><span class="comment">// 依次输入集合A和B的元素，在一维数组space中建立表示集合(A-B)U(B-A)</span></span><br><span class="line"><span class="comment">// 的静态链表，S为其头指针。假设备用空间足够大，space[0].cur为其头指针。</span></span><br><span class="line">InitSpace_SL(space); <span class="comment">//初始化备用空间</span></span><br><span class="line">S = Malloc_SL(space); <span class="comment">//生成S头结点</span></span><br><span class="line">r = S; <span class="comment">//r指向S的当前最后结点</span></span><br><span class="line"><span class="built_in">scanf</span>(m,n); <span class="comment">//输入A和B的元素个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123; <span class="comment">//建立集合A的链表</span></span><br><span class="line"><span class="keyword">int</span> i = Malloc_SL(space);</span><br><span class="line"><span class="built_in">scanf</span>(space[i].data); <span class="comment">//输入A的元素值</span></span><br><span class="line">space[r].cur = i; <span class="comment">//插入到表尾</span></span><br><span class="line">r = i;</span><br><span class="line">&#125;</span><br><span class="line">space[r].cur = <span class="number">0</span>; <span class="comment">//尾结点指针为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(b);</span><br><span class="line">p = S;</span><br><span class="line">k = space[S].cur; <span class="comment">//k指向集合A中第一个结点</span></span><br><span class="line"><span class="keyword">while</span>(k!=space[r].cur &amp;&amp; space[k].data!=b)&#123;</span><br><span class="line">p = k;</span><br><span class="line">k = space[k].cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == space[r].cur)&#123; <span class="comment">//说明当前表中不存在该元素，插入在r所指结点之后，且r的位置不变</span></span><br><span class="line">i = Malloc_SL(space);</span><br><span class="line">space[i].data = b;</span><br><span class="line">space[i].cur = space[r].cur;</span><br><span class="line">space[r].cur = i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">//该元素已在表中，删除之</span></span><br><span class="line">space[p].cur = space[k].cur;</span><br><span class="line">Free_SL(space, k);</span><br><span class="line"><span class="keyword">if</span> (r==k) r=p; <span class="comment">// 若删除的是r所指结点，则需修改尾指针</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************循环链表**************/</span></span><br><span class="line"><span class="comment">// 表中最后一个结点的指针域指向头结点，形成一个环</span></span><br><span class="line"><span class="comment">// 操作与线性列表基本一致，差别仅在于算法中的循环条件不是p或者p-&gt;next是否为空，而是在于是否等于头指针。</span></span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**************双向链表**************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p = GetElemP_DuL(L,i)))&#123;</span><br><span class="line"><span class="keyword">return</span> ERROR; <span class="comment">//若p为NULL，说明插入位置不合法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode)))) <span class="keyword">return</span> ERROR;</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;prior = p-&gt;prior; <span class="comment">//s-&gt;prior = a;</span></span><br><span class="line">p-&gt;prior-&gt;next = s; <span class="comment">//p36页 看图理解 a-&gt;next = s;</span></span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior = s;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p = GetElemP_DuL(L,i))) <span class="keyword">return</span> ERROR; <span class="comment">//在L中确定第i个元素的位置指针p</span></span><br><span class="line">e = p-&gt;data;</span><br><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>从实际应用角度出发重新定义线性链表及其基本操作。<br><a href="https://blog.csdn.net/u013457167/article/details/78543258" target="_blank" rel="noopener">https://blog.csdn.net/u013457167/article/details/78543258</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;p&gt;线性表是最常用且最简单的一种数据结构。在稍复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含
      
    
    </summary>
    
    
      <category term="考研" scheme="https://github.com/DesmonDay/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow运作方式入门</title>
    <link href="https://github.com/DesmonDay/2018/06/07/Tensorflow%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/DesmonDay/2018/06/07/Tensorflow运作方式入门/</id>
    <published>2018-06-07T10:41:34.000Z</published>
    <updated>2018-06-07T13:35:23.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习mnist-py–-构建图表"><a href="#学习mnist-py–-构建图表" class="headerlink" title="学习mnist.py– 构建图表"></a>学习mnist.py– 构建图表</h1><p>跟着教程步骤将代码打一遍，这样更容易记住。</p><p>Builds the MNIST network.<br>Implements the inference/loss/training pattern for model building.</p><ol><li>inference() – Builds the model as far as required for running the network<br>forward to make predictions.</li><li>loss() – Adds to the inference model the layers required to generate loss.</li><li>training() – Adds to the loss model the Ops required to generate and<br>apply gradients.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">10</span></span><br><span class="line">IMAGE_SIZE = <span class="number">28</span></span><br><span class="line">IMAGE_PIXELS = IMAGE_SIZE * IMAGE_SIZE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference</span><span class="params">(images, hidden1_units, hidden2_units)</span>:</span></span><br><span class="line">    <span class="comment"># inference()函数会尽可能地构建图表，做到返回包含了预测结果（output prediction）的Tensor。</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        images: Images placeholder, from inputs().</span></span><br><span class="line"><span class="string">        hidden1_units: Size of the first hidden layer.</span></span><br><span class="line"><span class="string">        hidden2_units: Size of the second hidden layer.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        softmax_linear: Output tensor with the computed logits.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># Hidden 1</span></span><br><span class="line">    <span class="comment"># 当这些层是在hidden1作用域下生成时，赋予权重变量的独特名称将会是"hidden1/weights"。</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'hidden1'</span>):</span><br><span class="line">        weights = tf.Variable(</span><br><span class="line">            tf.truncated_normal([IMAGE_PIXELS, hidden1_units],</span><br><span class="line">                                stddev=<span class="number">1.0</span> / math.sqrt(float(IMAGE_PIXELS))),</span><br><span class="line">            name=<span class="string">'weights'</span>) <span class="comment"># truncated_normal(shape, mean, stddev)函数产生正态分布,初始化权重</span></span><br><span class="line">        biases = tf.Variable(tf.zeros([hidden1_units]),</span><br><span class="line">                             name=<span class="string">'biases'</span>)</span><br><span class="line">        hidden1 = tf.nn.relu(tf.matmul(images, weights) + biases)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hidden 2</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'hidden2'</span>):</span><br><span class="line">        weights = tf.Variable(</span><br><span class="line">            tf.truncated_normal([hidden1_units, hidden2_units],</span><br><span class="line">                            stddev=<span class="number">1.0</span> / math.sqrt(float(hidden1_units))),</span><br><span class="line">            name=<span class="string">'weights'</span>)</span><br><span class="line">        biases = tf.Variable(tf.zeros([hidden2_units]),</span><br><span class="line">                             name=<span class="string">'biases'</span>)</span><br><span class="line">        hidden2 = tf.nn.relu(tf.matmul(hidden1, weights) + biases)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Linear</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'softmax_linear'</span>):</span><br><span class="line">        weights = tf.Variable(</span><br><span class="line">            tf.truncated_normal([hidden2_units, NUM_CLASSES],</span><br><span class="line">                                stddev=<span class="number">1.0</span>/math.sqrt(float(hidden2_units))),</span><br><span class="line">            name = <span class="string">'weights'</span>)</span><br><span class="line">        biases = tf.Variable(tf.zeros([NUM_CLASSES]),</span><br><span class="line">                             name=<span class="string">'biases'</span>)</span><br><span class="line">        logits = tf.matmul(hidden2, weights) + biases</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logits <span class="comment"># 返回包含了输出结果的logits Tensor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(logits, labels)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Calculates the loss from the logits and the labels.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        logits: Logits tensor, float - [batch_size, NUM_CLASSES].</span></span><br><span class="line"><span class="string">        labels: Labels tensor, int32 - [batch_size].</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        loss: Loss tensor of type float</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    labels = tf.to_int64(labels)</span><br><span class="line">    <span class="keyword">return</span> tf.losses.sparse_softmax_cross_entropy(labels=labels, logits=logits)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">training</span><span class="params">(loss, learning_rate)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Sets up the training Ops.</span></span><br><span class="line"><span class="string">    Creates a summarizer to track the loss over time in TensorBoard.</span></span><br><span class="line"><span class="string">    Creates an optimizer and applies the gradients to all trainable variables.</span></span><br><span class="line"><span class="string">    The Op returned by this function is what must be passed to the `sess.run()` call to cause the model to train.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        loss: Loss tensor, from loss().</span></span><br><span class="line"><span class="string">        learning_rate: The learning rate to use for gradient descent.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        train_op: The Op for training.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 该函数从loss()函数中获取损失Tensor，将其交给tf.scalar_summary，后者在与</span></span><br><span class="line">    <span class="comment"># SummaryWriter（见下文）配合使用时，可以向事件文件（events file）中生成汇总值（summary values）</span></span><br><span class="line">    tf.summary.scalar(<span class="string">'loss'</span>, loss) </span><br><span class="line">    <span class="comment"># 应用梯度下降法</span></span><br><span class="line">    Optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line">    <span class="comment"># 生成一个变量用于保存全局训练步骤（global training step）的数值</span></span><br><span class="line">    <span class="comment"># 使用minimize()函数更新系统中的三角权重（triangle weights), 增加全局步骤的操作</span></span><br><span class="line">    global_step = tf.Variable(<span class="number">0</span>, name=<span class="string">"global_step"</span>, trainable=<span class="keyword">False</span>)</span><br><span class="line">    train_op = optimizer.minimize(loss, global_step=global_step)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_op <span class="comment"># 返回包含了训练操作（training op）输出结果的Tensor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluation</span><span class="params">(logits, labels)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Evaluate the quality of the logits at predicting the label.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        logits: Logits tensor, float - [batch_size, NUM_CLASSES].</span></span><br><span class="line"><span class="string">        labels: Labels tensor, int32 - [batch_size], with values in the</span></span><br><span class="line"><span class="string">        range [0, NUM_CLASSES).</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A scalar int32 tensor with the number of examples (out of batch_size)</span></span><br><span class="line"><span class="string">        that were predicted correctly.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    correct = tf.nn.in_top_k(logis, labels, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Return the number of true entries.</span></span><br><span class="line">    <span class="keyword">return</span> tf.reduce_sum(tf.cast(correct, tf.int32))</span><br></pre></td></tr></table></figure><h1 id="学习fully-connected-feed-py–-训练模型"><a href="#学习fully-connected-feed-py–-训练模型" class="headerlink" title="学习fully_connected_feed.py– 训练模型"></a>学习fully_connected_feed.py– 训练模型</h1><p>上一节的mnist.py起到构建图表的作用。一旦图表构建完毕，就通过fully_connected_feed.py文件中的用户代码进行循环地迭代式训练和评估。</p><p>Trains and Evaluates the MNIST network using a feed dictionary.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> input_data <span class="comment"># 生成数据集</span></span><br><span class="line"><span class="keyword">import</span> mnist</span><br><span class="line"></span><br><span class="line">FLAGS = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># placeholder_inputs()函数将生成两个tf.placeholder操作，定义传入图表中的shape参数，shape参数中包括batch_size值，后续还会将实际的训练用例传入图表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练循环（training loop）的后续步骤中，传入的整个图像和标签数据集会被切片，以符合每一个操作所设置的batch_size值，占位符操作将会填补以符合这个batch_size值。然后使用feed_dict参数，将数据传入sess.run()函数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">placeholder_inputs</span><span class="params">(batch_size)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Generate placeholder variables to represent the input tensors.</span></span><br><span class="line"><span class="string">    These placeholders are used as inputs by the rest of the model building</span></span><br><span class="line"><span class="string">  code and will be fed from the downloaded data in the .run() loop, below.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        batch_size: The batch size will be baked into both placeholders.</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        images_placeholder: Images placeholder.</span></span><br><span class="line"><span class="string">        labels_placeholder: Labels placeholder.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    images_placeholder = tf.placeholder(tf.float32, shape=(batch_size, mnist.IMAGE_PIXELS))</span><br><span class="line">    labels_placeholder = tf.placeholder(tf.int32, shape=(batch_size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images_placeholder, labels_placeholder</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_feed_dict</span><span class="params">(data_set, images_pl, labels_pl)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Fills the feed_dict for training the given step.</span></span><br><span class="line"><span class="string">    A feed_dict takes the form of:</span></span><br><span class="line"><span class="string">        feed_dict = &#123;</span></span><br><span class="line"><span class="string">            &lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,</span></span><br><span class="line"><span class="string">            ....</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data_set: The set of images and labels, from input_data.read_data_sets()</span></span><br><span class="line"><span class="string">        images_pl: The images placeholder, from placeholder_inputs().</span></span><br><span class="line"><span class="string">        labels_pl: The labels placeholder, from placeholder_inputs().</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        feed_dict: The feed dictionary mapping from placeholders to values.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 索要下一批次batch_size的图像和标签，与占位符相匹配的Tensor则会包含下一批次的图像和标签。</span></span><br><span class="line">    images_feed, labels_feed = data_set.next_batch(FLAGS.batch_size, FLAGS.fake_data)</span><br><span class="line">    feed_dict = &#123;</span><br><span class="line">        images_pl: images_feed,</span><br><span class="line">        labels_pl: labels_feed,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feed_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_eval</span><span class="params">(sess, eval_correct, images_placeholder, labels_placeholder, data_set)</span>:</span></span><br><span class="line">    <span class="comment"># Runs one evaluation against the full epoch of data.</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    sess: The session in which the model has been trained.</span></span><br><span class="line"><span class="string">    eval_correct: The Tensor that returns the number of correct predictions.</span></span><br><span class="line"><span class="string">    images_placeholder: The images placeholder.</span></span><br><span class="line"><span class="string">    labels_placeholder: The labels placeholder.</span></span><br><span class="line"><span class="string">    data_set: The set of images and labels to evaluate, from</span></span><br><span class="line"><span class="string">      input_data.read_data_sets().</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    true_count = <span class="number">0</span> <span class="comment"># Counts the number of correct predictions.</span></span><br><span class="line">    steps_per_epoch = data_set.num_examples <span class="comment"># FLAGS.batch_size</span></span><br><span class="line">    num_examples = steps_per_epoch * FLAGS.batch_size</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> range(steps_per_epoch):</span><br><span class="line">        feed_dict = fill_feed_dict(data_set, images_placeholder, labels_placeholder)</span><br><span class="line">        true_count += sess.run(eval_correct, feed_dict=feed_dict)</span><br><span class="line">    precision = float(true_count) / num_examples</span><br><span class="line">    print(<span class="string">'Num examples: %d  Num correct: %d  Precision @ 1: %0.04f'</span> % (num_examples, true_count, precision))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_training</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Train MNIST for a number of steps."""</span></span><br><span class="line">    data_sets = input_data.read_data_sets(FLAGS.input_data_dir, FLAGS.fake_data)</span><br><span class="line">    <span class="keyword">with</span> tf.Graph().as_default(): </span><br><span class="line">    <span class="comment"># 这个命令表明所有已经构建的操作都要与默认的tf.Graph全局实例关联起来。</span></span><br><span class="line">        <span class="comment"># Generate placeholders for the images and labels.</span></span><br><span class="line">        images_placeholder, labels_placeholder = placeholder_inputs(FLAGS.batch_size)</span><br><span class="line">        <span class="comment"># Build a Graph that computes predictions from the inference model.</span></span><br><span class="line">        logits = mnist.inference(images_placeholder, FLAGS.hidden1, FLAGS.hidden2)</span><br><span class="line">        <span class="comment"># Add to the Graph the Ops for loss calculation.</span></span><br><span class="line">        loss = mnist.loss(logits, labels_placeholder)</span><br><span class="line">        <span class="comment"># Add to the Graph the Ops that calculate and apply gradients.</span></span><br><span class="line">        train_op = mnist.training(loss, FLAGS.learning_rate)</span><br><span class="line">        <span class="comment"># Add the Op to compare the logits to the labels during evaluation.</span></span><br><span class="line">        eval_correct = mnist.evaluation(logits, labels_placeholder)</span><br><span class="line">        <span class="comment"># Build the summary Tensor based on the TF collection of Summaries.</span></span><br><span class="line">        summary = tf.summary.merge_all()</span><br><span class="line">        <span class="comment"># Add the variable initializer Op.</span></span><br><span class="line">        init = tf.global_variables_initializer()</span><br><span class="line">        <span class="comment"># Create a saver for writing training checkpoints.</span></span><br><span class="line">        sess = tf.Session()</span><br><span class="line">        <span class="comment"># Instantiate a SummaryWriter to output summaries and the Graph.</span></span><br><span class="line">        summary_writer = tf.summary.FileWriter(FLAGS.log_dir, sess.graph)</span><br><span class="line"></span><br><span class="line">        sess.run(init)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Start training</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(FLAGS.max_steps):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            feed_dict = fill_feed_dict(data_set.train, images_placeholder, labels_placeholder)</span><br><span class="line">            _, loss_value = sess.run([train_op,loss], feed_dict=feed_dict)</span><br><span class="line">            duration = time.time() - start_time</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'Step %d: loss = %.2f (%.3f sec)'</span> % (step, loss_value, duration))</span><br><span class="line">                <span class="comment"># Update the events file.</span></span><br><span class="line">                summary_str = sess.run(summary, feed_dict=feed_dict)</span><br><span class="line">                summary_writer.add_summary(summary_str, step)</span><br><span class="line">                summary_writer.flush()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (step+<span class="number">1</span>)%<span class="number">1000</span>==<span class="number">0</span> <span class="keyword">or</span> (step+<span class="number">1</span>)==FLAGS.max_steps:</span><br><span class="line">                checkpoint_file = os.path.join(FLAGS.log_dir, <span class="string">'model.ckpt'</span>)</span><br><span class="line">                saver.save(ses, checkpoint_file, global_step=step)</span><br><span class="line">                <span class="comment"># saver.restore(sess, FLAGS.train_dir)可重载模型参数，继续训练</span></span><br><span class="line">                <span class="comment"># Evaluate against the training set.</span></span><br><span class="line">                print(<span class="string">'Training Data Eval:'</span>)</span><br><span class="line">                do_eval(sess,</span><br><span class="line">                        eval_correct,</span><br><span class="line">                        images_placeholder,</span><br><span class="line">                        labels_placeholder,</span><br><span class="line">                        data_sets.train)</span><br><span class="line">                print(<span class="string">'Validation Data Eval:'</span>)</span><br><span class="line">                do_eval(sess,</span><br><span class="line">                        eval_correct,</span><br><span class="line">                        images_placeholder,</span><br><span class="line">                        labels_placeholder,</span><br><span class="line">                        data_sets.validation)</span><br><span class="line">                <span class="comment"># Evaluate against the test set.</span></span><br><span class="line">                print(<span class="string">'Test Data Eval:'</span>)</span><br><span class="line">                do_eval(sess,</span><br><span class="line">                        eval_correct,</span><br><span class="line">                        images_placeholder,</span><br><span class="line">                        labels_placeholder,</span><br><span class="line">                        data_sets.test)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> tf.gfile.Exists(FLAGS.log_dir):</span><br><span class="line">        tf.gfile.DeleteRecursively(FLAGS.log_dir)</span><br><span class="line">    tf.gfile.MakeDirs(FLAGS.log_dir)</span><br><span class="line">    run_training()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser() <span class="comment">#参数设置</span></span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--learning_rate'</span>,</span><br><span class="line">        type=float,</span><br><span class="line">        default=<span class="number">0.01</span>,</span><br><span class="line">        help=<span class="string">'Initial learning_rate'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--max_steps'</span>,</span><br><span class="line">         type=int,</span><br><span class="line">        default=<span class="number">200</span>,</span><br><span class="line">        help=<span class="string">'Number of steps to run trainer.'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--hidden1'</span>,</span><br><span class="line">        type=int,</span><br><span class="line">        default=<span class="number">128</span>,</span><br><span class="line">        help=<span class="string">'Number of units in hidden layer 1.'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--hidden2'</span>,</span><br><span class="line">        type=int,</span><br><span class="line">        default=<span class="number">32</span>,</span><br><span class="line">        help=<span class="string">'Number of units in hidden layer 2.'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--batch_size'</span>,</span><br><span class="line">        type=int,</span><br><span class="line">        default=<span class="number">100</span>,</span><br><span class="line">        help=<span class="string">'Batch size.  Must divide evenly into the dataset sizes.'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--input_data_dir'</span>,</span><br><span class="line">        type=str,</span><br><span class="line">        default=os.path.join(os.getenv(<span class="string">'TEST_TMPDIR'</span>, <span class="string">'/tmp'</span>),</span><br><span class="line">                           <span class="string">'tensorflow/mnist/input_data'</span>),</span><br><span class="line">        help=<span class="string">'Directory to put the input data.'</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">'--fake_data'</span>,</span><br><span class="line">        default=<span class="keyword">False</span>,</span><br><span class="line">        help=<span class="string">'If true, uses fake data for unit testing.'</span>,</span><br><span class="line">        action=<span class="string">'store_true'</span>)</span><br><span class="line">    FLAGS, unparsed = parser.parse_known_args()</span><br><span class="line">    tf.app.run(main=main, argv=[sys.argv[<span class="number">0</span>]] + unparsed)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习mnist-py–-构建图表&quot;&gt;&lt;a href=&quot;#学习mnist-py–-构建图表&quot; class=&quot;headerlink&quot; title=&quot;学习mnist.py– 构建图表&quot;&gt;&lt;/a&gt;学习mnist.py– 构建图表&lt;/h1&gt;&lt;p&gt;跟着教程步骤将代码打一遍，这
      
    
    </summary>
    
      <category term="Tensorflow" scheme="https://github.com/DesmonDay/categories/Tensorflow/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow_识别手写数字</title>
    <link href="https://github.com/DesmonDay/2018/06/05/Tensorflow-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/"/>
    <id>https://github.com/DesmonDay/2018/06/05/Tensorflow-识别手写数字/</id>
    <published>2018-06-04T16:28:07.000Z</published>
    <updated>2018-06-04T16:28:07.116Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Tensorflow综述</title>
    <link href="https://github.com/DesmonDay/2018/06/04/Tensorflow%E7%BB%BC%E8%BF%B0/"/>
    <id>https://github.com/DesmonDay/2018/06/04/Tensorflow综述/</id>
    <published>2018-06-04T14:13:19.000Z</published>
    <updated>2018-06-04T15:28:44.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为数据挖掘课上自己不自量力地选择了深度强化学习方面的课程项目，本来想着直接看着二水马的代码学习相关知识，现在想想是不太可能的。我还是，乖乖地从最基础的知识入手好了。由于时间有限，因此会尽量在短时间内学会。学习网站是Tensorflow中文社区。<a href="http://www.tensorfly.cn/tfdoc/get_started/introduction.html" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/get_started/introduction.html</a> </p><p>另外由于教程里的Tensorflow是较旧版本的，且python使用的是.2版本，因此我会对代码进行一定的修改。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先教程里给了一个简短的python程序，生成三维数组，然后使用平面拟合。仅为初步了解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 NumPy 生成假数据(phony data), 总共 100 个点.</span></span><br><span class="line">x_data = np.float32(np.random.rand(<span class="number">2</span>, <span class="number">100</span>)) <span class="comment"># 随机输入</span></span><br><span class="line">y_data = np.dot([<span class="number">0.100</span>, <span class="number">0.200</span>], x_data) + <span class="number">0.300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个线性模型</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br><span class="line">W = tf.Variable(tf.random_uniform([<span class="number">1</span>, <span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">y = tf.matmul(W, x_data) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小化方差</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y - y_data))</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动图 (graph)</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合平面</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print( step, sess.run(W), sess.run(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到最佳拟合结果 W: [[0.100  0.200]], b: [0.300]</span></span><br></pre></td></tr></table></figure><p>这样看起来，好像挺简单？但是其实现在啥原理都不懂… 继续看教程。下载安装之类的步骤就略过了。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>上面一段代码中出现了一些新的名词，比如图, Session。这里解释之：</p><ul><li>TensorFlow使用图(graph)来表示计算任务</li><li>在被称为会话(Session)的上下文(context)中执行图</li><li>使用tensor表示数据</li><li>通过变量(Variable)维护状态</li><li>使用feed和fetch可以为任意的操作(arbitrary operation)赋值或者从其中获取数据</li></ul><h1 id="TensorFlow综述及介绍"><a href="#TensorFlow综述及介绍" class="headerlink" title="TensorFlow综述及介绍"></a>TensorFlow综述及介绍</h1><p>这部分直接摘抄好了，我这只刚入门菜鸟，也总结不了什么… 侵权必究，哈哈哈~</p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>TensorFlow 是一个编程系统, 使用图来表示计算任务. 图中的节点被称之为 op (operation 的缩写). 一个 op 获得 0 个或多个 Tensor, 执行计算, 产生 0 个或多个 Tensor. 每个 Tensor 是一个类型化的多维数组. 例如, 你可以将一小组图像集表示为一个四维浮点数数组, 这四个维度分别是 [batch, height, width, channels].</p><p>一个 TensorFlow 图描述了计算的过程. 为了进行计算, 图必须在 会话 里被启动. 会话 将图的 op 分发到诸如 CPU 或 GPU 之类的 设备 上, 同时提供执行 op 的方法. 这些方法执行后, 将产生的 tensor 返回. 在 Python 语言中, 返回的 tensor 是 numpy ndarray 对象; 在 C 和 C++ 语言中, 返回的 tensor 是 tensorflow::Tensor 实例.</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>TensorFlow 程序通常被组织成一个构建阶段和一个执行阶段. 在构建阶段, op 的执行步骤 被描述成一个图. 在执行阶段, 使用会话执行执行图中的 op.</p><p>例如, 通常在构建阶段创建一个图来表示和训练神经网络, 然后在执行阶段反复执行图中的训练 op.</p><p>TensorFlow 支持 C, C++, Python 编程语言. 目前, TensorFlow 的 Python 库更加易用, 它提供了大量的辅助函数来简化构建图的工作, 这些函数尚未被 C 和 C++ 库支持.</p><p>三种语言的会话库 (session libraries) 是一致的.</p><h2 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h2><p>构建图的第一步, 是创建源 op (source op). <strong>源 op 不需要任何输入, 例如 常量 (Constant)</strong>. 源 op 的输出被传递给其它 op 做运算.</p><p>Python 库中, op 构造器的返回值代表被构造出的 op 的输出, 这些返回值可以传递给其它 op 构造器作为输入.</p><p>TensorFlow Python 库有一个默认图 (default graph), op 构造器可以为其增加节点. 这个默认图对 许多程序来说已经足够用了. 阅读 Graph 类 文档 来了解如何管理多个图.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点</span></span><br><span class="line"><span class="comment"># 加到默认图中.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 构造器的返回值代表该常量 op 的返回值.</span></span><br><span class="line">matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另外一个常量 op, 产生一个 2x1 矩阵.</span></span><br><span class="line">matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.</span></span><br><span class="line"><span class="comment"># 返回值 'product' 代表矩阵乘法的结果.</span></span><br><span class="line">product = tf.matmul(matrix1, matrix2)</span><br></pre></td></tr></table></figure><p>默认图现在有三个节点, 两个 constant() op, 和一个matmul() op. 为了真正进行矩阵相乘运算, 并得到矩阵乘法的 结果, 你必须在会话里启动这个图.</p><h2 id="在一个会话中启动图"><a href="#在一个会话中启动图" class="headerlink" title="在一个会话中启动图"></a>在一个会话中启动图</h2><p>构造阶段完成后, 才能启动图. 启动图的第一步是创建一个 Session 对象, 如果无任何创建参数, 会话构造器将启动默认图.</p><p>欲了解完整的会话 API, 请阅读Session 类.(<a href="http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#session-management" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#session-management</a>, 罢了罢了，下次再说)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动默认图.</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 sess 的 'run()' 方法来执行矩阵乘法 op, 传入 'product' 作为该方法的参数. </span></span><br><span class="line"><span class="comment"># 上面提到, 'product' 代表了矩阵乘法 op 的输出, 传入它是向方法表明, 我们希望取回</span></span><br><span class="line"><span class="comment"># 矩阵乘法 op 的输出.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 整个执行过程是自动化的, 会话负责传递 op 所需的全部输入. op 通常是并发执行的.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 函数调用 'run(product)' 触发了图中三个 op (两个常量 op 和一个矩阵乘法 op) 的执行.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 返回值 'result' 是一个 numpy `ndarray` 对象.</span></span><br><span class="line">result = sess.run(product)</span><br><span class="line">print( result)</span><br><span class="line"><span class="comment"># ==&gt; [[ 12.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务完成, 关闭会话.</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure><p>Session 对象在使用完后需要关闭以释放资源. 除了显式调用 close 外, 也可以使用 “with” 代码块 来自动完成关闭动作.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    result = sess.run([product])</span><br><span class="line">    print( result)</span><br></pre></td></tr></table></figure><p>在实现上, TensorFlow 将图形定义转换成分布式执行的操作, 以充分利用可用的计算资源(如 CPU 或 GPU). 一般你不需要显式指定使用 CPU 还是 GPU, TensorFlow 能自动检测. 如果检测到 GPU, TensorFlow 会尽可能地利用找到的第一个 GPU 来执行操作.</p><p>如果机器上有超过一个可用的 GPU, 除第一个外的其它 GPU 默认是不参与计算的. 为了让 TensorFlow 使用这些 GPU, 你必须将 op 明确指派给它们执行. with…Device 语句用来指派特定的 CPU 或 GPU 执行操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="keyword">with</span> tf.device(<span class="string">"/gpu:1"</span>):</span><br><span class="line">        matrix1 = tf.constant([[<span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line">        matrix2 = tf.constant([[<span class="number">2.</span>],[<span class="number">2.</span>]])</span><br><span class="line">        product = tf.matmul(matrix1, matrix2)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>设备用字符串进行标识. 目前支持的设备包括:</p><ul><li>“/cpu:0”: 机器的 CPU.</li><li>“/gpu:0”: 机器的第一个 GPU, 如果有的话.</li><li>“/gpu:1”: 机器的第二个 GPU, 以此类推.<br>阅读使用GPU章节(<a href="http://www.tensorfly.cn/tfdoc/how_tos/using_gpu.html)" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/how_tos/using_gpu.html)</a>, 了解 TensorFlow GPU 使用的更多信息.</li></ul><h1 id="交互式使用"><a href="#交互式使用" class="headerlink" title="交互式使用"></a>交互式使用</h1><p>文档中的 Python 示例使用一个会话 Session 来 启动图, 并调用 Session.run() 方法执行操作.</p><p>为了便于使用诸如 IPython 之类的 Python 交互环境, 可以使用 InteractiveSession 代替 Session 类, 使用 Tensor.eval() 和 Operation.run() 方法代替 Session.run(). 这样可以避免使用一个变量来持有会话. (自从命令行可以直接启动python，我就不想启动Ipython了，看着前面序号不习惯。这里就记录一下。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入一个交互式 TensorFlow 会话.</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line"></span><br><span class="line">x = tf.Variable([<span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line">a = tf.constant([<span class="number">3.0</span>, <span class="number">3.0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用初始化器 initializer op 的 run() 方法初始化 'x' </span></span><br><span class="line">x.initializer.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个减法 sub op, 从 'x' 减去 'a'. 运行减法 op, 输出结果 </span></span><br><span class="line">sub = tf.sub(x, a)</span><br><span class="line">print( sub.eval())</span><br><span class="line"><span class="comment"># ==&gt; [-2. -1.]</span></span><br></pre></td></tr></table></figure><h1 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h1><p>TensorFlow 程序使用 tensor 数据结构来代表所有的数据, 计算图中, 操作间传递的数据都是 tensor. 你可以把 TensorFlow tensor 看作是一个 n 维的数组或列表. 一个 tensor 包含一个静态类型 rank, 和 一个 shape. 想了解 TensorFlow 是如何处理这些概念的, 参见 Rank, Shape, 和 Type.(不贴链接了，有三个呢。)</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量维护图执行过程中的状态信息. 下面的例子演示了如何使用变量实现一个简单的计数器.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个变量, 初始化为标量 0.</span></span><br><span class="line">state = tf.Variable(<span class="number">0</span>, name=<span class="string">"counter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 op, 其作用是使 state 增加 1</span></span><br><span class="line"></span><br><span class="line">one = tf.constant(<span class="number">1</span>)</span><br><span class="line">new_value = tf.add(state, one)</span><br><span class="line">update = tf.assign(state, new_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动图后, 变量必须先经过`初始化` (init) op 初始化,</span></span><br><span class="line"><span class="comment"># 首先必须增加一个`初始化` op 到图中.</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动图, 运行 op</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># 运行 'init' op</span></span><br><span class="line">  sess.run(init_op)</span><br><span class="line">  <span class="comment"># 打印 'state' 的初始值</span></span><br><span class="line">  print(sess.run(state))</span><br><span class="line">  <span class="comment"># 运行 op, 更新 'state', 并打印 'state'</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    sess.run(update)</span><br><span class="line">    print(sess.run(state))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure></p><p>代码中 assign() 操作是图所描绘的表达式的一部分, 正如 add() 操作一样. 所以在调用 run() 执行表达式之前, 它并不会真正执行赋值操作.</p><p>通常会将一个统计模型中的参数表示为一组变量. 例如, 你可以将一个神经网络的权重作为某个变量存储在一个 tensor 中. 在训练过程中, 通过重复运行训练图, 更新这个 tensor.</p><p>在神经网络中，Variable一般都是模型参数，在每轮训练时保存参数的更新，还可以将模型以参数的形式保存下来。</p><h2 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建变量</span></span><br><span class="line">v1 = tf.Variable([<span class="number">1.0</span>, <span class="number">2.0</span>], name=<span class="string">"v1"</span>)</span><br><span class="line">v2 = tf.Variable([<span class="number">3.0</span>, <span class="number">3.0</span>], name=<span class="string">"v2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量的op</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化saver的op</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，上面的两步都是op，真正执行也是在session中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  sess.run(init_op)</span><br><span class="line">  <span class="comment"># Do some work with the model.</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="comment"># 保存变量到硬盘</span></span><br><span class="line">  save_path = saver.save(sess, <span class="string">"/tmp/model.ckpt"</span>)</span><br><span class="line">  print(<span class="string">"Model saved in file: "</span>, save_path)</span><br></pre></td></tr></table></figure><h2 id="加载变量"><a href="#加载变量" class="headerlink" title="加载变量"></a>加载变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># 从硬盘加载变量</span></span><br><span class="line">  saver.restore(sess, <span class="string">"/tmp/model.ckpt"</span>)</span><br><span class="line">  print( <span class="string">"Model restored."</span>)</span><br><span class="line">  <span class="comment"># Do some work with the model</span></span><br></pre></td></tr></table></figure><h1 id="Fetch指定计算的结点"><a href="#Fetch指定计算的结点" class="headerlink" title="Fetch指定计算的结点"></a>Fetch指定计算的结点</h1><p>为了取回操作的输出内容, 可以在使用 Session 对象的 run() 调用 执行图时, 传入一些 tensor, 这些 tensor 会帮助你取回结果. 在之前的例子里, 我们只取回了单个节点 state, 但是你也可以取回多个 tensor: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input1 = tf.constant(<span class="number">3.0</span>)</span><br><span class="line">input2 = tf.constant(<span class="number">2.0</span>)</span><br><span class="line">input3 = tf.constant(<span class="number">5.0</span>)</span><br><span class="line">intermed = tf.add(input2, input3)</span><br><span class="line">mul = tf.mul(input1, intermed)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  result = sess.run([mul, intermed])</span><br><span class="line">  print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [array([ 21.], dtype=float32), array([ 7.], dtype=float32)]</span></span><br></pre></td></tr></table></figure><p>需要获取的多个 tensor 值，在 op 的一次运行中一起获得（而不是逐个去获取 tensor）。</p><h1 id="Feed图的输入"><a href="#Feed图的输入" class="headerlink" title="Feed图的输入"></a>Feed图的输入</h1><p>TensorFlow 还提供了 feed 机制, 该机制可以临时替代图中的任意操作中的 tensor 可以对图中任何操作提交补丁, 直接插入一个 tensor。</p><p>feed 使用一个 tensor 值临时替换一个操作的输出结果. 你可以提供 feed 数据作为 run() 调用的参数. feed 只在调用它的方法内有效, 方法结束, feed 就会消失. 最常见的用例是将某些特殊的操作指定为 “feed” 操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.</p><p>首先在构建图的时候要使用占位符：tf.placeholder。<br>然后在run函数里，指定feed_dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input1 = tf.placeholder(tf.float32)</span><br><span class="line">input2 = tf.placeholder(tf.float32)</span><br><span class="line">output = tf.multiply(input1, input2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  print(sess.run([output], feed_dict=&#123;input1:[<span class="number">7.</span>], input2:[<span class="number">2.</span>]&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [array([ 14.], dtype=float32)]</span></span><br></pre></td></tr></table></figure><p>for a larger-scale example of feeds. 如果没有正确提供 feed, placeholder() 操作将会产生错误。MNIST 全连通 feed 教程 (source code) 给出了一个更大规模的使用 feed 的例子.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为数据挖掘课上自己不自量力地选择了深度强化学习方面的课程项目，本来想着直接看着二水马的代码学习相关知识，现在想想是不太可能的。我还是，乖乖
      
    
    </summary>
    
      <category term="Tensorflow" scheme="https://github.com/DesmonDay/categories/Tensorflow/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数据结构笔记(1)</title>
    <link href="https://github.com/DesmonDay/2018/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://github.com/DesmonDay/2018/06/01/数据结构笔记-1/</id>
    <published>2018-06-01T07:03:26.000Z</published>
    <updated>2018-06-01T16:55:12.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>一般用计算机解决问题，需经过以下几个步骤：首先要从具体问题抽象成一个适当的数学模型，然后设计一个解此数学模型的算法，最后编出程序，进行测试、调整直至得到最终解答。</p><ul><li>数据是对客观事物的符号表示。</li><li>数据元素是数据的基本单位，一个数据元素可由若干个数据项组成。</li><li>数据对象是性质相同的数据元素的集合，是数据的一个子集。</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。通常有下列4类基本结构：集合、线性结构、树形结构、图状结构或网状结构。</li></ul><p>数据结构的形式定义为：数据结构是一个二元组Data_Strucutre=(D,S)，其中D是数据元素的有限集，S是D上关系的有限集。而结构定义中的“关系”描述的是数据元素之间的逻辑关系，因此又称为数据的逻辑结构。</p><p>数据结构在计算机中的表示称为数据的物理结构，又称存储结构。在计算机中表示信息的最小单位是位(bit)。数据元素之间的关系在计算机中有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。</p><ul><li>顺序映象的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。</li><li>非顺序映象的特点是借助指示元素存储地址的指针数据元素之间的逻辑关系。</li></ul><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称，如C中的整型变量，其值集为某个区间上的整数，定义在其上的操作为加、减、乘、除和取模等算术运算。 高级程序语言中的数据类型可分为两类：一类是非结构的原子类型，另一类是结构类型。</p><p>抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，其不再局限于处理器已定义并实现的数据类型，还包括用户在设计软件系统时自己定义的数据类型。和数据结构的形式定义相对应，抽象数据类型可用以下三元组表示：(D,S,P)，其中D是数据对象，S是D上的关系集，P是对D的基本操作集。</p><h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><p>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。另外，算法还具有5个重要特性：有穷性、确定性、可行性、输入、输出。</p><p>算法设计的要求你：正确性、可读性、健壮性、效率与低存储量需求。</p><p>算法效率的度量：</p><ul><li>(1)事后统计的方法</li><li>(2)事前分析估算的方法: 依据的算法选用何种策略、问题的规模(求100以内还是1000以内的素数)、书写程序的语言、编译程序所产生的机器代码的质量、机器执行指令的速度。<br>一般来说，认定一个特定算法“运行工作量”的大小，只依赖于问题的规模，即为问题规模的函数。算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作: T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度。</li></ul><p>常见的时间复杂度大小比较：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)。</p><p>算法的存储空间需求，类似算法的时间复杂度，我们以空间复杂度作为算法所需存储空间的量度，记作 S(n) = O(f(n))。若输入数据所占的空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应同时考虑输入本身所需空间。如果额外空间相对于输入数据量来说是常数，则称此算法为原地工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;一般用计算机解决问题，需经过以下几个步骤：首先要从具体问题抽象成一个适当的数学模型，然后设计一个解此数学模型的算法，最后编出
      
    
    </summary>
    
    
      <category term="考研" scheme="https://github.com/DesmonDay/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>kmeans实现</title>
    <link href="https://github.com/DesmonDay/2018/05/05/kmeans/"/>
    <id>https://github.com/DesmonDay/2018/05/05/kmeans/</id>
    <published>2018-05-05T15:55:09.000Z</published>
    <updated>2018-05-05T16:03:19.591Z</updated>
    
    <content type="html"><![CDATA[<p>由于时间关系，这里仅仅贴上对应算法的matlab代码。至于详细的算法解释，由于我是用latex写的报告，因此暂时也无法移植到blog上。之后可能会贴出对应的pdf链接之类的。对于常见算法，我直接将实现贴出，而对于只有圈内人才比较清楚的代码，我会将对应的论文名字写出来，并且贴出相应代码。代码上均有详细注释，今后考上研后，将算法解释以及python实现的代码一并写出。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 变量解释</span></span><br><span class="line"><span class="comment">% centroids为质心</span></span><br><span class="line"><span class="comment">% cluster为数据对应的类标</span></span><br><span class="line"><span class="comment">% data为输入原数据</span></span><br><span class="line"><span class="comment">% k为簇的个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[centroids,cluster]</span> = <span class="title">Kmeans</span><span class="params">(data, k)</span> </span></span><br><span class="line"><span class="comment">%% 绘制数据集原始图形,在调用函数的那里写</span></span><br><span class="line"><span class="comment">% x = data(:,1); %二维数据</span></span><br><span class="line"><span class="comment">% y = data(:,2);</span></span><br><span class="line"><span class="comment">% s = scatter(x,y);</span></span><br><span class="line"><span class="comment">% title('Aggregation cluster原始图');</span></span><br><span class="line"><span class="comment">%% 随机初始化质心</span></span><br><span class="line">[n,d] = <span class="built_in">size</span>(data);</span><br><span class="line">centroids = <span class="built_in">zeros</span>(k,d); </span><br><span class="line">minVal = min(data);</span><br><span class="line">maxVal = max(data);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:k</span><br><span class="line">    centroids(<span class="built_in">i</span>,:) = minVal + (maxVal - minVal)*<span class="built_in">rand</span>();<span class="comment">%rand()函数是返回[0,1]均匀分布随机数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 计算过程</span></span><br><span class="line">cluster = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">change = <span class="number">1</span>; <span class="comment">% 判断类标是否有改变</span></span><br><span class="line"><span class="keyword">while</span> change == <span class="number">1</span></span><br><span class="line">    change = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">% 公式1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        minDist = <span class="built_in">inf</span>;</span><br><span class="line">        minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:k</span><br><span class="line">            dist = (data(<span class="built_in">i</span>,:)-centroids(<span class="built_in">j</span>,:))*(data(<span class="built_in">i</span>,:)-centroids(<span class="built_in">j</span>,:))';</span><br><span class="line">            <span class="keyword">if</span> dist &lt; minDist</span><br><span class="line">                minDist = dist;</span><br><span class="line">                minIndex = <span class="built_in">j</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> cluster(<span class="built_in">i</span>) ~= minIndex</span><br><span class="line">            change = <span class="number">1</span>;</span><br><span class="line">            cluster(<span class="built_in">i</span>) = minIndex;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 公式2</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:k</span><br><span class="line">        sum = <span class="built_in">zeros</span>(<span class="number">1</span>,d);</span><br><span class="line">        r = <span class="number">0</span>; <span class="comment">%当前类中元素个数</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">            <span class="keyword">if</span> cluster(<span class="built_in">i</span>) == <span class="built_in">j</span></span><br><span class="line">                sum = sum + data(<span class="built_in">i</span>,:);</span><br><span class="line">                r = r + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            centroids(<span class="built_in">j</span>,:) = sum/r;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%% 作图</span></span><br><span class="line">    hold on </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">switch</span> cluster(<span class="built_in">i</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.b'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.g'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.r'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.c'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.m'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.y'</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.k'</span>);</span><br><span class="line">            <span class="keyword">otherwise</span></span><br><span class="line">                plot(data(<span class="built_in">i</span>,<span class="number">1</span>), data(<span class="built_in">i</span>,<span class="number">2</span>), <span class="string">'.k'</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于时间关系，这里仅仅贴上对应算法的matlab代码。至于详细的算法解释，由于我是用latex写的报告，因此暂时也无法移植到blog上。之后可能会贴出对应的pdf链接之类的。对于常见算法，我直接将实现贴出，而对于只有圈内人才比较清楚的代码，我会将对应的论文名字写出来，并且贴
      
    
    </summary>
    
      <category term="数据挖掘" scheme="https://github.com/DesmonDay/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="matlab" scheme="https://github.com/DesmonDay/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>如何正确学习一篇论文</title>
    <link href="https://github.com/DesmonDay/2018/04/24/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AD%A6%E4%B9%A0%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87/"/>
    <id>https://github.com/DesmonDay/2018/04/24/如何正确学习一篇论文/</id>
    <published>2018-04-23T16:05:38.000Z</published>
    <updated>2018-04-23T16:21:47.027Z</updated>
    
    <content type="html"><![CDATA[<p>最近好多人问我，你保不保研。说实话，我当然想保研，但是发现自己加分项特别少。绩点排名级六十，而参加的比赛项目却极少，直接导致我在保研这一块基本是不利的。特别是参加美赛，只得了个可怜的S奖，更加是令保研的希望很渺茫。当然，现在是坚定了考研的路了，但同时也会担心，自己的项目经历真的是等于零。</p><p>今天询问二水马，如果我跟着机器之心（一个公众号）上面的项目学习，即一般是直接跟着论文项目学习，这样子好不好。他是这么说的：你说的过一遍流程，除了看完论文，对应代码和论文的公式，跑一下论文的实验，那满分有一百分，只能给六十分。</p><p>这里得记录一下二水马提出的三个学习步骤：</p><ol><li>除了过一遍流程之外，要分析，分析论文中的优缺点，代码中的实现的细节，原因。</li><li>拓展实验，除了论文的实验，自己想几个感兴趣的点，找数据集，或者对现有的修改，然后进行新的实验，并分析结果。</li><li>论文中提出的难点哪些他已经解决了，怎么解决的，哪些没解决的，你自己的想法是什么，论文的future work里面提到的那些自己想想，可以尝试一下。</li></ol><p>通过上面三步，深入探索之后，面试官问起，就算没有很明显的创新，但起码有自己的思考在里面。其实真的很有道理，我一直想着，要参加实验室，要打比赛，要参加项目，这样才算积累经历，但是自己深入自学，这又何尝不是经历。当然，能够有实力打比赛之类的，也是极好的。</p><p>其实，我一直是缺乏自信的。文锋说，“一定要记得，厚积薄发，从知识的积累中找回你的自信，这是你今年的首要任务。之前的挫折都过去了，以后还可能会有更多，要让自己变得越来越强。”（文锋即二水马~）</p><p>是的，我要加油啊！以二水马为榜样，努力向前！今年的任务，就是找回自信！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近好多人问我，你保不保研。说实话，我当然想保研，但是发现自己加分项特别少。绩点排名级六十，而参加的比赛项目却极少，直接导致我在保研这一块基本是不利的。特别是参加美赛，只得了个可怜的S奖，更加是令保研的希望很渺茫。当然，现在是坚定了考研的路了，但同时也会担心，自己的项目经历
      
    
    </summary>
    
      <category term="杂想" scheme="https://github.com/DesmonDay/categories/%E6%9D%82%E6%83%B3/"/>
    
    
      <category term="paper" scheme="https://github.com/DesmonDay/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Reading report of Attributed Network Embedding for Learning in a Dynamic Environment</title>
    <link href="https://github.com/DesmonDay/2018/04/06/DANE/"/>
    <id>https://github.com/DesmonDay/2018/04/06/DANE/</id>
    <published>2018-04-06T02:05:45.000Z</published>
    <updated>2018-04-06T02:51:21.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h1><p>I first write the latex version. But it is hard for markdown to edit the formula, therefore I directly paste the picture that I cut. Mostly have inline formula. If you want to get the complete version, please contact me at <a href="mailto:908660116@qq.com" target="_blank" rel="noopener">908660116@qq.com</a>.</p><h1 id="Introduction-and-Contribution"><a href="#Introduction-and-Contribution" class="headerlink" title="Introduction and Contribution"></a>Introduction and Contribution</h1><p>Network structure often evolves over time with addition/deletion of links and nodes, which means the network is not static, but dynamic. It is valuable and necessary to learn about dynamic network embedding. But most of the existing famous network embedding approaches are limited to deal with plain networks. Therefore, we need to seek an effective embedding representation to capture network and attribute evolving patterns.</p><p>In the paper, the authors propose a novel dynamic attributed network embedding framework – DANE, an unsupervised embedding algorithm, which can combine node attributes and network structure information at the same time in a dynamic environment. And they are the first one to tackle the following two challenges:<br>(1)the information in network might be noisy and incomplete, it necessitates a robust consensus representation to learn their characteristics; (2)the network embedding learning should be able to adapt to the change, which means to there should be an online pattern.</p><h1 id="Main-Algorithm"><a href="#Main-Algorithm" class="headerlink" title="Main Algorithm"></a>Main Algorithm</h1><p>The algorithm contains two key steps:</p><ol><li>An offline method for a consensus embedding, and maximize the correlations between the embeddings of node attributes and node structure.</li><li>Using matrix perturbation theory to update the online embedding results.</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/8636110-8ca4d81ba7759b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Offline-Model"><a href="#Offline-Model" class="headerlink" title="Offline Model"></a>Offline Model</h2><p>Network structure and node attributes in networks are presented in different representations. In this section, the authors learn a robust consensus embedding of two different representations to help solve the data sparsity problem.</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-b7cee8bd0ba382f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Now the problem is to seek a consensus embedding. The authors propose to maximize their correlations. They seek two projection vectors $p_A^{(t)}$ and $p_X^{(t)}$ such that the correlation of $Y_A^{(t)}$ and $Y_X^{(t)}$ is maximized after projection. After some derivation about eigenvectors, the final consensus embedding representation can be computed as:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-321a64d7e490398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Online-Model"><a href="#Online-Model" class="headerlink" title="Online Model"></a>Online Model</h2><p>In real-world networks often evolve smoothly in the temporal dimension between two consecutive time steps, therefor the authors use $\Delta A$ and $\Delta X$ to denote the perturbation of network structure and node attributes between two consecutive time steps t and t+1.</p><p>The offline model focuses on finding the top eigenvectors corresponding to the smallest eigenvalues of the generalized eigen-problems. So the key idea to enable online update of the embeddings is to efficiently update the top eigenvectors and eigenvalues. Because the derivation process is long, here I skip this part and simply present the pseudo code and the final formula.</p><p>The variation of the eigenvalue is as follows:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-0730612e0942a453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>The perturbation of eigenvector a_i is as follows:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-82bf74e76f0b0771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-7f91610b1b1499b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><p>The authors use four datasets BlogCatalog, Flickr, Epinions and DBLP for experimental evaluation. And the baseline methods are Deepwalk, LINE, DANE-N, DANE-A, CCA, LCMF, LANE for different tasks. And the proposed DINE algorithm performs better than other methods.</p><h1 id="My-Idea"><a href="#My-Idea" class="headerlink" title="My Idea"></a>My Idea</h1><p>The offline model in this paper mostly focus on finding the top eigenvectors to solve the problem, which I am not familiar with. Besides, the proposed method has two inherent constraints: (1)the node attributes are related to the formation of the network; (2) requiring that between different steps, the network node property of links change little or small. </p><p>This algorithm is suitable for real time risk identification, which can rapidly update vector representation of high-dimensional information.</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>The authors first introduce the offline and online model of their algorithm, then analysis its computational complexity. Later comes the experimental part, and the tasks including network clustering and node classification. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Remark&quot;&gt;&lt;a href=&quot;#Remark&quot; class=&quot;headerlink&quot; title=&quot;Remark&quot;&gt;&lt;/a&gt;Remark&lt;/h1&gt;&lt;p&gt;I first write the latex version. But it is hard for ma
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://github.com/DesmonDay/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="paper" scheme="https://github.com/DesmonDay/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲1073. Scientific Notation</title>
    <link href="https://github.com/DesmonDay/2018/04/05/A1073/"/>
    <id>https://github.com/DesmonDay/2018/04/05/A1073/</id>
    <published>2018-04-05T14:52:55.000Z</published>
    <updated>2018-04-05T15:49:09.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]”.”[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive.</p><p>Now given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999.</p><p>Output Specification:</p><p>For each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros,</p><p>Sample Input 1:<br>+1.23400E-03<br>Sample Output 1:<br>0.00123400<br>Sample Input 2:<br>-1.2E+10<br>Sample Output 2:<br>-12000000000</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这一题是字符串处理的题目。题意很简单啊，看看给的两个例子就懂了，我现在自己写的代码是通过分类讨论来写的。但是最后有个样例一直是超时，不太清楚哪里有问题，所以接下来是打算看看别人的代码，看晴神宝典的吧。先贴上自己的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, res;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'+'</span>) f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">'+'</span> &amp;&amp; s[i] != <span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="built_in">exp</span> += (s[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>, cnt++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span>) &#123; <span class="comment">//shift right</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'-'</span>)&#123; <span class="comment">//shift left</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">//wrong</span></span><br><span class="line">        res += s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=s.length()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="built_in">exp</span>--;</span><br><span class="line">                res+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">exp</span>--)&#123;</span><br><span class="line">            res += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res += s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=s.length()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span>-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">exp</span>--)&#123;</span><br><span class="line">            res = <span class="string">'0'</span> + res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="string">"0."</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        res = <span class="string">'-'</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我后来试了一个样例，确实是会超时。不过，找不到具体的原因了，直接贴出正确能够通过的参考代码。感觉我们的思路其实是差不多的，但是他比较机智的一点是先找出E的位置，<strong>并且在过程中即可输出结果</strong>，而不是像我一样最后再输出。学习了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10010</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//存放字符串中E的位置 </span></span><br><span class="line">    <span class="keyword">while</span>(str[pos] != <span class="string">'E'</span>)&#123; </span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>; <span class="comment">//exp存放指数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">2</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="built_in">exp</span> = <span class="built_in">exp</span>*<span class="number">10</span> + (str[i]-<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pos; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str[pos+<span class="number">1</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0."</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">exp</span><span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;pos; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pos; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="built_in">exp</span>+<span class="number">2</span> &amp;&amp; pos<span class="number">-3</span> != <span class="built_in">exp</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">exp</span>-(pos<span class="number">-3</span>); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Scientific notation is the way that scientists easily handle very larg
      
    
    </summary>
    
      <category term="PAT甲" scheme="https://github.com/DesmonDay/categories/PAT%E7%94%B2/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Reading report of Multi-view Intact Space Learning</title>
    <link href="https://github.com/DesmonDay/2018/03/29/Multi-view-Intact-Space-Learning/"/>
    <id>https://github.com/DesmonDay/2018/03/29/Multi-view-Intact-Space-Learning/</id>
    <published>2018-03-29T15:25:15.000Z</published>
    <updated>2018-03-29T15:31:00.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Most of the objects have different views, so it is suitable to assume that an individual view is more likely to be insufficient for our learning. Therefore, integration of multi-view information is necessary and useful. In the paper, the authors propose the Multi-view Intact Space Learning(MISL) algorithm to integrate the information from multiple views. </p><p>Exisiting multi-view learning methods have some limitations: the issue of single-view insufficiency is not clearly addressed, fail to discover latent intact spaces, no theoratical supports to guarantee their performance. </p><h1 id="Main-Algorithm"><a href="#Main-Algorithm" class="headerlink" title="Main Algorithm"></a>Main Algorithm</h1><p>The authors assume “view insufficiency” that each view only captures partial information. In multi-view learning, each view zv is a particular reflection of the object x, and we can obtain the view generation function fv on x:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-c21e0af3cd69929d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And fv(x)=Wvx, since the function is non-invertible, Wv is not column full-rank. The object is to learn a series of view generation functions 〖{Wv}〗_(v=1)^mto generate multi-view data points from a latent intact space. It is clear to see that a straightforward approach is to minimize the empirical risk using the L1 or L2 loss. But the authors found that both two losses were not robust to outliers, therefore they deploy Cauchy estimator in MISL:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f574d66e3f17dec8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And the upper bounded influence function is:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-ae434aec01fe8bdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="MISL"><a href="#MISL" class="headerlink" title="MISL"></a>MISL</h2><p>Using the Cauchy loss and regularization terms, the resulting objective function is:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-94e0ab78424c0e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Given an input of multiple insuffiency views, the latent intact space and view generation funtions can be found. And we can infer the new data point x with optimal Wv. When the view space Z is in an infinite-dimensional space, we need to extense the kernal:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-ec0f25e4661e2c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>(not quite understand)</p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>The authors develop an IRR algorithm to optimize the sub-problems over the view generation function and the latent intact space X. The process is simple. Take finding the latent intact space X as an example. </p><p>First, we given fixed view generation functions 〖{Wv}〗_(v=1)^m. After the simplification of the objective, setting the gradient of the expression with respect to x to 0, and then using the residual of the example x on each view, we can gain weight function. Finally, we have the resulting formula:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d2096ff8b1e8d299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>The calculation of W is almost the same. Following is the pseudo code of IRR algorithm:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-afb74e4f211724e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Theoretical-Analysis"><a href="#Theoretical-Analysis" class="headerlink" title="Theoretical Analysis"></a>Theoretical Analysis</h1><p>In this section, the authors give three analysis: convergence analysis, view sufficiency analysis and the generalization error analysis. Convergence analysis mainly analyze the convergence of  IRR algorithm, and I will focus on the latter two analysis.</p><h2 id="View-insufficiency-analysis"><a href="#View-insufficiency-analysis" class="headerlink" title="View insufficiency analysis"></a>View insufficiency analysis</h2><p>The authors use the information theory to explain the view insufficiency assumption, which can be described as:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-b38ba0a595897466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>From proposition 1, we can know:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-15e46f71dfcda846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>which is very clear. And we can also obtain that more views will bring in more information. And later the authors use an information theoretical framwork developed by Sridharan and Kakade to analyze multi-view learning algorithms. </p><h2 id="Generalization-Error-Analysis"><a href="#Generalization-Error-Analysis" class="headerlink" title="Generalization Error Analysis"></a>Generalization Error Analysis</h2><p>In this section, the authors propose a new definition of multi-view stability.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d511170661f6b39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And this stability has an implicit connection with robustness. Besides, the authors use Rademacher complexity. Finally, they give the calculated multi-view stability and Rademacher complexity of their algorithm, which is also the generalization error bound of MISL. </p><h1 id="My-Idea"><a href="#My-Idea" class="headerlink" title="My Idea"></a>My Idea</h1><p>To my best knowledge, the objective function of MISL algorithm is a bit simple compared with other papers (Although I do not quite understand about the kernel extension part). In the paper, the authors seem not to clearly explain about the view generation function W, which I think needed consideration. Maybe there is better way to give the clear definition of this part. And I think we can draw lessons from the heterogeneous network embedding.</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>The authors first introduce their proposed algorithm and their optimization method, and then give three kinds of analysis of the algorithms, including convergence analysis, view sufficiency analysis and the generalization error analysis. Finally, comes the experiment part.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;Most of the objects have diffe
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://github.com/DesmonDay/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="paper" scheme="https://github.com/DesmonDay/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙1028.人口普查</title>
    <link href="https://github.com/DesmonDay/2018/03/25/1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/"/>
    <id>https://github.com/DesmonDay/2018/03/25/1028-人口普查/</id>
    <published>2018-03-25T13:48:21.000Z</published>
    <updated>2018-03-25T14:08:12.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p><p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><p>输入格式：</p><p>输入在第一行给出正整数N，取值在(0, 105]；随后N行，每行给出1个人的姓名（由不超过5个英文字母组成的字符串）、以及按“yyyy/mm/dd”（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p><p>输出格式：</p><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p><p>输入样例：<br>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20<br>输出样例：<br>3 Tom John</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这一道思路很简单，但是我做麻烦了！主要是把生日的输入当成了字符串，而看了一下算法笔记，是可以直接整数输入的，这个地方我确实不懂，现在懂了！另外有个地方我没有注意，就是输出有效生日的个数，当为0时，我没有处理，因此会出现有个样例没有通过。贴出我通过了的代码，只是比较麻烦。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">birth</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> birthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(year &lt; <span class="number">1814</span> || year&gt;<span class="number">2014</span>)&#123;</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((year==<span class="number">1814</span> &amp;&amp; month&lt;<span class="number">9</span>) || (year==<span class="number">2014</span> &amp;&amp; month&gt;<span class="number">9</span>))&#123;</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((year==<span class="number">1814</span> &amp;&amp; month==<span class="number">9</span> &amp;&amp; day&lt;<span class="number">6</span>) || (year==<span class="number">2014</span> &amp;&amp; month==<span class="number">9</span> &amp;&amp; day&gt;<span class="number">6</span>))&#123;</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    birth b[<span class="number">100003</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i].name &gt;&gt; b[i].birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> valid_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//看是否年老于当前生日,日期是要小的 </span></span><br><span class="line">    <span class="keyword">int</span> year1=<span class="number">2015</span>, month1=<span class="number">13</span>, day1=<span class="number">32</span>;</span><br><span class="line">    <span class="comment">//看是否年轻于当前生日,日期是要大的 </span></span><br><span class="line">    <span class="keyword">int</span> year2=<span class="number">0</span>, month2=<span class="number">0</span>, day2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">0</span>, month = <span class="number">0</span>, day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;b[i].birthday.length(); j++)&#123; <span class="comment">//得到对应的年月日数字 </span></span><br><span class="line">            <span class="keyword">int</span> x = b[i].birthday[j] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                year += x*<span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">3</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">5</span> &amp;&amp; j&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">                month += x*<span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">6</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">                day += x*<span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(valid(year, month, day))&#123;</span><br><span class="line">            valid_++;</span><br><span class="line">            <span class="keyword">if</span>((year1&gt;year) || (year1==year&amp;&amp;month1&gt;month) || (year1==year&amp;&amp;month1==month&amp;&amp;day1&gt;day))&#123;</span><br><span class="line">                year1 = year;</span><br><span class="line">                month1 = month;</span><br><span class="line">                day1 = day;</span><br><span class="line">                index1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((year2&lt;year) || (year2==year&amp;&amp;month2&lt;month) || (year2==year&amp;&amp;month2==month&amp;&amp;day2&lt;day))&#123;</span><br><span class="line">                year2 = year;</span><br><span class="line">                month2 = month;</span><br><span class="line">                day2 = day;</span><br><span class="line">                index2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(valid_ == <span class="number">0</span>)&#123; <span class="comment">//这里！ </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; valid_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; valid_ &lt;&lt; <span class="string">" "</span> &lt;&lt; b[index1].name &lt;&lt; <span class="string">" "</span> &lt;&lt; b[index2].name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外，贴出算法笔记另一种写法，主要是对生日的输入处理。除了这个部分，其他的地方也是值得学习的，比如判断条件。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里结构体的使用也要学习</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> yy, mm, dd; </span><br><span class="line">&#125; oldest, youngest, left_, right_, temp; </span><br><span class="line"><span class="comment">//left与right存放合法日期的左右边界 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lessEqu</span><span class="params">(person a, person b)</span></span>&#123; <span class="comment">//如果a的日期小于等于b，返回true </span></span><br><span class="line">    <span class="keyword">if</span>(a.yy != b.yy)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.yy &lt;= b.yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.mm != b.mm)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.mm &lt;= b.mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.dd &lt;= b.dd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MoreEqu</span><span class="params">(person a, person b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.yy != b.yy)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.yy &gt;= b.yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.mm != b.mm)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.mm &gt;= b.mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.dd &gt;= b.dd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    youngest.yy = left_.yy = <span class="number">1814</span>;</span><br><span class="line">    oldest.yy = right_.yy = <span class="number">2014</span>;</span><br><span class="line">    youngest.mm = left_.mm = oldest.mm = right_.mm = <span class="number">9</span>;</span><br><span class="line">    youngest.dd = left_.dd = oldest.dd = right_.dd = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">int</span> n, num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d/%d/%d"</span>, temp.name, &amp;temp.yy, &amp;temp.mm, &amp;temp.dd);</span><br><span class="line">        <span class="keyword">if</span>(MoreEqu(temp, left_) &amp;&amp; lessEqu(temp, right_))&#123; <span class="comment">//合法</span></span><br><span class="line">            num ++;</span><br><span class="line">            <span class="keyword">if</span>(lessEqu(temp, oldest)) oldest = temp;</span><br><span class="line">            <span class="keyword">if</span>(MoreEqu(temp, youngest)) youngest = temp; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %s %s\n"</span>, num, oldest.name, youngest.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案明显要简洁了许多，另外因为不用处理字符串，用时了短了许多，边输入边比较，内存占用得也少。。。对比之下，我的代码好渣！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。&lt;/p&gt;
&lt;p&gt;这里确保每个输入的日期都是合法的，但不
      
    
    </summary>
    
      <category term="PAT乙" scheme="https://github.com/DesmonDay/categories/PAT%E4%B9%99/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲1065.A+B and C (64bit)</title>
    <link href="https://github.com/DesmonDay/2018/03/24/A1065/"/>
    <id>https://github.com/DesmonDay/2018/03/24/A1065/</id>
    <published>2018-03-24T14:56:06.000Z</published>
    <updated>2018-03-24T15:39:22.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given three integers A, B and C in [-2^63, 2^63], you are supposed to tell whether A+B &gt; C.</p><p>Input Specification:</p><p>The first line of the input gives the positive number of test cases, T (&lt;=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.</p><p>Output Specification:</p><p>For each test case, output in one line “Case #X: true” if A+B&gt;C, or “Case #X: false” otherwise, where X is the case number (starting from 1).</p><p>Sample Input:<br>3<br>1 2 3<br>2 3 4<br>9223372036854775807 -9223372036854775808 0<br>Sample Output:<br>Case #1: false<br>Case #2: true<br>Case #3: false</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>之前我在乙题那里也做过类似的题，不过它是32位的，只要用long long就可以了。今天这道题我吸取了教训，然后就直接用double来存储数据，然而发现，结果不对？？是的，不管我怎么测试，感觉double的范围就是比long long大啊，但是结果都是错的。无奈之下，只能用long long加溢出判断了。</p><p>特殊情况：</p><ol><li>当A+B&gt;=2^63，显然有A+B&gt;C成立。然而因为相加后溢出，导致相加后的结果为负，需要处理;</li><li>与1相反，当A+B&lt;=-2^63时，显然不成立，但相加后溢出结果大于等于0，需要处理。</li></ol><p>依稀觉得这题很熟悉！！记住了！！不能忘记！！代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b, c;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=t; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;<span class="number">0</span> &amp;&amp; a&gt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">0</span> &amp;&amp; b&lt;<span class="number">0</span> &amp;&amp; a+b&gt;=<span class="number">0</span>)&#123; <span class="comment">//&gt;=</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a+b &gt; c)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a+b &lt;= c)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后还是乖乖按题目要求做题好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Given three integers A, B and C in [-2^63, 2^63], you are supposed to 
      
    
    </summary>
    
      <category term="PAT甲" scheme="https://github.com/DesmonDay/categories/PAT%E7%94%B2/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲1042和1046</title>
    <link href="https://github.com/DesmonDay/2018/03/24/A1042%E5%92%8C1046/"/>
    <id>https://github.com/DesmonDay/2018/03/24/A1042和1046/</id>
    <published>2018-03-24T11:32:41.000Z</published>
    <updated>2018-03-24T12:03:46.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1042-Shuffling-Machine"><a href="#1042-Shuffling-Machine" class="headerlink" title="1042 Shuffling Machine"></a>1042 Shuffling Machine</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.</p><p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p><p>S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2</p><p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><p>Sample Input:<br>2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</p><p>Sample Output:<br>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的意思是，在原先56张纸牌顺序依次排放时，通过输入的次序来对纸牌的摆放进行t次换位。具体的过程可以通过题目中所给的例子来了解。我这题的思路是，将输入的纸牌顺序使用一个order数组来存储，因为我们可能对纸牌进行多次换位，所以这个输入的数组需要记住；而我用card数组来代表对应纸牌当前的顺序，用1到54分别代表54张纸牌。</p><p>当读入数组时，card数组也依次赋对应的值，此时相当于进行了第一次换位。随后，在剩余的t-1次中，利用card数组原有的值，在order中查找对应下标对应的值，即为纸牌新的顺序，即card[j] = order[card[j]]。具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; j&lt;=<span class="number">13</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">14</span> &amp;&amp; j&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"H"</span> &lt;&lt; j<span class="number">-13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">27</span> &amp;&amp; j&lt;=<span class="number">39</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"C"</span> &lt;&lt; j<span class="number">-26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">40</span> &amp;&amp; j&lt;=<span class="number">52</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"D"</span> &lt;&lt; j<span class="number">-39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"J"</span> &lt;&lt; j<span class="number">-52</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t; </span><br><span class="line">    <span class="keyword">int</span> card[<span class="number">55</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> order[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">54</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; order[i];</span><br><span class="line">        card[i] = order[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;t; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">54</span>; j++)&#123; <span class="comment">//纸牌,关键 </span></span><br><span class="line">            card[j] = order[card[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=54; i++)&#123;cout&lt;&lt;card[i]&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">54</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">54</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == card[j] &amp;&amp; i!=<span class="number">54</span>)&#123;</span><br><span class="line">                turn(j);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == card[j] &amp;&amp; i==<span class="number">54</span>)&#123;</span><br><span class="line">                turn(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来以为这题自己做不出来，后来认真想想发现其实很简单啦，还是要对自己有信心。另外看了看算法笔记上的题解，感觉还有些麻烦，不如我的做法简单。</p><h1 id="1046-Shortest-Distance"><a href="#1046-Shortest-Distance" class="headerlink" title="1046 Shortest Distance"></a>1046 Shortest Distance</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.</p><p>Output Specification:</p><p>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p><p>Sample Input:<br>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1<br>Sample Output:<br>3<br>10<br>7</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我的思路很简单，就是把输入的所有距离放在一个数组里。然后再根据之后输入的入口和出口对进行计算，由于要计算两次距离，一次是两个出口之间的直接距离，一次是通过大数折返回小数的距离(环状)<br>，因此用了三次for循环（后者要用两次）。然后这样导致的问题是，超时。。。代码交上去后，有个测试点过不了，原因就是超时。一开始我以为是我输入输出用了cin和cout，改了之后发现没用。原因如下：</p><p>这里借用算法笔记的说法：在极端情况下，每次查询都需要遍历整个数组，即有10^5次操作，而共有10^4次查询，所有会有10^9此操作，这在100ms内无法完成。贴出我的超时代码吧，好歹也有17分（总分20）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">100005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y)&#123; <span class="comment">//保证前面的大 </span></span><br><span class="line">                <span class="keyword">int</span> temp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> dis1=<span class="number">0</span>, dis2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;y; i++)&#123;</span><br><span class="line">                dis1 += dis[i];</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;x; i++)&#123;</span><br><span class="line">                dis2 += dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=y; i&lt;=n; i++)&#123;</span><br><span class="line">                dis2 += dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(dis1, dis2));</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来的解法是看算法笔记的。它的思路其实也很直接，并且也很方便。。。哎，我的一开始的思路确实是不太对。傻逼了啊！</p><ol><li>记录路程总长度sum，这个变量可以边输入边计算。</li><li>以dis[i]表示1号结点按顺时针到达”i号结点顺时针方向的下一个结点”的距离(1&lt;=i&lt;=N)，同样可以边输入边累加。</li><li>从left到right的直接距离计算：dist1 = dis[right-1]-dis[left-1]，而另一个方向距离则直接为sum-dist1。</li></ol><p>这样做，查询的复杂度就达到O(1)了，真聪明啊！修改后代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">100005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        temp += x;</span><br><span class="line">        sum += x;</span><br><span class="line">        dis[i] = temp; <span class="comment">//第1位，储存了1出口和2出口的距离 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x == y)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y)&#123; <span class="comment">//保证前面的大 </span></span><br><span class="line">                <span class="keyword">int</span> temp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">int</span> dis1 = dis[y<span class="number">-1</span>] - dis[x<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> dis2 = sum-dis1;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(dis1, dis2));</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后还是得注意一下这类问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1042-Shuffling-Machine&quot;&gt;&lt;a href=&quot;#1042-Shuffling-Machine&quot; class=&quot;headerlink&quot; title=&quot;1042 Shuffling Machine&quot;&gt;&lt;/a&gt;1042 Shuffling Machi
      
    
    </summary>
    
      <category term="PAT甲" scheme="https://github.com/DesmonDay/categories/PAT%E7%94%B2/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Reading report of Robust continuous clustering</title>
    <link href="https://github.com/DesmonDay/2018/03/23/RCC/"/>
    <id>https://github.com/DesmonDay/2018/03/23/RCC/</id>
    <published>2018-03-23T10:32:09.000Z</published>
    <updated>2018-03-23T10:45:38.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Movitivation"><a href="#Movitivation" class="headerlink" title="Movitivation"></a>Movitivation</h1><p>Clustering has been studied for decades, but the existing clustering algorithms still have many shortcomings, like having limited effectiveness in high dimensions and often requiring tuning parameters for different domains and datasets. In order to solve the above problems, the authors present a new clustering algorithm called RCC(Robust continuous clustering), which achieves high accuracy across multiple domains and scales efficiently to high dimensions and large datasets.</p><h1 id="Main-Algorithm"><a href="#Main-Algorithm" class="headerlink" title="Main Algorithm"></a>Main Algorithm</h1><h2 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h2><p>The fundamental principle of the algorithm is to find the appropriate representatives U for the corresponding data point X. And we need to operate the optimization on U.<br>The RCC objective 1 has the following form:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-7c0c6a468f18d5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>The funtion ρ(∙) is a robust penalty function on the regularization terms, which is central to the method. There are two expectations on this term: (1)we want representative ui from the same latent cluster to collapse into a single point; (2) we want the penalty function to be robust enough. Therefore, the authors decided to use robust estimators. The weight wp,q and λ are the balance factors, and ε is the set of edges in the graph.</p><p>The second term in the objective is related to the mean shift objective. Later, the authors provide a reformulated objective 2.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d1fdb418c410e3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>The new objective adds an auxiliary variable lp,q for each connection in ε, and together optimize both the representative U and the line process L, where   is a penalty on the connection. Why the authors use objective 2 is because its form enables efficient and scalable optimization by iterative solution of linear least-square systems, which yields a general approach, for three reasons:</p><ol><li>accommodate many robust nonconvex functions ρ.</li><li>reduce clustering to the application of linear system solvers.</li><li>easily scale to high dimensions and large datasets.</li></ol><p>In the paper, ρ(y) uses the Geman-McClure estimater, and μ is a scale parameter:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-bcf4c033c6361d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And the corresponding penalty function that equals objective 1 and 2 is :<br><img src="https://upload-images.jianshu.io/upload_images/8636110-1275f793248fb51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>Later, the authors give the optimization of the above objectives, which I don’t introduce much here. When U are fixed, the optimal value of each lp,q is given by:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-537d8030574c405b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And when L are fixed, we can rewrite the expression to solve U, which turns into a linear least-squares problem:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-d9e71d1ae4186bc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>The pseudo code of RCC is followed:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-2d85d77f4677aac3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="RCC-DR"><a href="#RCC-DR" class="headerlink" title="RCC-DR"></a>RCC-DR</h2><p>In RCC, the dimensionality of the embedding U is the same as the dimensionality of the data X. And since RCC optimizes a continuous and differentiable objective, it can be used within end-to-end feature learning pipelines. In this section, the authors extend RCC to perform joint clustering and dimensionality reduction, called RCC-DR.<br>The final formulation of the RCC-DR objective is:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-36cad4727653cc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Where D∈R(Dxd) is a dictionary, zi∈R(Dxd) is a sparse code corresponding to the ith data sample, and ui∈R(d) is the low dimensional embedding of xi. The optimization is performed by block coordinate descent over U, Z, D, L1 and L2. The variables U are updated by solving linear system.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-901c888b05dd6a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/8636110-b62da3b876e8f103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And the dictionary D and codes Z are initialized using PCA and updated by different methods.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-f1389587eba8f7d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/8636110-db8ef58d51f0fb2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><p>In the paper, the authors propose an algorthm called RCC, which optimizes a continuous objective based on robust estimation. And its end-to-end feature learning pipelines allow it to perform joint clustering and dimensionality reduction. This method achieves high accuracy across multiple domains and scales efficiently to high dimensions and large datasets. </p><h1 id="My-Idea"><a href="#My-Idea" class="headerlink" title="My Idea"></a>My Idea</h1><p>Actually, I don’t quite understand about this paper. I don’t know how the authors comp up with such wonderful idea about robust estimators, and how can they smartly turn a complicated optimization problem into linear least-squares solvers. Maybe it will be better if we can get the code of the Algorithm to study. </p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>The authors first give us the principle of RCC, and then extend it by to perform joint clustering and dimensionality reduction, called RCC-DR. And most of the thesis is talking about the objectives of the algorithm, and the optimization method they use. In the final part, they do a lot of experiments compared with RCC, RCC-DR and other 13 baselines about the results and running time on different datasets.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Movitivation&quot;&gt;&lt;a href=&quot;#Movitivation&quot; class=&quot;headerlink&quot; title=&quot;Movitivation&quot;&gt;&lt;/a&gt;Movitivation&lt;/h1&gt;&lt;p&gt;Clustering has been studied fo
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://github.com/DesmonDay/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="paper" scheme="https://github.com/DesmonDay/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习(1)</title>
    <link href="https://github.com/DesmonDay/2018/03/21/opengl1/"/>
    <id>https://github.com/DesmonDay/2018/03/21/opengl1/</id>
    <published>2018-03-21T15:58:33.000Z</published>
    <updated>2018-03-21T16:05:34.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGL学习"><a href="#OpenGL学习" class="headerlink" title="OpenGL学习"></a>OpenGL学习</h1><p>实验室师兄有项目是做3D虚拟环境，而我对这一方面也比MRCP强烈许多（捂脸）。现在所在的无人系统实验室，我所在的方向是脑电方向。但发现我对这一块其实并没有太大兴趣，而更偏向具有实质性效果的研究，比如机器学习、大数据这块。废话一下说了好多，现在就开始学习吧。</p><p>我所使用的学习教程是<a href="https://learnopengl-cn.github.io，据说很不错。和Linux学习一样，同样基本按照教程走，记录自己觉得重要的地方，有时候全部摘抄。" target="_blank" rel="noopener">https://learnopengl-cn.github.io，据说很不错。和Linux学习一样，同样基本按照教程走，记录自己觉得重要的地方，有时候全部摘抄。</a></p><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>OpenGL一般被认为是一个API(Application Programming Inerface，应用程序编程接口)，包括了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是API，而仅仅是一个由Khronos组织制定并维护的规范(Specification)。</p><p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。而内部具体每个函数的实现，则是由OpenGL库的开发者自行决定。实际的OpenGL库的开发者通常是显卡的生产商。比如Apple系统、Linux系统，均由不同开发商维护。由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL。</p><h2 id="核心模式与立即渲染模式"><a href="#核心模式与立即渲染模式" class="headerlink" title="核心模式与立即渲染模式"></a>核心模式与立即渲染模式</h2><p>早期OpenGL使用立即渲染模式（固定渲染管线），这个模式下绘制图形很方便。但由于随着时间推移，开发者对绘图细节有了更多掌控，而立即渲染模式效率太低，因此如今规范文档鼓励开发者在核心模式下进行开发。</p><p>当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>OpenGL的一大特性是对扩展的支持。当一个显卡公司提出一个新特性或者渲染上的优化，通常以<strong>扩展</strong>的方式在驱动中实现。使用扩展的代码大多看上去如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)&#123;</span><br><span class="line">    <span class="comment">//使用硬件支持的全新的现代特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不支持此扩展，用旧的方式去做。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL自身是一个巨大的状态机：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径来更改OpenGL状态：设置选项，操作缓冲。最后，使用当前OpenGL上下文来渲染。</p><p>假设我们想告诉OpenGL画线段而不是三角形时，通过改变上下文变量来改变OpenGL状态，从而告知其如何绘图。一旦我们改变了OpenGL状态为绘制线段，下一个绘制命令就会绘制线段而不是三角形。</p><p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍然是一个C库。由于C的一些语言结构不易被翻译到其他高级语言，因此OpenGL开发时引入抽象层，如对象(Object)。</p><p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后就可以设置其大小、支持的颜色位数等等，可以把对象看作一个C风格的结构体（Struct):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_name</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> option1;</span><br><span class="line">    <span class="keyword">int</span> option2;</span><br><span class="line">    <span class="keyword">char</span>[] name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们使用一个对象时，通常看起来如下（把OpenGL上下文看作一个大的结构体）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenGL的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenGL_Context</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    object* object_window_Target;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId=<span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">//绑定对象至上下文</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">//设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面代码展示了OpenGL常见工作流：首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）；随后将对象绑定至上下文目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）；接下来设置窗口选项；最后将目标位置id设回0，解绑对象。</p><p>设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p><p>使用对象的好处是，在程序中我们可以定义多个对象，并且设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作时，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。</p><p>理论知识基本介绍完毕。</p><p><a href="http://blog.csdn.net/wangdingqiaoit/article/category/2107037/2" target="_blank" rel="noopener">http://blog.csdn.net/wangdingqiaoit/article/category/2107037/2</a> 这个博客可留作补充学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenGL学习&quot;&gt;&lt;a href=&quot;#OpenGL学习&quot; class=&quot;headerlink&quot; title=&quot;OpenGL学习&quot;&gt;&lt;/a&gt;OpenGL学习&lt;/h1&gt;&lt;p&gt;实验室师兄有项目是做3D虚拟环境，而我对这一方面也比MRCP强烈许多（捂脸）。现在所在的无人
      
    
    </summary>
    
      <category term="OpenGL学习" scheme="https://github.com/DesmonDay/categories/OpenGL%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="opengl" scheme="https://github.com/DesmonDay/tags/opengl/"/>
    
  </entry>
  
  <entry>
    <title>算法阅读笔记--日期处理</title>
    <link href="https://github.com/DesmonDay/2018/03/21/%E7%AE%97%E6%B3%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>https://github.com/DesmonDay/2018/03/21/算法阅读笔记-日期处理/</id>
    <published>2018-03-20T16:25:35.000Z</published>
    <updated>2018-03-27T12:44:51.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h1><p>因为自己一向不擅长这类题，所以把它分出来做成一个博文，以便自己回头时不时重看。我们不仅需要处理平年和闰年（二月的天数区别）、大月和小月的问题，因此细节比较多。下面以《算法笔记》中所给的例子来进行学习。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目描述：有两个日期，求两个日期之间的天数，如果两个日期是连续的，则规定它们之间的天数为两天。</p><p>输入格式：有多组输入，每组数据有两行，分别表示两个日期，形式为YYYYMMDD。</p><p>输出格式：每组数据输出一行，即日期差值。</p><p>样例输入<br>20130101<br>20130105</p><p>样例输出<br>5</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就直接看的答案，确实此类题我不太会。输入直接为数字，再分别处理为年月日。一天天的数，到了月边界或者年边界就处理。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>]&#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">28</span>,<span class="number">29</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">30</span>,<span class="number">30</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">30</span>,<span class="number">30</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;, &#123;<span class="number">30</span>,<span class="number">30</span>&#125;, &#123;<span class="number">31</span>,<span class="number">31</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time1, y1, m1, d1;</span><br><span class="line">    <span class="keyword">int</span> time2, y2, m2, d2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;time1, &amp;time2) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(time1 &gt; time2)&#123; <span class="comment">//第一个日期大，则交换 </span></span><br><span class="line">            <span class="keyword">int</span> temp = time1;</span><br><span class="line">            time1 = time2;</span><br><span class="line">            time2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        y1 = time1 / <span class="number">1000</span>, m1 = time1 % <span class="number">10000</span> / <span class="number">100</span>, d1 = time1 % <span class="number">100</span>;</span><br><span class="line">        y2 = tiem2 / <span class="number">1000</span>, m2 = time2 % <span class="number">10000</span> / <span class="number">100</span>, d2 = time2 % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2)&#123;</span><br><span class="line">            d1++;</span><br><span class="line">            <span class="keyword">if</span>(d1 == month[m1][isLeap(y1)] + <span class="number">1</span>)&#123; <span class="comment">//满当月天数 </span></span><br><span class="line">                 m1++; <span class="comment">//日期变为下个月的1号 </span></span><br><span class="line">                 d1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m1 == <span class="number">13</span>)&#123; <span class="comment">//月份满12个月 </span></span><br><span class="line">                y1++;</span><br><span class="line">                m1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特别要学习的是对于月份天数的二维数组的使用，并且和平闰年的判断函数结合在了一起，比较方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日期处理&quot;&gt;&lt;a href=&quot;#日期处理&quot; class=&quot;headerlink&quot; title=&quot;日期处理&quot;&gt;&lt;/a&gt;日期处理&lt;/h1&gt;&lt;p&gt;因为自己一向不擅长这类题，所以把它分出来做成一个博文，以便自己回头时不时重看。我们不仅需要处理平年和闰年（二月的天数区别）、
      
    
    </summary>
    
      <category term="笔记" scheme="https://github.com/DesmonDay/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Reading report of Clustering by fast search and find of density peaks</title>
    <link href="https://github.com/DesmonDay/2018/03/20/clustering-by-fast-search/"/>
    <id>https://github.com/DesmonDay/2018/03/20/clustering-by-fast-search/</id>
    <published>2018-03-20T12:16:21.000Z</published>
    <updated>2018-03-23T10:31:23.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>Classical clustering methods K-means and K-medoids find cluster centers by initially assigning cluster center(s) and iteratively update it(them). Because every data point is assigned to the nearest cluster center(using distance), K-means and K-medoids can not detect nonspherical clusters. If we want to detect clusters with an arbitrary shape, we should perform density-based approaches. Although density-based spatial clustering of applications with noise(DBSCAN) can detect arbitrary shapes, we need to manually setting the density threshold, which is non-trivial. As for mean-shift clustering method, a cluster is defined as local maxima in the density of data points, which allows the findings of nonspherical clusters but requires embedding the data. </p><p>In the paper, the authors propose a new simple and efficient algorithm, which combines the advantages of the above cluster methods, but also overcomes their shortcomings.</p><h1 id="Main-algorithms"><a href="#Main-algorithms" class="headerlink" title="Main algorithms"></a>Main algorithms</h1><p>The algorithm is based on two principles, which reaches on the definition of a cluster.</p><ol><li>Cluster centers have higher local density, which means they are surrounded by neighbors with lower local density;</li><li>Cluster centers are at a relatively large distance from points with a higher local density.</li></ol><h2 id="Computing-local-density-ρ-i"><a href="#Computing-local-density-ρ-i" class="headerlink" title="Computing local density ρ_i"></a>Computing local density ρ_i</h2><p>In the paper, the authors use two different methods to calculate the local density. In most of the datasets, using cutoff distance:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-59c822bc11e001f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>where χ(x) = 1 if x&lt;0 and χ(x) = 0 otherwise, and d_c is a cutoff distance. This algorithm is sensitively only to the relative magnitude of ρi, but robust to the choice of d_c.</p><p>When applying approach on Olivetti Face Database, the authors use a Guassian kernal to calculate distance:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-a70d9521a8a128f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>And we can see that the first one is discrete value, the second one is continuous value, which means the former one is more easy to conflict.</p><h2 id="Calculating-distance-δ-i"><a href="#Calculating-distance-δ-i" class="headerlink" title="Calculating distance δ_i"></a>Calculating distance δ_i</h2><p>δ_i is measured by the minimum distance between point i and other points with higher local density.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-671fe4f645ffd5b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>For the point with highest density, take δ_i=maxj(dij). Here we may jump in such dilemma, maybe point i and point j has the same density, and they happen to be in the same cluster. If we using the following cluster procedure, we may choose both two point as cluster centers, and takes one cluster apart. </p><p>When I search some relevant information online, I find a better understanding of δ_i, which defines as followed:<br>Suppose {q_i }_(i=1)^N represents the descending index order of {ρ<em>i }\</em>(i=1)^N, which mean it satisfies:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-b39162471428cd08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="Cluster-procedure"><a href="#Cluster-procedure" class="headerlink" title="Cluster procedure"></a>Cluster procedure</h2><p>In order to choose the cluster center, the authors find such observation: the points of high δ and relatively high ρ are the cluster centers. In order to better visualize the result, they create a decision graph, which shown as followed:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-b7209009ad681c73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>From the figure, we can clearly see that point 1 and 10 are clusters. In the paper, the isolated points are 26,27,28. (But in the paper, the authors did not clearly propose an exact way to find out the outliers, which I think needed consideration.) But one thing we should mention is that we define the cluster center in a qualitative analysis but not a quantitative analysis, which would cause puzzles.<br><img src="https://upload-images.jianshu.io/upload_images/8636110-4399580d34e2186d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>When we see figure A, the number of cluster centers is not clear and some may think different points as cluster centers. So as to determine the number of cluster centers, the authors gave a metric value:<br><img src="https://upload-images.jianshu.io/upload_images/8636110-ea19feef45766ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>In figure B, γ is pointed out. We can see that the higher γ is morely like the cluster center. And there is a clear different between cluster center and other points: the latter is relatively smooth, and there is a clear jump between cluster center and other points. In this way, we can see there are nine center clusters in the above figure.</p><h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><p>This paper is the first one which combines local density and distance together. Besides, the algorithm it propose is easy and feasible, which I believe has inspired a lot of people.<br>Although from my perspective, it has some small problems. But this bran-new idea deserves our respect.</p><h1 id="My-Idea"><a href="#My-Idea" class="headerlink" title="My Idea"></a>My Idea</h1><p>There are three points that I feel confused:<br>First, how to find the outliers? In this part the authors did not mention about it, maybe because this is not their main point.<br>Second, in the paper, the authors did not clearly how they elaborate the distance between two points, which means there is not specific distance formula.<br>Third, maybe the last metric value γ, we can normalize ρ and δ. </p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>In the paper, the authors propose a simple and robust algorithm of the choice of cluster centers. It is easy for us to understand and know how to realize. But the paper still has some questions to be solved. </p><p>First, the authors declare two variables we need to calculate, then tell us how to use them to find the cluster center. In the experimental part, their algorithm shows great results on real datasets.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h1&gt;&lt;p&gt;Classical clustering methods K-means a
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://github.com/DesmonDay/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="paper" scheme="https://github.com/DesmonDay/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记阅读1</title>
    <link href="https://github.com/DesmonDay/2018/03/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E9%98%85%E8%AF%BB1/"/>
    <id>https://github.com/DesmonDay/2018/03/19/算法笔记阅读1/</id>
    <published>2018-03-19T15:21:12.000Z</published>
    <updated>2018-03-20T06:50:27.549Z</updated>
    
    <content type="html"><![CDATA[<p>新开了个目录，因为发现其他的目录似乎不太合适。就当记录自己平时的一些笔记好了，现在看晴神宝典，据说是PAT神级书，希望我甲级考高分啦！下面就是简单的记录一些自己不太知道，或者容易忘记的东西，以后也都是这样。下面记的是一些基础知识。</p><h1 id="变量型"><a href="#变量型" class="headerlink" title="变量型"></a>变量型</h1><ol><li>int: 一个整数占32bit，取值范围大致是-2<em>10^9~2</em>10^9(-2^31~2^31-1).</li><li>long long: 一个整数占用64bit，取值-2^63~2^63-1</li><li>如果long long型赋大于2^31-1的初值，则需要在初值后面加上LL，否则会编译错误。</li><li>对于浮点型，以后都是用double来存储。</li><li>小写字母比大写字母的ASCII码大32。</li><li><p>C的字符串常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">25</span>] = <span class="string">"wo ai de ren bu ai wo"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">25</span>] = <span class="string">"so sad a story it is."</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s, %s"</span>, str1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>整型常量在赋值给布尔型变量时会自动转换成true(非零)或者false(零)</p></li><li><p>常量定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义,符号常量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> pi 3.14</span></span><br><span class="line"><span class="comment">// const 常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure></li><li><p>scanf(“格式控制”, 变量地址); 如scanf(“%d”, &amp;n); 另外要注意，数组名称本身代表了这个数组第一个元素的地址，所以不需要再加取地址运算符。在scanf中，除了char数组整个输入的情况不加&amp;s之外，其他变量类型都需要加&amp;。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">23</span>] = <span class="string">"23 sfs fsa"</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure></li><li><p>scanf对其他格式符(如%d)的输入是以空白符（空格、Tab）为结束判断标志；字符数组使用%s读入的时候以空格跟换行为读入结束标志。另外，scanf的%c格式是可以读入空格跟换行的。以下面为例子，c为空格：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c, str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;a, &amp;c, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,c=%c,str=%s"</span>, a, c, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入: 1 a bcd</span></span><br><span class="line"><span class="comment">//输出：a=1,c= ,str=a(在我的电脑上测试,str输出乱码)</span></span><br></pre></td></tr></table></figure></li><li><p>scanf的double类型变量为%lf，而在printf则为%f。</p></li></ol><h1 id="三种实用的输出格式"><a href="#三种实用的输出格式" class="headerlink" title="三种实用的输出格式"></a>三种实用的输出格式</h1><p>(1) %md<br>%md可以使不足m位的int型变量以m位进行右对齐输出，其中高位用空格补齐；如果变量本身超过m位，则保持原样。实例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>, b = <span class="number">1234567</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%5d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%5d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">  123   //不足5位，前面自动用两个空格填充</span></span><br><span class="line"><span class="comment">1234567 //大于5位，直接输出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>(2)%0md<br>和%md唯一的不同点是，当变量不足m位时，将在前面补足够数量的0而不是空格。<strong>非常实用啊！</strong>以后就可以不用判断了，比如时间等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>, b = <span class="number">1234567</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">00123</span></span><br><span class="line"><span class="comment">1234567</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>(3)%.mf<br>保留m位小数。如保留1位: be accurate to 1 decimal place.</p><h1 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h1><ol><li>getchar用来输入单个字符，putchar用来输出单个字符。另外注意，getchar()可以用来识别换行符。gets用来输入一行字符串(<strong>识别\n换行符作为输入结束，因此scanf完一个整数后，如果要使用gets，需要先用getchar接收整数后的换行符</strong>)。</li><li>fabs(double x)用来对double型变量取绝对值，abs用于整型。</li><li>floor(double x)和ceil(double)分别用于double型变量的向下取整和向上取整。</li><li><p>sin(double x), cos(double x), tan(double x)参数要求是弧度制，示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db1 = <span class="built_in">sin</span>(pi*<span class="number">45</span>/<span class="number">180</span>);</span><br></pre></td></tr></table></figure></li><li><p>asin(double x), acos(double x), atan(double x)。</p></li><li>round(double x) 代表四舍五入取整。</li><li>switch语句<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于case本身默认把两个case之间的内容全部作为上一个case的内容，因此不需要加大括号。</p><ol start="8"><li>break可强制退出switch语句和循环；continue在需要的地方临时结束循环的当前轮回，然后进入下一个轮回。</li><li>对数组而言，如果不赋值，则系统会随机赋值；如果赋值但没有全部赋完，则没有赋值的位置一般为0。</li><li>特别提醒：如果数组大小较大（大概10^6级别），则需要将其定义在主函数外面，否则会使程序异常退出。原因是函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全部变量来自静态存储区，允许申请的空间较大。</li><li>memset(数组名, 值, sizeof(数组名)); 建议只能赋值0或-1，如果赋值其他值，使用fill，但速度慢。</li></ol><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>算法复杂度:O(n^2)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; i++)&#123; <span class="comment">//进行n-1趟排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>-i; j++)&#123; <span class="comment">//这里之所以是5-i，是因为到后面只需要比较前面的元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] =  temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新开了个目录，因为发现其他的目录似乎不太合适。就当记录自己平时的一些笔记好了，现在看晴神宝典，据说是PAT神级书，希望我甲级考高分啦！下面就是简单的记录一些自己不太知道，或者容易忘记的东西，以后也都是这样。下面记的是一些基础知识。&lt;/p&gt;
&lt;h1 id=&quot;变量型&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="笔记" scheme="https://github.com/DesmonDay/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="c++" scheme="https://github.com/DesmonDay/tags/c/"/>
    
  </entry>
  
</feed>
