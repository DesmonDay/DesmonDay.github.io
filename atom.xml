<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DesmonDay&#39;s Blog</title>
  
  <subtitle>一只小辣鸡的自我拯救之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DesmonDay/"/>
  <updated>2020-04-16T03:34:56.793Z</updated>
  <id>https://github.com/DesmonDay/</id>
  
  <author>
    <name>DesmonDay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hive学习</title>
    <link href="https://github.com/DesmonDay/2020/04/16/Hive%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/DesmonDay/2020/04/16/Hive学习/</id>
    <published>2020-04-16T03:34:56.000Z</published>
    <updated>2020-04-16T03:34:56.793Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/DesmonDay/2020/03/30/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://github.com/DesmonDay/2020/03/30/回溯/</id>
    <published>2020-03-30T09:57:41.347Z</published>
    <updated>2020-03-30T09:57:41.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="# 回溯"></a># 回溯</h1><p>解决一个回溯问题，实际上就是一个决策树的遍历过程。我们需要解决三个问题：</p><ol><li>路径：也就是已经做出的选择。</li><li>选择列表：也就是当前可以做的选择。</li><li>结束条件：也就是到达决策树底层，无法再做选择的条件。</li></ol><p>回溯算法的框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径，选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>其核心是for循环里面的递归，在递归调用之前[做选择]，在递归调用之后[撤销选择]。</p><h2 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h2><p>大致的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    backtrack(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            backtrack(board, i, j);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1到9做选择，全部试一遍</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">9</span>, n = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 当j到达超过最后一个索引时，转为增加i开始穷举下一行</span></span><br><span class="line">    <span class="comment">// 并且在穷举之前添加一个判断，跳过不满足条件的数字</span></span><br><span class="line">    <span class="keyword">if</span> (c == n) &#123;</span><br><span class="line">        backtrack(board, r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == m) &#123; <span class="comment">// 找到一个可行解，触发base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 就是对每个位置进行穷举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果该位置是预设的数字，则不用操作</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'1'</span>; ch &lt;= <span class="string">'9'</span>; ch++) &#123;</span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                <span class="comment">// 如果遇到不合法的数字，就跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!isValid(board, i, j, ch)) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                board[i][j] = ch;</span><br><span class="line">                backtrack(board, i, j + <span class="number">1</span>);</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 穷举完1~9，依然没有找到可行解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断行是否存在重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[r][i] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断列是否存在重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][c] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断3x3方框是否存在重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[(r/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>][(c/<span class="number">3</span>)*<span class="number">3</span> + i%<span class="number">3</span>] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求子集问题"><a href="#求子集问题" class="headerlink" title="求子集问题"></a>求子集问题</h2><p>方法一，递归结构：</p><p>这个解法的时间复杂度很高，为O(N*2^N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">// base case 返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    <span class="comment">// 先递归算法前面元素的所有子集</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = subsets(nums);</span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二，回溯算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span>&#123;</span><br><span class="line">res.push_back(track);</span><br><span class="line">    <span class="comment">// 注意i从start开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.push_back(nums[i]);</span><br><span class="line">        backtrack(nums, start + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对res的更新是一个前序遍历，也就是说，res是树上的所有节点。</p><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><p>输入两个数字n, k，算法输出[1..n]中k个数字的所有组合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回溯&quot;&gt;&lt;a href=&quot;#回溯&quot; class=&quot;headerlink&quot; title=&quot;# 回溯&quot;&gt;&lt;/a&gt;# 回溯&lt;/h1&gt;&lt;p&gt;解决一个回溯问题，实际上就是一个决策树的遍历过程。我们需要解决三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径：也就是已经做出的选择。&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++知识</title>
    <link href="https://github.com/DesmonDay/2020/03/17/C-%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/DesmonDay/2020/03/17/C-知识/</id>
    <published>2020-03-17T15:21:59.000Z</published>
    <updated>2020-03-17T17:01:16.445Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>vector的reserve和resize</p><p>vector的reserve增加了vector的capacity，但是size没有改变；resize改变了vector的capacity，同时也增加了它的size。原因：reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新对象之前，不能引用容器内元素，加入新元素要调用push_back()或insert()函数；resize是改变容器大小，且在创建对象，因此调用这个函数后就可以引用容器内的对象，所以加入新的元素时可以用operator[]操作符，或者迭代器来引用该元素。</p></li><li><p>C++的虚函数和纯虚函数</p><p>虚函数是允许被派生类重新定义的成员函数。声明方式：virtual returntype func(parameter); 定义一个函数为虚函数，是为了实现动态绑定，允许用基类的指针来调用子类的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B::foo() is called"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A *a = <span class="keyword">new</span> B();  </span><br><span class="line">    a-&gt;foo();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子，可以知道，它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。</p><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”。纯虚函数最显著的特征是：它们<strong>必须在继承类中重新声明函数</strong>（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。<strong>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口</strong>。</p></li><li><p>基类的虚析构函数</p><p>为了防止内存泄漏。想去借助父类指针销毁子类对象的时候，不能销毁子类对象。假如没有虚析构函数，释放一个由基类指针指向的派生类对象时，不会触发动态绑定，则只会调用基类的析构函数，不会调用派生类的。派生类中申请的空间则会得不到释放而导致内存泄漏。</p></li><li><p>const和static</p><p>初始化：通常在类外申明static成员，但是static const的整型(bool, char, int, long)可以在类中声明并初始化，static const的其他类型必须在类外初始化（包括整型数组）。</p><p>用法：</p><ul><li><p>static作用：</p><ol><li>局部变量：在局部变量前加关键字static，局部变量就被定义为一个局部静态变量。在内存中的位置是静态存储区，未经初始化的会被程序自动初始化为0。作用域为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</li><li>全局变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。在内存中的位置是静态存储区，未经初始化的会被程序自动初始化为0。作用域是在声明他的文件之外是不可见的。</li></ol><p>注：当static用来修饰局部变量的时候，它就<strong>改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</strong></p><p>​      当static修饰全局变量，<strong>并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量</strong>，好处如下：（1）不会被其他文件所访问，修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。</p></li></ul></li><li><p>extern关键字：<a href="https://www.cnblogs.com/banmei-brandy/p/11338314.html" target="_blank" rel="noopener">https://www.cnblogs.com/banmei-brandy/p/11338314.html</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;vector的reserve和resize&lt;/p&gt;
&lt;p&gt;vector的reserve增加了vector的capacity，但是size没有改变；resize改变了vector的capacity，同时也增加了它的size。原因：reserve是容器预留空间
      
    
    </summary>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python知识摘要</title>
    <link href="https://github.com/DesmonDay/2020/03/10/python%E7%9F%A5%E8%AF%86%E6%91%98%E8%A6%81/"/>
    <id>https://github.com/DesmonDay/2020/03/10/python知识摘要/</id>
    <published>2020-03-10T09:35:53.000Z</published>
    <updated>2020-04-08T15:54:28.102Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>以下划线开头的标识符是有特殊意义的。以单下划线开头<code>_foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <strong>from xxx import *</strong> 而导入。以双下划线开头的 <code>__foo</code>代表类的私有成员，以双下划线开头和结尾的<code>__foo__</code>代表 Python 里特殊方法专用的标识，如 <strong>__init__()</strong> 代表类的构造函数。</p></li><li><p>list是一种有序的集合，可以随时添加和删除其中的元素。要删除指定位置的元素，用pop(i)，其中i是索引位置。</p></li><li><p>tuple也是有序列表，但一旦初始化就不能修改。初始化：t = (1,2) 另外，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义。</p></li><li><p>python内置了字典dict，在其他语言中称为map，使用键-值（key-value）存储，具有极快的查找速度。要删除一个key，使用pop(key)。</p></li><li><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。add(key), remove(key)。<strong>可以使用 {  }  或 set( ) 创建集合，但是创建一个空集合时，只能使用set( )</strong>。</p></li><li><p>str是不可变对象，而list是可变对象。对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样就保证了不可变对象本身永远是不可变的。</p></li><li><p>函数名其实是指向一个函数对象的引用，完全把函数名赋给一个变量，相当于给这个函数起了一个别名。</p></li><li><p>数据类型检查可以用内置函数isinstance()实现。</p></li><li><p>写函数时定义默认参数，需要牢记：<strong>默认参数必须指向不变对象</strong>。必选参数在前，默认参数在后。另外，python函数还可以定义<strong>可变参数</strong>，可变参数就是传入的参数个数是可变的。可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span> <span class="comment"># 传入的numbers可以是list, tuple</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关键字参数</strong>：关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装成一个<strong>dict</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>,name,<span class="string">'age:'</span>,age,<span class="string">'other:'</span>,kw)</span><br><span class="line">person(<span class="string">'Michael'</span>,<span class="number">30</span>) <span class="comment"># 输出name: Michael age: 30 other: &#123;&#125;</span></span><br><span class="line">person(<span class="string">'Bob'</span>,<span class="number">35</span>,city=<span class="string">'Beijing'</span>) <span class="comment"># name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;</span></span><br></pre></td></tr></table></figure><p>关键字参数的作用：<strong>扩展函数的功能。</strong>比如我们在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项。利用关键字参数来定义这个函数，就能满足注册的需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;<span class="string">'city'</span>:<span class="string">'Beijing'</span>, <span class="string">'job'</span>:<span class="string">'Engineer'</span>&#125;</span><br><span class="line">person(<span class="string">'Jack'</span>,<span class="number">24</span>,**extra) <span class="comment">#name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125;</span></span><br></pre></td></tr></table></figure><p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数。</p></li><li><p>命名关键字参数：如果要限制关键字参数的名字，可以用命名关键字参数，比如只接受city和job作为关键字参数的定义函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    <span class="comment"># 即需要一个特殊的</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>命名关键字参数必须传入参数名，否则调用将报错。同时，可以有缺省值，从而简化调用。</p></li><li><p><strong>参数定义的顺序必须是</strong>：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用，无论它的参数是如何定义的。（因此，<code>*args</code>是可变参数，接受的是一个tuple；<code>**kw</code>是关键字参数，接受的是一个dict）</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p></li><li><p>列表生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>注意，我们不可以在最后的if加else。这是因为跟在for后面的if是一个筛选条件，不能带else。而如果我们把if写在for前面，则必须加else，否则报错。因此，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exp1 <span class="keyword">if</span> condition <span class="keyword">else</span> exp2 <span class="keyword">for</span> x <span class="keyword">in</span> data]</span><br></pre></td></tr></table></figure></li><li><p>for循环遍历dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k, <span class="string">'='</span>, v)</span><br></pre></td></tr></table></figure></li><li><p><strong>生成器</strong>：通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p><strong>方法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) <span class="comment"># 和列表生成式比较，改成了括号</span></span><br></pre></td></tr></table></figure><p>可以通过<code>next()</code>函数获得generator的下一个返回值。但我们通常用for循环来迭代它。</p><p><strong>方法二：</strong></p><p>另外，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现，则可以用函数来实现。这是定义generator的另一种方法：如果一个函数定义中<strong>包含<code>yield</code>关键字</strong>，则其不是普通函数，而是generator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(<span class="string">'g:'</span>, x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Generator return value'</span>, e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>要理解generator的工作原理，它是在<code>for</code>循环的过程中不断计算出下一个元素，并在适当的条件结束<code>for</code>循环。对于函数改成的generator来说，遇到<code>return</code>语句或者执行到函数体最后一行语句，就是结束generator的指令，<code>for</code>循环随之结束。</p></li><li><p>迭代器：<strong>可以直接作用于for循环的对象统称为可迭代对象（Iterable）</strong>。可以使用isinstance()判断一个对象是否是Iterable对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">print(isinstance([], Iterable)) <span class="comment"># True</span></span><br><span class="line">print(isinstance([], Iterator)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p><strong>可以被next()函数调用并不断返回下一个值的对象称为迭代器(Iterator)</strong>。把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(iter([]), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p><code>Iterator</code>可以表示一个无限大的数据流，例如全体自然数。但是使用list是永远不可能存储完的。</p></li><li><p>函数式编程：其特点是允许把函数本身作为参数传入另一个函数，还允许返回一个函数。然而，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。python对函数式编程提供部分支持，由于python允许使用变量，因此python不是纯函数式编程。</p></li><li><p><strong>变量可以指向函数</strong>：如我们有绝对值函数abs，而我们可以用f = abs；<strong>函数名也是变量</strong>。</p></li><li><p>传入函数：<strong>一个函数可以接受另一个函数作为参数</strong>，称之为高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">add(<span class="number">-5</span>, <span class="number">4</span>, abs) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure></li><li><p><strong>map()函数</strong>：接收两个参数，一个是函数，一个是Iterable。map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = map(f, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># r为Iterator</span></span><br><span class="line">list(r) <span class="comment"># [1,4,9,16,25]</span></span><br></pre></td></tr></table></figure><p>由于r是一个<code>Iterator</code>，<code>Iterator</code>是一个惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p></li><li><p><strong>reduce()函数</strong>：reduce把一个函数作用在一个序列<code>[x1,x2,x3,...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做<strong>累积计算</strong>，其效果就是：reduce(f,[x1,x2,x3,x4]) = f(f(f(x1,x2),x3),x4)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">print(reduce(add, [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])) <span class="comment"># 输出13579</span></span><br></pre></td></tr></table></figure></li><li><p><strong>filter()函数</strong>：用于过滤序列（<strong>筛选函数</strong>）。和<code>map()</code>类似，filter()也接受一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</span><br><span class="line"><span class="comment"># 结果：[1,5,9,15]</span></span><br></pre></td></tr></table></figure></li><li><p>sorted()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="number">36</span>,<span class="number">5</span>,<span class="number">-12</span>,<span class="number">9</span>,<span class="number">-21</span>], key=abs)</span><br><span class="line"><span class="comment"># 还有 reverse=True（降序）</span></span><br><span class="line"><span class="comment"># 输出[5, 9, -12, -21, 36]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>lambda</strong>匿名函数：为了减少单行函数的定义而存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line"><span class="comment"># 输出 [1,4,9,16]</span></span><br></pre></td></tr></table></figure></li><li><p>装饰器(decorator)：一个返回函数的高阶函数。如果我们想在函数调用之前自动打印日志，但又不希望修改函数的定义，这种<strong>在代码运行期间动态增加功能的方式</strong>，称为装饰器。（比如经常使用的@timeit）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span> <span class="comment"># 接受任意参数的调用</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2020-03-10'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-10</span></span><br></pre></td></tr></table></figure><p>其中，把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：now = log(now)</p></li></ol><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数。</p><ol><li><p>python内部使用<strong>引用计数</strong>，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。</p><p>引用计算加1的情况：</p><ul><li>对象被创建：x = 4</li><li>另外的别人创建：y =  x</li><li>被作为参数传递给函数：foo(x)</li><li>作为容器对象的一个元素：a = [1,x’33’]</li></ul><p>引用计算减少情况：</p><ul><li>一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。</li><li>对象的别名被显式的销毁：del x ；或者del y</li><li>对象的一个别名被赋值给其他对象：x=789</li><li>对象从一个窗口对象中移除：myList.remove(x)</li><li>窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。</li></ul></li><li><p>垃圾回收(import gc)</p><ul><li>当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些<strong>引用计数为0</strong>的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了.</li><li>垃圾回收机制还有一个<strong>循环垃圾回收器</strong>, 确保释放循环引用对象(a引用b, b引用a, 导致其引用计数永远不为0)。</li></ul><p>python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放。由于这些内存的申请并不是为了创建对象，所以并没有对象一级的内存池机制。这就意味着python在运行期间会<strong>大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换</strong>，这将严重影响python的执行效率。为了加速python的执行效率，<strong>python引入了一个内存池机制，用于管理对小块内存的申请和释放</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.get_threshold() <span class="comment"># gc模块中查看阈值的方法</span></span><br><span class="line">gc.collect()       <span class="comment"># 手动启动垃圾回收</span></span><br></pre></td></tr></table></figure><p>如果存在循环引用，则创建数量&gt;释放数量。当创建数量与释放数量的差值达到规定的阈值的时候，则有分代回收机制：python将所有的对象分为0,1,2三代：所有的新建对象是0代；当某一代对象经过垃圾回收后依然存活，则被归入下一代对象。</p></li><li><p>内存池机制：python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。<strong>Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc</strong>。另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。（总结：<strong>大对象使用malloc进行分配，小对象使用内存池分配</strong>）</p></li><li><p>模块：</p><p><img src="C:\Users\90866\AppData\Roaming\Typora\typora-user-images\1583853580787.png" alt="1583853580787"></p><p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p></li><li><p>作用域：在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p><ul><li>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</li><li>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</li><li>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；以单下划线开头<code>_foo</code>的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <strong>from xxx import *</strong> 而导入。以双下划线开头的 <code>__foo</code>代表类的私有成员。</li></ul></li><li><p>面向对象的设计思想是抽象出Class，根据Class创建Instance。面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。<strong>封装、继承和多态</strong>是面向对象的三大特点。</p><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p></li><li><p>在类定义中，如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。在python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p></li><li><p>继承的好处：子类获得了父类的全部功能。当然，我们也可以对子类增加一些方法。当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p></li><li></li></ol><p>代码小记：</p><ol><li><p>一行完成变量值交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure></li><li><p>按key或value对字典进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按key排序</span></span><br><span class="line">sorted(mydict.keys(), re0verse=<span class="keyword">True</span>) <span class="comment"># 降序</span></span><br><span class="line"><span class="comment"># 按value排序</span></span><br><span class="line">sorted(mydict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下划线开头的标识符是有特殊意义的。以单下划线开头&lt;code&gt;_foo&lt;/code&gt;的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 &lt;strong&gt;from xxx import *&lt;/strong&gt; 而导入。以双下划线开头的 &lt;code&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 42*. 接雨水</title>
    <link href="https://github.com/DesmonDay/2020/03/09/Leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>https://github.com/DesmonDay/2020/03/09/Leetcode-42-接雨水/</id>
    <published>2020-03-09T15:47:27.000Z</published>
    <updated>2020-03-09T16:57:07.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对我来说，果然还是很困难啊。。。因为一开始做就已经没有思路了，但是其实再多思考思考，还是可以想出暴力解法的。当然，暴力解法感觉也很难想到。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>直接按问题描述进行。对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。</p><p><strong>算法</strong></p><ul><li>初始化 ans=0</li><li>从左向右扫描数组：<ul><li>初始化 max_left=0和max_right=0</li><li>从当前元素向左扫描并更新：<ul><li>max_left = max(max_left, height[j])</li></ul></li><li>从当前元素向右扫描并更新：<ul><li>max_right = max(max_right, height[j])</li></ul></li><li>将min(max_left, max_right)-height[i]累加到ans</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = height.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            leftMax = max(leftMax, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">            rightMax = max(rightMax, height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += min(leftMax, rightMax) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时，上面的方法其实每次都要重复计算最大值。其实我们可以实现将左右两侧的最大值存储起来。再计算，这样的时间复杂度为O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = height.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftMax(len), rightMax(len);</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        leftMax[i] = max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        rightMax[i] = max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        ans += min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 23. 合并K个排序链表</title>
    <link href="https://github.com/DesmonDay/2020/03/09/Leetcode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://github.com/DesmonDay/2020/03/09/Leetcode-23-合并K个排序链表/</id>
    <published>2020-03-09T14:58:49.000Z</published>
    <updated>2020-03-09T15:15:31.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题，一开始我是想按照归并排序（看到了合并两个字的第一反应）来做。结果，由于这个是K个链表的排序，要用归并排序很麻烦。（感觉需要一环套一环）</p><p>因此，直接参考了别人的思路来写。其实，最暴力的方法就是把所有的数放到一个数组里，然后排序，最坏时间复杂度为O(NlogN)。而由于k个链表是有序的，实际上我们只需要维护k个指针，从k个链表的头向尾移动。每次选取k个链表的表头里最小的一个加入有序链表里。在C++中，我们使用priority_queue来实现堆。一般默认为最大堆（less\<int>），最小堆为(greater\<int>)。</int></int></p><p>由于此题是要对指针进行排序，因此需要重载运算符。我们使用struct结构体来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; heapk; <span class="comment">// 最小堆，输出堆中的最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : lists)&#123;</span><br><span class="line">        heapk.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (!heapk.empty())&#123;</span><br><span class="line">        ListNode *temp = heapk.top();</span><br><span class="line">        heapk.pop();</span><br><span class="line">        cur-&gt;next = temp;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next) heapk.push(temp-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;合并 &lt;em&gt;k&lt;/em&gt; 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/stron
      
    
    </summary>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>刷题笔记</title>
    <link href="https://github.com/DesmonDay/2020/03/06/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/DesmonDay/2020/03/06/刷题笔记/</id>
    <published>2020-03-06T03:35:41.000Z</published>
    <updated>2020-04-09T05:44:50.510Z</updated>
    
    <content type="html"><![CDATA[<p>从现在开始，按照leetcode专题刷题。此博文持续更新。</p><p>注意点：</p><ol><li>写完函数，该return的记得return!</li><li>不要丢三落四！！！<ol><li>树，不仅要会递归写法，同·时也要会迭代写法。</li></ol></li></ol><h1 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h1><h2 id="leetcode-146-LRU缓存机制"><a href="#leetcode-146-LRU缓存机制" class="headerlink" title="leetcode 146. LRU缓存机制"></a>leetcode 146. LRU缓存机制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 千万记住，任何改动，都要看看hashmap和list用不用更新</span></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        capacity_ = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hashmap.count(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = hashmap[key]-&gt;second;</span><br><span class="line">            lr.erase(hashmap[key]);</span><br><span class="line">            lr.push_front(&#123;key, value&#125;);</span><br><span class="line">            hashmap[key] = lr.begin();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashmap.count(key))&#123;</span><br><span class="line">            <span class="comment">// hashmap.erase(key);</span></span><br><span class="line">            lr.erase(hashmap[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lr.size() &gt;= capacity_)&#123;</span><br><span class="line">            hashmap.erase(lr.back().first);</span><br><span class="line">            lr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        lr.push_front(&#123;key, value&#125;);</span><br><span class="line">        hashmap[key] = lr.begin(); <span class="comment">// 更新或添加</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> capacity_;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; lr;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator&gt; hashmap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="递归-回溯"><a href="#递归-回溯" class="headerlink" title="递归+回溯"></a>递归+回溯</h1><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><blockquote><p>有三个柱子，分别为 from、buffer、to。需要将 from 上的圆盘全部移动到 to 上，并且要保证小圆盘始终在大圆盘上。</p></blockquote><p>经典的递归问题，分为三步求解：</p><ol><li>将n-1个圆盘从from -&gt; buffer</li><li>将1个圆盘从from -&gt; to</li><li>将n-1个圆盘从buffer-&gt;to</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> buffer, <span class="keyword">char</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"from"</span> + from + <span class="string">"to"</span> + to &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    move(n - <span class="number">1</span>, from, to, buffer);</span><br><span class="line">    move(<span class="number">1</span>, from, buffer, to);</span><br><span class="line">    move(n - <span class="number">1</span>, buffer, from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-46-全排列"><a href="#leetcode-46-全排列" class="headerlink" title="leetcode 46*. 全排列"></a>leetcode 46*. 全排列</h2><p>老是记不住！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    PermutationHelper(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">        res.push_back(nums);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= nums.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != begin &amp;&amp; nums[i] == nums[begin])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[begin]);</span><br><span class="line">        PermutationHelper(nums, begin + <span class="number">1</span>, res);</span><br><span class="line">        swap(nums[i], nums[begin]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-17-电话号码的字母组合"><a href="#leetcode-17-电话号码的字母组合" class="headerlink" title="leetcode 17. 电话号码的字母组合"></a>leetcode 17. 电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom:50%;"></p><p>输入：“23”</p><p>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>思想：这道题和全排列有点像，也是用回溯。多记！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; table&#123;</span><br><span class="line">        &#123;<span class="string">'0'</span>, <span class="string">" "</span>&#125;, &#123;<span class="string">'1'</span>,<span class="string">"*"</span>&#125;, &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="string">""</span>) <span class="keyword">return</span> res;</span><br><span class="line">    helper(res, digits, <span class="string">""</span>, table, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> digits, <span class="built_in">string</span> str, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.size() == digits.size())&#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> temp = m[digits[k]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> x : temp)&#123;</span><br><span class="line">        str += x;</span><br><span class="line">        helper(res, digits, str, m, k+<span class="number">1</span>);</span><br><span class="line">        str.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-22-括号生成"><a href="#leetcode-22-括号生成" class="headerlink" title="leetcode 22. 括号生成"></a>leetcode 22. 括号生成</h2><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>例如，给出 <em>n</em> = 3，生成结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>貌似懂了一点点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    generate(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> str, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == n &amp;&amp; r == n)&#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; n || r &gt; n || r &gt; l) <span class="keyword">return</span>;</span><br><span class="line">    generate(res, str + <span class="string">'('</span>, l + <span class="number">1</span>, r, n);</span><br><span class="line">    generate(res, str + <span class="string">')'</span>, l, r + <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="leetcode-19-删除链表的倒数第N个节点"><a href="#leetcode-19-删除链表的倒数第N个节点" class="headerlink" title="leetcode 19. 删除链表的倒数第N个节点"></a>leetcode 19. 删除链表的倒数第N个节点</h2><p>双指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* fast = dummy, *slow = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *deleteNode = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = deleteNode-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> deleteNode;</span><br><span class="line">    ListNode *newhead = dummy-&gt;next; <span class="comment">// 有的情况下会把head删掉，所以要设置newhead！！！</span></span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-141-环形链表"><a href="#leetcode-141-环形链表" class="headerlink" title="leetcode 141. 环形链表"></a>leetcode 141. 环形链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* slow = head, *fast = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-反转链表"><a href="#leetcode-反转链表" class="headerlink" title="leetcode 反转链表"></a>leetcode 反转链表</h2><p>有多种出题的形式，第一种，将整个链表进行反转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* last = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种，反转链表的前n个元素(n &lt;= 链表长度)，需要记录<strong>后驱节点</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode *successor = <span class="literal">NULL</span>; <span class="comment">// 后驱结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 记录第n + 1个结点</span></span><br><span class="line">        successor = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *last = reverseN(head-&gt;next, n - <span class="number">1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 让反转之后的head节点和后面的节点连起来</span></span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种，反转链表的一部分：给一个索引区间<code>[m,n]</code>（索引从1开始），仅仅反转区间中的链表元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果m = 1，相当于反转前n个元素</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    head-&gt;next = reverseBetween(head-&gt;next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="leetcode-225-用队列实现栈"><a href="#leetcode-225-用队列实现栈" class="headerlink" title="leetcode 225. 用队列实现栈"></a>leetcode 225. 用队列实现栈</h2><blockquote><p>只需要一个队列来模拟栈即可。要删除栈顶元素，可以用如下操作，即循环pop和push。获取top元素同理，但记得末尾要添加为temp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">&gt;        q.push(q.front());</span><br><span class="line">&gt;        q.pop();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">int</span> temp = q.front();</span><br><span class="line">&gt; q.pop();</span><br><span class="line">&gt; <span class="keyword">return</span> temp;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="leetcode-1-两数之和"><a href="#leetcode-1-两数之和" class="headerlink" title="leetcode 1. 两数之和"></a>leetcode 1. 两数之和</h2><blockquote><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p></blockquote><p>O(n)的做法，利用一个map来存储对应的值和下标，贴代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (hashmap.count(tmp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res.push_back(i);</span><br><span class="line">        res.push_back(hashmap[tmp]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hashmap[nums[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-3-找无重复字符的最长子串"><a href="#leetcode-3-找无重复字符的最长子串" class="headerlink" title="leetcode 3*. 找无重复字符的最长子串"></a>leetcode 3*. 找无重复字符的最长子串</h2><p>不会做，这里要运用<strong>滑动窗口</strong>求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (M.count(s[j]))&#123;</span><br><span class="line">        i = max(M[s[j]], i); </span><br><span class="line"><span class="comment">// i是截至j，以j为最后一个元素的最长不重复子串的起始位置</span></span><br><span class="line"><span class="comment">// 即索引范围是[i,j]的子串是以索引j为最后一个元素的最长子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    maxlen = max(maxlen, j - i + <span class="number">1</span>);</span><br><span class="line">    M[s[j]] = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-11-盛最多水的容器"><a href="#leetcode-11-盛最多水的容器" class="headerlink" title="leetcode 11. 盛最多水的容器"></a>leetcode 11. 盛最多水的容器</h2><p>思路只差一点就做对了，加油啊！！有时候不要想得太多，先按照一开始的思路写写看。思想有点类似动态规划。</p><blockquote><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:67%;"></p></blockquote><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height.size() == <span class="number">2</span>) <span class="keyword">return</span> min(height[<span class="number">0</span>], height[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxnum = <span class="number">0</span>, temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; height.size() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        temp = (j - i) * min(height[i], height[j]);</span><br><span class="line">        maxnum = max(maxnum, temp);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; height[j]) j--;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-15-三数之和"><a href="#leetcode-15-三数之和" class="headerlink" title="leetcode 15*. 三数之和"></a>leetcode 15*. 三数之和</h2><blockquote><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p></blockquote><p>双指针：类似于滑动窗口题，需要先进行排序，再利用滑动窗口求解。但注意，由于不允许重复，因此在左右指针更新的时候，需要特别留意！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// 同样是滑动窗口题，需要排序后才可以</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 已排序，但第一个数字大于0，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 遇到重复数字，跳过</span></span><br><span class="line">            left = i + <span class="number">1</span>; </span><br><span class="line">            right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 如果两个while不写，会导致重复结果</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                        left = left + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                        right = right - <span class="number">1</span>;</span><br><span class="line">                    left += <span class="number">1</span>; <span class="comment">// 这里还要继续更新，不然无法退出while</span></span><br><span class="line">                    right -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode-16-最接近的三数之和"><a href="#leetcode-16-最接近的三数之和" class="headerlink" title="leetcode 16. 最接近的三数之和"></a>leetcode 16. 最接近的三数之和</h2><p>方法与leetcode 15基本相同，同样是排序+滑动窗口。</p><h2 id="leetcode-18-四数之和"><a href="#leetcode-18-四数之和" class="headerlink" title="leetcode 18. 四数之和"></a>leetcode 18. 四数之和</h2><p>方法参考leetcode 15. 先进行排序，随后，我们首先将题目转化为三数之和，计算出新的target，从而可以求解。注意，仍然需要避免重复元素！！在每个循环初始化的时候，都要想清楚为什么。</p><p>还是不太会，这道题。。。希望不会出吧！有时间再做一次。</p><h2 id="leetcode-31-下一个排列"><a href="#leetcode-31-下一个排列" class="headerlink" title="leetcode 31*. 下一个排列"></a>leetcode 31*. 下一个排列</h2><blockquote><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成<strong>字典序</strong>中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote><p>参考思路：</p><ol><li>判断按照字典序有木有下一个，如果完全降序(包括等号)就没有下一个，则要找第一个</li><li>如何判断有没有下一个呢？只要存在a[i-1]&lt;a[i]的升序结构，则有下一个（我们要从右往左找）</li><li>当发现a[i-1]&lt;a[i]的结构，则从[i, ]中找到<strong>最接近a[i-1]又大于a[i-1]</strong>的数字，由于降序，从右往左遍历即可得到k</li><li>交换a[i-1]和k，再对[i, ]进行排序。排序只需要首尾不停交换即可，因为已经是降序。</li></ol><p>参考例子：比如[0,5,4,3,2,1]，下一个是[1,0,2,3,4,5]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁版答案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">2</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) i--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] &lt;= nums[i]) j--;</span><br><span class="line">        swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="leetcode-5-最长回文子串"><a href="#leetcode-5-最长回文子串" class="headerlink" title="leetcode 5*. 最长回文子串"></a>leetcode 5*. 最长回文子串</h2><p>这道题，百看不会，所以还是要多做很多很多次。</p><blockquote><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p></blockquote><p>我记的是O(n^2)的做法，即<strong>遍历对称轴</strong>来找回文串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 回文子串为奇数的情况, s[i]为中心轴</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// while循环</span></span><br><span class="line">            <span class="keyword">while</span> (i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i - j] == s[i + j])&#123;</span><br><span class="line">                <span class="keyword">if</span> (maxlen &lt; <span class="number">1</span> + <span class="number">2</span> * j)&#123;</span><br><span class="line">                    maxlen = <span class="number">1</span> + <span class="number">2</span> * j;</span><br><span class="line">                    ans = s.substr(i - j, maxlen);</span><br><span class="line">                &#125;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文子串为偶数的情况，s[i],s[i+1]为中心轴</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i - j &gt;= <span class="number">0</span> &amp;&amp; i + j + <span class="number">1</span> &lt; s.size() &amp;&amp; s[i - j] == s[i + j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (maxlen &lt; <span class="number">2</span> + <span class="number">2</span> * j)&#123;</span><br><span class="line">                    maxlen = <span class="number">2</span> + <span class="number">2</span> * j;</span><br><span class="line">                    ans = s.substr(i - j, maxlen);</span><br><span class="line">                &#125;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有更好的思路，马拉车算法O(N)：<a href="https://blog.csdn.net/csdnnews/article/details/82920678" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/82920678</a></p><ol><li>先对字符串进行预处理，两个字符之间加上特殊符号#；</li><li>然后遍历整个字符串，用一个数组来记录以该字符为中心的回文长度，为了方便计算右边界，我在数组中记录长度的一半（向下取整）；</li><li>每一次遍历的时候，如果该字符在已知回文串最右边界的覆盖下，那么就计算其相对最右边界回文串中心对称的位置，得出已知回文串的长度；</li><li>判断该长度和右边界，如果达到了右边界，那么需要进行中心扩展探索。当然，如果第3步该字符没有在最右边界的“羽翼”下，则直接进行中心扩展探索。进行中心扩展探索的时候，同时又更新右边界；</li><li>最后得到最长回文之后，去掉其中的特殊符号即可。</li></ol><h2 id="leetcode-6-Z字形变换"><a href="#leetcode-6-Z字形变换" class="headerlink" title="leetcode 6*. Z字形变换"></a>leetcode 6*. Z字形变换</h2><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><p>L    C      I     R<br>E T O E S  I   I   G<br>E    D     H    N</p></blockquote><p>巧妙的思想，用一维数组就可以得到结果，图示如下：</p><p><img src="https://pic.leetcode-cn.com/ebbed8592bd11014e81affb8af6df3e713d88ae0e8003f4f989459d7694e475c-Picture8.png" alt="img" style="zoom: 25%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res[numRows];</span><br><span class="line">    <span class="keyword">if</span> (s.empty() || numRows &lt; <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">-1</span>; <span class="comment">// 利用flag来改变存储方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">        res[i] += s[j];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>)</span><br><span class="line">            flag = - flag;</span><br><span class="line">        i += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> r : res)&#123;</span><br><span class="line">        ans += r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-8-字符串转换整数-atoi"><a href="#leetcode-8-字符串转换整数-atoi" class="headerlink" title="leetcode 8. 字符串转换整数(atoi)"></a>leetcode 8. 字符串转换整数(atoi)</h2><blockquote><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42</p><p>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><p>这个问题其实没有过多的技巧，考察的是<strong>细心和耐心</strong>，并且需要不断地调试。在这里我简单罗列几个要点。</p><p>Java 、Python 和 C++ 字符串的设计都是不可变的，即使用 trim() 会产生新的变量，因此我们尽量不使用库函数，使用一个变量 index 去做线性遍历，这样遍历完成以后就得到转换以后的数值。</p><ul><li>根据示例 1，需要去掉前导空格；</li><li>根据示例 2，需要判断第 1 个字符为 + 和 - 的情况，因此，可以设计一个变量 sign，初始化的时候为 1，如果遇到 - ，将 sign 修正为 -1；</li><li>判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 0 &lt;= c &lt;= ‘9’；</li><li>根据示例 3 和示例 4 ，在遇到第 1 个不是数字的字符的情况下，就得退出循环；</li><li>根据示例 5，如果转换以后的数字超过了 int 类型的范围，需要截取。这里需要将结果 res 变量设计为 long 类型，注意：由于输入的字符串转换以后也有可能超过 long 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；</li><li>因为涉及下标访问，因此全程需要考虑数组下标是否越界的情况。<br>特别注意：由于题目中说“环境只能保存 32 位整数”，因此这里在每一轮循环之前先要检查乘以 1010 以后是否溢出，具体细节请见编码.</li></ul><p>这里贴一下判断函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; INT_MAX % <span class="number">10</span>))&#123;</span><br><span class="line">    <span class="comment">// INT_MAX % 10 = 7</span></span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (currChar - <span class="string">'0'</span>) &gt; - (INT_MIN % <span class="number">10</span>)))&#123;</span><br><span class="line">    <span class="comment">//  -(INT_MIN % 10) = 8</span></span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-10-正则表达式匹配（困难）"><a href="#leetcode-10-正则表达式匹配（困难）" class="headerlink" title="leetcode 10*. 正则表达式匹配（困难）"></a>leetcode 10*. 正则表达式匹配（困难）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">".*"</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">    <span class="keyword">auto</span> first_match = !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-12-整数转罗马数字"><a href="#leetcode-12-整数转罗马数字" class="headerlink" title="leetcode 12. 整数转罗马数字"></a>leetcode 12. 整数转罗马数字</h2><p>使用<strong>两个数组</strong>，存储对应的string和代表的数字。虽然再对num进行转换即可。</p><h2 id="leetcode-13-罗马数字转整数"><a href="#leetcode-13-罗马数字转整数" class="headerlink" title="leetcode 13. 罗马数字转整数"></a>leetcode 13. 罗马数字转整数</h2><p>使用<char,int>字典存储罗马数字对应的数字。遍历字符串，<strong>如果当前的字符比右边的字符所代表的数字小，则减去当前字符所代表的数字；否则直接加上</strong>。也就是说，一个字符一个字符的处理，而不要想着按照string的方式来找准数字。</char,int></p><h2 id="leetcode-14-最长公共前缀"><a href="#leetcode-14-最长公共前缀" class="headerlink" title="leetcode 14. 最长公共前缀"></a>leetcode 14. 最长公共前缀</h2><p>我的做法：先求出所有字符串中的最短长度，再遍历字符串来判断。时间复杂度相当于：字符串总数 * 最短字符串长度。</p><p>用python的话很简单诶，复杂度只有O(N)，求出最短的和最长的两个字符串，再比较他们的最长公共前缀即可。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>我的弱点之一。</p><h2 id="leetcode-10-正则表达式匹配"><a href="#leetcode-10-正则表达式匹配" class="headerlink" title="leetcode 10*. 正则表达式匹配"></a>leetcode 10*. 正则表达式匹配</h2><blockquote><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;.&apos; 匹配任意单个字符</span><br><span class="line">&gt; &apos;*&apos; 匹配零个或多个前面的那一个元素</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">".*"</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">    <span class="keyword">auto</span> first_match = !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p)); <span class="comment">// 前者是直接跳过，不匹配；后者是匹配一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first_match &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-53-最大子序和"><a href="#leetcode-53-最大子序和" class="headerlink" title="leetcode 53. 最大子序和"></a>leetcode 53. 最大子序和</h2><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p>首先，来理解最标准的动态规划做法。</p><p>初始化一个dp数组，用来存储当前数组位置所对应的最大和。其中，初始状态为dp[0] = nums[0]。状态转移方程为：dp[i] = max(0, dp[i-1]) + nums[i]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size());</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// dp[i] = max(dp[i - 1], 0) + nums[i] 状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        sum = max(sum, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从状态转移方程可以看到，dp[i] = max(dp[i - 1], 0) + nums[i]看出，当前状态的值只取决于前一个状态值，所以我们可以用一个变量来代替dp[i-1]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        temp = max(temp, <span class="number">0</span>) + nums[i];</span><br><span class="line">        sum = max(temp, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-62-不同路径"><a href="#leetcode-62-不同路径" class="headerlink" title="leetcode 62. 不同路径"></a>leetcode 62. 不同路径</h2><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p></blockquote><p>使用二维数组作为状态方程，表示到达该位置的路径数。其中，初始状态，第一行和第一列的值为1。接着需要设计状态转移方程，其实通过观察也可以发现：dp[i][j] = dp[i-1][j] + dp[i][j-1]。（要努力培养这种思维，即如何利用之前已经获得的值呢？）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//状态初始化</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//状态初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-63-不同路径II"><a href="#leetcode-63-不同路径II" class="headerlink" title="leetcode 63*. 不同路径II"></a>leetcode 63*. 不同路径II</h2><p>同样使用动态规划来做，做法和62基本相同。不同之处在于，多了障碍物，所以初始化的时候需要注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.size(); i++)&#123; <span class="comment">// 对第一列进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123; <span class="comment">// 存在障碍物</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid[<span class="number">0</span>].size(); i++)&#123; <span class="comment">// 对第一行进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123; <span class="comment">// 存在障碍物</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转移方程和之前一致。另外要注意，如果我们的dp数组用int来存值，那么在中间会有计算结果超过int值表示。因此<strong>要修改成dp数组改成long表示</strong>。</p><p>另外，<strong>用vector初始化二维数组</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="leetcode-64-最小路径和"><a href="#leetcode-64-最小路径和" class="headerlink" title="leetcode 64. 最小路径和"></a>leetcode 64. 最小路径和</h2><p>还是比较简单的。我使用二维数组来做dp数组，状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br></pre></td></tr></table></figure><h2 id="leetcode-70-爬楼梯"><a href="#leetcode-70-爬楼梯" class="headerlink" title="leetcode 70. 爬楼梯"></a>leetcode 70. 爬楼梯</h2><p>其实是斐波那契数列题，也可以用动态规划的思想来理解。91题的思想要从这道题参考。</p><h2 id="leetcode-91-解码方法"><a href="#leetcode-91-解码方法" class="headerlink" title="leetcode 91*. 解码方法"></a>leetcode 91*. 解码方法</h2><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: &quot;12&quot;</span><br><span class="line">&gt; 输出: 2</span><br><span class="line">&gt; 解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: &quot;226&quot;</span><br><span class="line">&gt; 输出: 3</span><br><span class="line">&gt; 解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这一题，我做了很多次，但是都是错的。原因有两个：</p><ol><li>将动态规划的思想给搞错了，没有体会题目的含义；</li><li>没有注意到0这个边界条件的额外处理。</li></ol><p>正确的思路是这样的：</p><ol><li><p>我们知道最后一个字母有可能是由一个数字串或两个数字串转化而来，例如’12312’这个数字串，转化成字母串最后一位可以是’2’转成B，也可能是’12’转成L。</p></li><li><p>这就有点类似<strong>跳台阶</strong>问题。设数字串S的前i个数字解密成字母串有dp[i]种方式：那么就有<strong>dp[i] = dp[i-1] + dp[i-2]</strong>。</p><p>dp[i-1]表示最后一个数字解码成一个字母；</p><p>dp[i-2]表示最后两个数字解码成一个字母。</p></li></ol><p>而我的错误，就是没有看清楚本质，而是一直在处理各种边界条件的情况下死磕着，这是非常错误的！！通常情况下，状态转移方程不会有过多复杂的情况（正则表达式那一题除外）。因此，要自己认真体会！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i + 1] = dp[i] + dp[i - 1];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">0</span> || (s.size() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'0'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">        dp[i + <span class="number">1</span>] = s[i] == <span class="string">'0'</span> ? <span class="number">0</span> : dp[i]; </span><br><span class="line">        <span class="comment">// 如果为0，则表示这一位数字不能解码为一个字母，因此加0</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == <span class="string">'1'</span> || (s[i<span class="number">-1</span>] == <span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>)))&#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-96-不同的二叉搜索树"><a href="#leetcode-96-不同的二叉搜索树" class="headerlink" title="leetcode 96*. 不同的二叉搜索树"></a>leetcode 96*. 不同的二叉搜索树</h2><p>要知道怎么找规律。我们设$G(n)$代表n个整数为节点构成的二叉搜索树个数。其中，令$f(i)$表示第i个结点为根的二叉搜索树个数，则有：</p><script type="math/tex; mode=display">G(n) = f(1)+f(2)+...+f(n)</script><p>而$f(i)$又可以表示为以i为根节点，再结合左右子树的值：</p><script type="math/tex; mode=display">f(i) = G(i-1) * G(n - i)</script><p>因此有：</p><script type="math/tex; mode=display">G(n) = G(0)*G(n-1)+G(1)*G(n-2)+... +G(n-1)*G(0)</script><p>贴贴代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-120-三角形最小路径和"><a href="#leetcode-120-三角形最小路径和" class="headerlink" title="leetcode 120. 三角形最小路径和"></a>leetcode 120. 三角形最小路径和</h2><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。例如，给定三角形：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p>思路：使用二维dp数组，先初始化后，根据状态转移方程进行更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">// 第0列</span></span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == i)&#123;</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + triangle[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，再找最后一行的最小值即可。另外，上述代码是自顶向下求；而自底向上求会更加方便，因为dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]必成立，不需要额外判断。另外，还可以在原输入的基础上修改，做到空间复杂度为O(1)。</p><p>贴代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维dp数组</span></span><br><span class="line"><span class="keyword">if</span> (triangle.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(triangle.size() + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// dp中记录了求第i行时，第i+1行的最小路径和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); j++)&#123;</span><br><span class="line">        dp[j] = min(dp[j+<span class="number">1</span>], dp[j]) + triangle[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原数组修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); j++)&#123;</span><br><span class="line">        triangle[i][j] += min(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="leetcode-312-戳气球（困难）"><a href="#leetcode-312-戳气球（困难）" class="headerlink" title="leetcode 312*. 戳气球（困难）"></a>leetcode 312*. 戳气球（困难）</h2><blockquote><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><ul><li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><p><strong>示例:</strong></p><p>输入: [3,1,5,8]<br>输出: 167<br>解释: nums = [3,1,5,8] —&gt; [3,5,8] —&gt;   [3,8]   —&gt;  [8]  —&gt; []<br>     coins =  3<em>1</em>5      +  3<em>5</em>8    +  1<em>3</em>8      + 1<em>8</em>1   = 167</p></blockquote><p>记录一道困难的动态规划题，貌似网易很喜欢出。</p><p>动态规划：</p><p>经过一连串的分析（其实我看不太懂这个分析）<a href="https://qoogle.top/leetcode-312-burst-balloons/" target="_blank" rel="noopener">https://qoogle.top/leetcode-312-burst-balloons/</a> 总之，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">    dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> ans = helper(nums, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; </span><br><span class="line">    <span class="comment">// 问题区间，从第i到第j个气球，能获得的最大硬币数量</span></span><br><span class="line">    <span class="comment">// 边界</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = helper(nums, i, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = helper(nums, k + <span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// 因为第k个气球是最后引爆的，所以其相邻气球应该是区间的左右两端</span></span><br><span class="line">        <span class="keyword">int</span> delta = nums[k] * nums[i - <span class="number">1</span>] * nums[j + <span class="number">1</span>];</span><br><span class="line">        dp[i][j] = max(dp[i][j], left + right + delta);</span><br><span class="line">        <span class="comment">// dp[i][j]表示从i到j个气球（闭区间）能够获取的最大的硬币数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,2,5], amount = 11</span><br><span class="line">输出：3</span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>思想：我总想着怎么用贪心来解，殊不知，这是一道动态规划题。。。</p><script type="math/tex; mode=display">dp[i - 1] = \min_{j=0,1,...,n-1} dp[i - c_j] + 1</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态规划 - 完全背包问题</span></span><br><span class="line">    <span class="comment">// dp[i] = (\min_&#123;j=0,...,n - 1&#125; dp[i - cj]) + 1</span></span><br><span class="line">    <span class="comment">// 其中,cj表示硬币的金额数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = INT_MAX - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coins[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; dp[i - coins[j]]) temp = dp[i - coins[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-121-买卖股票的最佳时机"><a href="#leetcode-121-买卖股票的最佳时机" class="headerlink" title="leetcode 121. 买卖股票的最佳时机"></a>leetcode 121. 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p>思路：动态规划。如果直接计算最大差值的话应该会超时。机灵一点！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(prices.size(), <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minp = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], prices[i] - minp);</span><br><span class="line">        <span class="keyword">if</span> (minp &gt; prices[i]) minp = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[prices.size() - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122. 买卖股票的最佳时机II"></a>122. 买卖股票的最佳时机II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p>一直在想着要怎么用动态规划，万万没想到，这道题却是脑筋急转弯。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7, 1, 5, 6] 第二天买入，第四天卖出，收益最大（6-1），所以一般人可能会想，怎么判断不是第三天就卖出了呢? 这里就把问题复杂化了，根据题目的意思，当天卖出以后，当天还可以买入，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） == 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">            cnt += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h1><h2 id="leetcode-206-反转链表"><a href="#leetcode-206-反转链表" class="headerlink" title="leetcode 206. 反转链表"></a>leetcode 206. 反转链表</h2><p>今天，一直不擅长的题目做出来了！（也可能是因为之前做过）我的体会是，可以用画图的方式来看答案，就是自己摸清楚需要记录什么结点，结点之间的关系怎么变换，应该就可以懂了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代做法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>, *pro;</span><br><span class="line">    ListNode *ReverseHead;</span><br><span class="line">    <span class="keyword">while</span> (head)&#123;</span><br><span class="line">        pro = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        <span class="keyword">if</span> (pro == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ReverseHead = head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = pro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ReverseHead;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 递归做法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *newhead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-203-删除链表中等于给定值val的所有节点"><a href="#leetcode-203-删除链表中等于给定值val的所有节点" class="headerlink" title="leetcode 203 删除链表中等于给定值val的所有节点"></a>leetcode 203 删除链表中等于给定值val的所有节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    newhead-&gt;next = head;</span><br><span class="line">    ListNode* pre = newhead, *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == val)&#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的题，都直接重新刷一遍。</p><h2 id="leetcode-112-路径总和"><a href="#leetcode-112-路径总和" class="headerlink" title="leetcode 112. 路径总和"></a>leetcode 112. 路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case考虑边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum - root-&gt;val == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) ||</span><br><span class="line">        hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-94-二叉树的中序遍历"><a href="#leetcode-94-二叉树的中序遍历" class="headerlink" title="leetcode 94*. 二叉树的中序遍历"></a>leetcode 94*. 二叉树的中序遍历</h2><p>递归做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    inorderTraversal(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root) res.push_back(root-&gt;val);</span><br><span class="line">    inorderTraversal(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归，利用栈来做。看看代码就会理解！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (root || !S.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (root)&#123;</span><br><span class="line">            S.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">            root = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：前序遍历非递归写法"><a href="#补充：前序遍历非递归写法" class="headerlink" title="补充：前序遍历非递归写法"></a>补充：前序遍历非递归写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (p || !S.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            res.push_back(p-&gt;val);</span><br><span class="line">            S.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">            p = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与中序遍历非递归的不同点，在于访问结点的位置不同。前序遍历是在入栈时就访问，中序遍历是在出栈时访问。</p><h2 id="补充：后序遍历非递归写法"><a href="#补充：后序遍历非递归写法" class="headerlink" title="补充：后序遍历非递归写法"></a>补充：后序遍历非递归写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    TreeNode* temp;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            S.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = S.top();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right &amp;&amp; p-&gt;right != r) &#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                r = p; <span class="comment">//记录最近访问过的节点</span></span><br><span class="line">                p = <span class="literal">NULL</span>; <span class="comment">//重置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-95-不同的二叉搜索树II"><a href="#leetcode-95-不同的二叉搜索树II" class="headerlink" title="leetcode 95*. 不同的二叉搜索树II"></a>leetcode 95*. 不同的二叉搜索树II</h2><p>不太会，看答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n) <span class="keyword">return</span> generate(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generate(<span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">        res.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left_nodes = generate(left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; right_nodes = generate(i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode* left_node : left_nodes)&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode* right_node : right_nodes)&#123;</span><br><span class="line">                TreeNode* r = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                r-&gt;left = left_node;</span><br><span class="line">                r-&gt;right = right_node;</span><br><span class="line">                res.push_back(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-98-验证二叉搜索树"><a href="#leetcode-98-验证二叉搜索树" class="headerlink" title="leetcode 98. 验证二叉搜索树"></a>leetcode 98. 验证二叉搜索树</h2><p>有两个地方要注意：</p><ol><li>不能出现相等的数字！</li><li>空节点也返回true，算是二叉搜索树。</li></ol><p>第一种方法是通过中序遍历把结果保存到vector中，再依次判断；第二种方法是空间复杂度为O(1)，即边中序遍历边判断。但是，<strong>有边界值需要考虑</strong>！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 第二想法，边中序遍历边判断</span></span><br><span class="line">    <span class="comment">// int pre = INT_MIN; 先弄一个初始值,但如果这样初始化,会出现INT_MIN边界值,导致结果为false!!!</span></span><br><span class="line"><span class="keyword">long</span> pre = (<span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    InOrder(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &amp;&amp; flag)&#123;</span><br><span class="line">        InOrder(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= root-&gt;val) flag = <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        InOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-99-恢复二叉搜索树"><a href="#leetcode-99-恢复二叉搜索树" class="headerlink" title="leetcode 99*. 恢复二叉搜索树"></a>leetcode 99*. 恢复二叉搜索树</h2><p>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p>示例1：</p><p>输入: [1,3,null,null,2]</p><p>   1<br>  /<br> 3<br>  \<br>   2</p><p>输出: [3,1,null,null,2]</p><p>   3<br>  /<br> 1<br>  \<br>   2</p><p>感觉我有点被这个“困难”题给吓到了，所以并没有去思考思路。但是看了别人的答案后，发现其实是一道<strong>很简单</strong>的题。（事实证明，还是不懂）贴代码吧。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *t1, *t2, *pre; <span class="comment">//记得每个都要加星号！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root); </span><br><span class="line">    <span class="keyword">int</span> temp = t1-&gt;val;</span><br><span class="line">    t1-&gt;val = t2-&gt;val;</span><br><span class="line">    t2-&gt;val = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt; root-&gt;val)&#123; <span class="comment">// 要错误排序才交换</span></span><br><span class="line">        <span class="comment">// first swap occurence</span></span><br><span class="line">        <span class="keyword">if</span> (!t1) t1 = pre; </span><br><span class="line">        <span class="comment">// 主要不明白的是这里，尽管这里记录的是第一次的逆序对。但是如果出现了两个逆序对，t1不更新，但是t2却可以更新。备注：现在懂了，题目规定了只有两个节点错误交换，一般是这种情况1,3,2,4或者1,4,3,2,5（只需交换4 2）</span></span><br><span class="line">        t2 = root;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-100-相同的树"><a href="#leetcode-100-相同的树" class="headerlink" title="leetcode 100. 相同的树"></a>leetcode 100. 相同的树</h2><p>按照最简单的思维去思考！不要想得太复杂！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构和节点值都要相同</span></span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((!p &amp;&amp; q) || (p &amp;&amp; !q) || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-101-对称二叉树"><a href="#leetcode-101-对称二叉树" class="headerlink" title="leetcode 101*.对称二叉树"></a>leetcode 101*.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p>递归，多思考一下就能想出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> judge(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode* a, TreeNode* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a &amp;&amp; !b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((!a &amp;&amp; b) || (a &amp;&amp; !b)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;val == b-&gt;val) &amp;&amp; judge(a-&gt;left, b-&gt;right) &amp;&amp; judge(a-&gt;right, b-&gt;left);<span class="comment">//只有在值相等的条件下，才比较其左右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坑爹的是，自己写了很久的迭代写法，但是一直都是错的。就是利用队列层次遍历的那种常规操作，写出来的结果一直不对。最后，只能参考官方教程的做法， 当然，这样做其实效率更高，空间也用的少。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    Q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        TreeNode* t1 = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        TreeNode* t2 = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="comment">// 此处与递归判断的时候不同，是continue，而不是返回True</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Q.push(t1-&gt;right);</span><br><span class="line">        Q.push(t2-&gt;left);</span><br><span class="line">        Q.push(t1-&gt;left);</span><br><span class="line">        Q.push(t2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-102-二叉树的层次遍历"><a href="#leetcode-102-二叉树的层次遍历" class="headerlink" title="leetcode 102. 二叉树的层次遍历"></a>leetcode 102. 二叉树的层次遍历</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。返回类型为vector<vector\<int>&gt;，即按层添加。</vector\<int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">    TreeNode *t;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> len = Q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123; <span class="comment">// 这里是按层添加的精髓。</span></span><br><span class="line">            t = Q.front();</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) Q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) Q.push(t-&gt;right);</span><br><span class="line">            temp.push_back(t-&gt;val);</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-105-从前序与中序遍历序列构造二叉树"><a href="#leetcode-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="leetcode 105*. 从前序与中序遍历序列构造二叉树"></a>leetcode 105*. 从前序与中序遍历序列构造二叉树</h2><p>我之前在牛客做过，一直写的方法是利用构造多个vector序列。但是实际上这么写，空间和时间都有很大的复杂度！！！所以，今天看到了利用了hashmap的方法，特此记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line"><span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inorder = inorder;</span><br><span class="line">    <span class="keyword">int</span> size1 = preorder.size(), size2 = inorder.size();</span><br><span class="line">    <span class="keyword">if</span> (size1 == <span class="number">0</span> || size2 == <span class="number">0</span> || size1 != size2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size1; i++)&#123;</span><br><span class="line">        hashmap[inorder[i]] = i; <span class="comment">// here!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder(<span class="number">0</span>, size1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">builder</span><span class="params">(<span class="keyword">int</span> mostleft, <span class="keyword">int</span> mostright)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mostleft &gt; mostright) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> curval = preorder[preIndex];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(curval);</span><br><span class="line">    preIndex++;</span><br><span class="line">    root-&gt;left = builder(mostleft, hashmap[curval] - <span class="number">1</span>); <span class="comment">// 先构建左子树，因为先序遍历就是这样</span></span><br><span class="line">    root-&gt;right = builder(hashmap[curval] + <span class="number">1</span>, mostright);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-106-从中序与后序遍历序列构造二叉树"><a href="#leetcode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="leetcode 106*. 从中序与后序遍历序列构造二叉树"></a>leetcode 106*. 从中序与后序遍历序列构造二叉树</h2><p>这一题与前一题基本类似，同样用hashmap来加快时间效率。然而！！！在创建左右子树的时候，应当<strong>先创建右子树，再创建左子树</strong>（因为后序遍历的尾巴就先是右子树），不然会出错！！！</p><p>而由前序和中序构造二叉树，则要<strong>先创建左子树，再创建右子树</strong>！！！</p><h2 id="leetcode-108-将有序数组转换为二叉搜索树"><a href="#leetcode-108-将有序数组转换为二叉搜索树" class="headerlink" title="leetcode 108*. 将有序数组转换为二叉搜索树"></a>leetcode 108*. 将有序数组转换为二叉搜索树</h2><p>转换后的二叉搜索树需要是高度平衡二叉树。没有思路，但是看了答案后发现其实很简单。<strong>从有序数组的中间部分划分左右子树</strong>，就可以确保二叉搜索树是高度平衡的了！！要注意一点，中间部分对于偶数长度的数组来说，可能选左边的，也可能选右边的，所以答案的结果不唯一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> BuildTree(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>; </span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root-&gt;left = BuildTree(nums, i, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = BuildTree(nums, mid + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-110-平衡二叉树"><a href="#leetcode-110-平衡二叉树" class="headerlink" title="leetcode 110*. 平衡二叉树"></a>leetcode 110*. 平衡二叉树</h2><p>判断是否为平衡二叉树。我一开始是跟着自己在牛客网写的代码那样的写法来写，但是始终过不了leetcode的样例。后来，真相大白，我的代码确实有错误！！这也说明，牛客的样例和leetcode的样例相比不够全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getHeight(root-&gt;right); </span><br><span class="line">    <span class="comment">// 注释这么写就是没有继续递归判断，相当于只计算了根节点的左右两个子树是否平衡，但没有判断余下的子树！！</span></span><br><span class="line">    <span class="comment">// return abs(left - right) &gt; 1 ? 0 : 1;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>; <span class="comment">// 要继续判断接下来的子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-109-有序链表转换二叉搜索树"><a href="#leetcode-109-有序链表转换二叉搜索树" class="headerlink" title="leetcode 109*. 有序链表转换二叉搜索树"></a>leetcode 109*. 有序链表转换二叉搜索树</h2><p>这道题和108题有点类似，区别是输入不再是数组，而是一个升序链表。我一开始是将链表中的元素取出来放到数组中，再按照108题做，然而，运行效率和空间复杂度太高了！</p><p>实际上，我们可以按照那道题的思想，找出链表里中点的位置，再进行指针的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">    ListNode* pre = head, *slow = head-&gt;next, *fast = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next; </span><br><span class="line">    &#125; <span class="comment">// slow抵达中点</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">    root-&gt;left = sortedListToBST(head);</span><br><span class="line">    root-&gt;right = sortedListToBST(slow-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-222"><a href="#leetcode-222" class="headerlink" title="leetcode 222"></a>leetcode 222</h2><p>求完全二叉树的节点个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-72-编辑距离"><a href="#leetcode-72-编辑距离" class="headerlink" title="leetcode 72. 编辑距离"></a>leetcode 72. 编辑距离</h2><blockquote><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，计算出将 <em>word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p>示例 1:</p><p>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p>示例 2:</p><p>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEditDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word1.size() == <span class="number">0</span> &amp;&amp; word2.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cost(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cost[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cost[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123; <span class="comment">// 相等，无需变动</span></span><br><span class="line">                cost[i][j] = cost[i - <span class="number">1</span>][j - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cost[i-1][j-1]:替换操作</span></span><br><span class="line">                <span class="comment">// cost[i-1][j]:删除</span></span><br><span class="line">                <span class="comment">// cost[i][j-1]:插入</span></span><br><span class="line">                cost[i][j] = min(min(cost[i - <span class="number">1</span>][j - <span class="number">1</span>], cost[i - <span class="number">1</span>][j]), cost[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="leetcode-29-两数相除"><a href="#leetcode-29-两数相除" class="headerlink" title="leetcode 29. 两数相除"></a>leetcode 29. 两数相除</h2><blockquote><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求<strong>不使用乘法、除法和 mod 运算符</strong>。返回被除数 dividend 除以除数 divisor 得到的商。</p></blockquote><p>思路：很不擅长这类限制使用运算符的题目。参考他人的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件要全面解决！</span></span><br><span class="line">    <span class="keyword">if</span> (dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX; </span><br><span class="line">    <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>; <span class="comment">// 判断结果的正负号</span></span><br><span class="line">    <span class="keyword">if</span> ((dividend &gt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>))&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">long</span> t = <span class="built_in">abs</span>((<span class="keyword">long</span>) dividend); <span class="comment">// 用int会溢出，所以用long</span></span><br><span class="line">    <span class="keyword">long</span> d = <span class="built_in">abs</span>((<span class="keyword">long</span>) divisor);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 左移是乘2，右移是除以2</span></span><br><span class="line">        <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d)&#123; <span class="comment">// 此部分是关键，要自己体会</span></span><br><span class="line">            t -= d &lt;&lt; i;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &gt; <span class="number">0</span> ? res : -res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a>633. 平方数之和</h2><blockquote><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 a2 + b2 = c。</p></blockquote><p>用滑动窗口来做。但是，这道题有点坑，主要是在int类型上可能会超，因此要自己学会判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="built_in">sqrt</span>(c);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span> (start * start == c - end * end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start * start &lt; c - end * end)&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="面试题10-01-合并排序的数组"><a href="#面试题10-01-合并排序的数组" class="headerlink" title="面试题10.01. 合并排序的数组"></a>面试题10.01. 合并排序的数组</h2><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [1,2,3,0,0,0], m = 3</span><br><span class="line">B = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>我被自己愚蠢到了。一直想着，把A数组中的数字先往后挪，再利用归并排序从头开始填入数字，然而，这样做在挪数字时会出现很多的错误。其实，从A数组末尾开始比较着填数字就好了，是我太傻了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 想复杂了。。。从尾部开始填充数据就好了，唉。</span></span><br><span class="line">    <span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">    m--; n--;</span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span> || n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span> || (n &gt;= <span class="number">0</span> &amp;&amp; B[n] &gt;= A[m]))&#123;</span><br><span class="line">            A[index--] = B[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> A[index--] = A[m--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>BFS通常用来求解最短路径问题。要学会“抽象”问题。</p><h2 id="leetcode-127-单词接龙"><a href="#leetcode-127-单词接龙" class="headerlink" title="leetcode 127. 单词接龙"></a>leetcode 127. 单词接龙</h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：每次转换只能改变一个字母， 转换过程中的中间单词必须是字典中的单词。</p><p>说明: 如果不存在这样的转换序列，返回 0； 所有单词具有相同的长度 ；所有单词只由小写字母组成 ；字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p><p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出: 5</p><p>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。</p><p><strong>思路</strong>：这一题就是需要有抽象思维。每个单词是一个结点，只有相差一个字符的点之间才有路径，路径权值全部为1. 本质就是求图的两点最短路径问题！！！因此，用BFS来做最为合适。</p><h2 id="leetcode-994-腐烂的橘子"><a href="#leetcode-994-腐烂的橘子" class="headerlink" title="leetcode 994*. 腐烂的橘子"></a>leetcode 994*. 腐烂的橘子</h2><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></p><p>思路：这道题应该用广度优先遍历（虽然我一开始没有看出来）。这里类似于树的广度遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//将腐烂橘子压入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) Q.push(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> vol = Q.size(); <span class="comment">//标记队列内腐烂橘子个数,这里的做法和树的广度遍历很像！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vol; i++)&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x.first + dir_x[i];</span><br><span class="line">                <span class="keyword">int</span> ty = x.second + dir_y[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; grid[tx][ty] == <span class="number">1</span>)&#123; <span class="comment">//判断是否存在新鲜橘子</span></span><br><span class="line">                    grid[tx][ty] = <span class="number">2</span>;</span><br><span class="line">                    Q.push(&#123;tx, ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Q.empty())&#123; <span class="comment">//如果为空表示一开始就没有腐烂橘子，返回0分钟</span></span><br><span class="line">            res++;  <span class="comment">//每次取出队列所有橘子时间加1，同时压入被污染的新一批橘子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p>用BFS来求。一旦遍历到左右子树均为空的结点，则返回当前深度。</p><p>也可以递归来做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root-&gt;left), right = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right) ? <span class="number">1</span> + min(left, right) : <span class="number">1</span> + left + right</span><br><span class="line">    <span class="comment">// 之所以后面是1+left+right,这个时候left或者right一定有一个是0</span></span><br><span class="line">    <span class="comment">// 这样加上一个0，对另一个变量的值不会有影响，如果另一个是0 那就返回0+0+1否则返回另一个不为0的变量的值+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="leetcode-200-岛屿数量"><a href="#leetcode-200-岛屿数量" class="headerlink" title="leetcode 200. 岛屿数量"></a>leetcode 200. 岛屿数量</h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>标准DFS，但是很多细节要注意啊！！！另外，可以不用辅助数组就不用！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, 0));</span></span><br><span class="line">        <span class="comment">// memset(visited, 0, sizeof(visited));</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">// dfs(grid, visited, i, j);</span></span><br><span class="line">                    dfs2(grid, i, j);</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="comment">// 无需使用辅助数组</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.size() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].size() || grid[i][j] != <span class="string">'1'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        dfs2(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs2(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs2(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs2(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.size() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].size() || visited[i][j] || grid[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(grid, visited, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, visited, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, visited, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, visited, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode-130-被围绕的区域"><a href="#leetcode-130-被围绕的区域" class="headerlink" title="leetcode 130. 被围绕的区域"></a>leetcode 130. 被围绕的区域</h2><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>思路：其实，这道题要学会换个思路。我们不应该一直想着怎么求出被‘X’围绕的区域，而是可以从边界上的’O’来下手，这样就可以用普通的BFS或者DFS方法来做了！这里就不贴代码了，用DFS来做比较简单。</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="leetcode-452-用最少数量的箭引爆气球"><a href="#leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="leetcode 452. 用最少数量的箭引爆气球"></a>leetcode 452. 用最少数量的箭引爆气球</h2><blockquote><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p><p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p></blockquote><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure><p>思路：贪心思想。先按照气球的x_end坐标由小到大排序。然后再查看接下来气球的x_start是否大于这个first_end.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//边界条件不能忘！</span></span><br><span class="line">    <span class="comment">// 贪心法</span></span><br><span class="line">    sort(points.begin(), points.end(), cmp); <span class="comment">// 根据x_end将气球进行排序</span></span><br><span class="line">    <span class="keyword">int</span> first_end = points[<span class="number">0</span>][<span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">int</span> arrows = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; first_end)&#123; <span class="comment">// 大于first_end，说明不可以同时引爆</span></span><br><span class="line">            arrows += <span class="number">1</span>;</span><br><span class="line">            first_end = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="leetcode-54-螺旋矩阵"><a href="#leetcode-54-螺旋矩阵" class="headerlink" title="leetcode 54. 螺旋矩阵"></a>leetcode 54. 螺旋矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, down = m - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) res.push_back(matrix[up][i]);</span><br><span class="line">        <span class="keyword">if</span> (++up &gt; down) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; i++) res.push_back(matrix[i][right]);</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) res.push_back(matrix[down][i]);</span><br><span class="line">        <span class="keyword">if</span> (--down &lt; up) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; i--) res.push_back(matrix[i][left]);</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h1 id="额外找："><a href="#额外找：" class="headerlink" title="额外找："></a>额外找：</h1><p>5 一个数组a，判断是否存在i&lt;j&lt;k, a[i]&lt;a[k]&lt;a[j]（撕代码）</p><p>6 找到一个字符串中不重复子串的最大长度（撕代码）</p><p>7 一个二叉搜索树，找出小于m的最大数（撕代码）</p><p>算法题：两个有序数组求交集</p><p>给定一个表，列名如下，</p><p>user | video | time</p><p>查询每个用户第二个看得视频，请写出sql语句。</p><p>作者：Johnny想要offer<br><a href="https://www.nowcoder.com/discuss/199615来源：牛客网" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/199615来源：牛客网</a></p><p>  一道基于抖音的sql题目： </p><p>  给定一个表，列名如下， </p><p>  user  |  video  | time </p><p>  查询每个用户第二个看得视频，请写出sql语句。 </p><p>  写出统计用户数量的sql语句。 </p><p>  2 交叉熵损失函数公式怎么写 </p><p>  3 最大似然估计公式 </p><p>  4 梯度爆炸lstm怎么解决 </p><p>  5 一个数组a，判断是否存在i&lt;j&lt;k, a[i]&lt;a[k]&lt;a[j]（撕代码） </p><p>  6 找到一个字符串中不重复子串的最大长度（撕代码） </p><p>  7 一个二叉搜索树，找出小于m的最大数（撕代码） </p><p>  8 linux找上一个使用命令 </p><p>  9 vim定位到第一行</p><p>千万向量中找到和单个向量相似的那个，先聚类，再然后输入向量先与聚类中心比较再与类中的向量比较。</p><p>模型为了拟合数据而调节参数改变模型形状，正则则是使得模型形状更为平缓，使得泛化能力增加，而bias则只会使得模型平移，因此正则bias应该没什么效果</p><p>transformer结构</p><p>既然LR解决的是分类问题，它为什么叫逻辑回归</p><p><a href="https://www.jianshu.com/p/3956c2eb070e" target="_blank" rel="noopener">https://www.jianshu.com/p/3956c2eb070e</a></p><p><a href="https://blog.csdn.net/qq_38358305/article/details/88242839" target="_blank" rel="noopener">https://blog.csdn.net/qq_38358305/article/details/88242839</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从现在开始，按照leetcode专题刷题。此博文持续更新。&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写完函数，该return的记得return!&lt;/li&gt;
&lt;li&gt;不要丢三落四！！！&lt;ol&gt;
&lt;li&gt;树，不仅要会递归写法，同·时也要会迭代写法。&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>linux相关命令</title>
    <link href="https://github.com/DesmonDay/2020/03/05/linux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/DesmonDay/2020/03/05/linux相关命令/</id>
    <published>2020-03-05T05:42:20.000Z</published>
    <updated>2020-03-05T08:45:17.906Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些相对不太熟悉的命令和需要注意的知识。</p><p><a href="https://cyc2018.github.io/CS-Notes/" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/</a></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>cat : cat 命令用于连接文件并打印到标准输出设备上。（-n: 打印出行号，连同空白号；-b：打印行号，无空白行）</p><p>tac：cat 的反向操作，从最后一行开始打印。</p><p>more：和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p><p>less：和 more 类似，但是多了一个向前翻页的功能。</p><p>head：取得文件前几行（-n）； tail：head的反向操作，后几行。</p><p>od：以字符或者16进制的形式显示二进制文件。</p><p><strong>grep</strong>：使用<strong>正则表达式进行全局查找</strong>并打印**。搜索指定文件的内容，匹配指定的模式，默认情况下输出匹配内容所在的行。grep 只支持匹配而不能替换匹配到的内容。</p><p>touch：更新文件时间或<strong>建立新文件</strong>。</p><h2 id="指令与文件搜索"><a href="#指令与文件搜索" class="headerlink" title="指令与文件搜索"></a>指令与文件搜索</h2><p>man：man 是 manual 的缩写，将指令的具体信息显示出来。</p><p>info：info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。</p><p>which：指令搜索。</p><blockquote><p>which [-a] command </p><p>-a : 将所有指令列出，而不是只列第一个</p></blockquote><p>whereis：文件搜索。速度比较快，因为它只搜索几个特定的目录。</p><p>locate：文件搜索。可以用关键字或者正则表达式进行搜索。无法用 locate 搜索新建的文件，可以使用 updatedb 来立即更新数据库。</p><p>find：文件搜索。可以使用文件的属性和权限进行搜索。</p><blockquote><p>find [basedir] [option] 有许多的选项，时间、文件拥有者、文件权限和名称。</p><p>find . -name “shadow*” </p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>cut</strong>：用于显示每行从开头算起 num1 到 num2 的文字。对数据进行切分，取出想要的部分。</p><p>sort：用于排序。</p><p>who：在关机前需要先使用 who 命令查看有没有其它用户在线。</p><p>sync：为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p><p>shutdown：关机。</p><p>chmod：修改权限。</p><blockquote><p>chmod [-R] xyz dirname/filename 此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。如chmod 754 .bashrc</p></blockquote><p>uniq：可以将重复的数据只取一个。</p><p><strong>双向输出重定向</strong> tee：输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。$ tee [-a] file</p><p>split：将一个文件划分为多个文件</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是<strong>磁盘阵列</strong>等技术可以将一个分区格式化为多个文件系统。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>最主要的组成部分：</p><ul><li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li><li>block：记录文件的内容，文件太大时，会占用多个 block。</li></ul><p>除此之外还有：</p><ul><li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>block bitmap：记录 block 是否被使用的位图。</li></ul><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>对于Ext2文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p><p>对于FAT文件系统，没有 inode，每个 block 中存储着下一个 block 的编号。</p><h2 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h2><p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>inode具体包含以下信息：</p><ul><li>权限（read/write/execute）</li><li>拥有者与群组</li><li>容量</li><li>建立或状态改变的时间（ctime）</li><li>最近读取时间（atime）</li><li>最近修改时间（mtime）</li><li>定义文件特性的旗标（flag），如SetUID…</li><li>该文件真正内容的指向（pointer）</li></ul><p>inode中记录了文件内容所在的 block 编号，但是每个 block 非常小，而一个文件可能需要几十万的block。一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了<strong>间接、双间接、三间接引用</strong>。间接引用让 inode 记录的引用 block 块记录引用信息。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>建立一个目录时，会分配一个 inode 与至少一个 block。<strong>block 记录的内容是目录下所有文件的 inode 编号以及文件名</strong>。</p><h2 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h2><p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p><ul><li>/（root，根目录）</li><li>/usr（unix softmax resource 所有系统默认软件都会安装到这个目录）</li><li>/var（variable 存放系统或程序运行过程中的数据文件）</li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>使用 ll 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段。用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。后9位分别对应这三种用户。</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><h2 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h2><ul><li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li><li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" alt="img"></p><blockquote><p>ln [-sf] source_filename dist_filename</p><p>-s:默认是实体链接，加-s为符号链接</p><p>-f:如果目标文件存在时，先删除目标文件</p></blockquote><h3 id="实体链接"><a href="#实体链接" class="headerlink" title="实体链接"></a>实体链接</h3><p>在目录下创建一个条目，记录着文件名与 <strong>inode 编号</strong>，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。有以下限制：不能跨越文件系统、不能对目录进行链接。</p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>符号链接文件保存着源文件所在的<strong>绝对路径</strong>，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。可以为目录建立符号链接。</p><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>命令历史：记录使用过的命令</li><li>命令与文件补全：快捷键：tab</li><li>命名别名：例如 ll 是 ls -al 的别名</li><li>shell scripts</li><li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li></ul><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><p>对一个变量赋值直接使用=。对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p><p>可以使用 <strong>export 命令将自定义变量转成环境变量</strong>，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p><h2 id="指令搜索顺序"><a href="#指令搜索顺序" class="headerlink" title="指令搜索顺序"></a>指令搜索顺序</h2><ul><li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li><li>由别名找到该指令来执行；</li><li>由 Bash 内置的指令来执行；</li><li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li></ul><h1 id="管道指令"><a href="#管道指令" class="headerlink" title="管道指令"></a>管道指令</h1><p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>ps：查看某个时间点的进程信息。</p><p>pstree：查看进程树。</p><p>top：实时显示进程信息。</p><p>netstat：查看占用端口的进程。</p><h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/Linux?id=sigchld" target="_blank" rel="noopener">SIGCHLD</a></h2><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p><ul><li>得到SIGCHLD信号；</li><li>waitpid() 或者 wait() 调用会返回。</li></ul><p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 <strong>init 进程</strong>（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p>PATH：可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 <code>:</code> 分隔。</p><p>sudo：允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p><p>vim三个模式：</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png" alt="img"></p><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p><strong>BIOS</strong>：基本输入输出系统。它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（<strong>MBR</strong>），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些相对不太熟悉的命令和需要注意的知识。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cyc2018.github.io/CS-Notes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cyc2018.github.io/CS-N
      
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/DesmonDay/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>cs224n-2020追剧笔记</title>
    <link href="https://github.com/DesmonDay/2020/03/03/cs224n-2020%E8%BF%BD%E5%89%A7%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/DesmonDay/2020/03/03/cs224n-2020追剧笔记/</id>
    <published>2020-03-03T10:08:05.000Z</published>
    <updated>2020-03-04T07:41:07.386Z</updated>
    
    <content type="html"><![CDATA[<p>之前总是半途而废，希望这次不会。只记录关键点。</p><h1 id="week-1-Introduction-and-Word-Vectors"><a href="#week-1-Introduction-and-Word-Vectors" class="headerlink" title="week 1 - Introduction and Word Vectors"></a>week 1 - Introduction and Word Vectors</h1><p>one-hot表示：1. 词汇量过大；2. 无法表示单词之间的相似性（正交）</p><p>想要获得相似性信息：1. 构建相似词表(如WordNet。耗费人力、单词不断更新)；2. 分布式表示</p><p>分布式表示：利用单词的不同<strong>上下文</strong>(context window)，可以理解它的不同语义。</p><p>词向量：word vectors  / word embeddings / word representation. 低纬度，每个维度代表不同的含义（虽然往往无法获知具体的含义）</p><h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><p><em>思想</em>: </p><ul><li>我们有大量的训练语料</li><li>在一个固定的词汇表里，每个单词都可以用一个向量来表示(初始化: random)</li><li>text中的每个位置$t$，都有一个center word $c$和context words $o$</li><li>使用词向量的相似性来计算给定c求o的概率（或者给定o求c的概率）</li><li>不断训练调整词向量，使似然最大化</li></ul><p><em>似然</em>：</p><script type="math/tex; mode=display">Likelihood = L(\theta) = \prod_{t=1}^T \prod_{-m\le j\le m, j \neq 0} P(w_{t+j} | w_t; \theta)</script><p>以负对数似然作为目标方程（最小化$J(\theta)$ cost / loss / objective function）：</p><script type="math/tex; mode=display">min J(\theta) = -\frac{1}{T}\log L(\theta) = -\frac{1}{T}\sum_{t=1}^T \sum_{-m\le j \le m, j \neq 0} \log P(w_{t+j}|w_t; \theta)</script><p><em>如何计算$P(w_{t+j}|w_t; \theta)$</em>：</p><p>​       使用每个单词$w$的两种向量：$v_w$($w$ is a center word); $u_w$($w$ is a context word). 我们有（给定中心词，预测其上下文词）：</p><script type="math/tex; mode=display">P(o|c) = \frac{\exp(u_o^Tv_c)}{\sum_{w\in V}\exp(u^T_w v_c)}</script><p>上式其实是<strong>softmax function</strong>的一个例子。越相似，则分子越大，概率也越大。</p><script type="math/tex; mode=display">softmax(x_i) = \frac{\exp(x_i)}{\sum_{j=1}^n \exp(x_j)} = p _i</script><p><em>优化</em>：（梯度下降）</p><p>我们的参数是这些单词向量，对他们进行求导。</p><script type="math/tex; mode=display">\frac{\partial}{\partial v_c} \log \frac{\exp(u_o^Tv_c)}{\sum_{w\in V}\exp(u^T_w v_c)} \\= \frac{\partial}{\partial v_c}\log exp(u_o^Tv_c) - \frac{\partial}{\partial v_c}\log \sum_{w=1}^T \exp(u_w^T v_c) \\= \frac{\partial}{\partial v_c} u_o^T v_c - \frac{1}{\sum_{w=1}^V \exp(u_w^T v_c)} \sum_{x=1}^V \frac{\partial}{\partial v_c}\exp(u_x^Tv_c) \\= u_o - \frac{\sum_{x=1}^V exp(u_x^Tv_c) u_w}{\sum_{w=1}^V \exp(u_w^T v_c)} \\= u_o - \sum_{x=1}^V p(x|c) u_x</script><p>含义：用我们观察到的context word减去模型认为的context word(<strong>期望</strong>)。</p><p>我们可以利用Word2vec训练出来的词向量做相似性计算，或者说做“类比”。</p><h1 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h1><h2 id="Word-Vectors-2-and-Word-Senses"><a href="#Word-Vectors-2-and-Word-Senses" class="headerlink" title="Word Vectors 2 and Word Senses"></a>Word Vectors 2 and Word Senses</h2><h3 id="回顾Word2vec"><a href="#回顾Word2vec" class="headerlink" title="回顾Word2vec"></a>回顾Word2vec</h3><ol><li>iterate through each word of the whole corpus</li><li>predict surrounding words using word vectors</li></ol><p>不过要注意的一点是，我们要注意文档中出现频率过高的词（比如英文中的the that，中文的“的”等等，这些其实是停用词）。</p><p><em>梯度下降</em>：</p><script type="math/tex; mode=display">\theta^{new} = \theta^{old} - \alpha \triangledown_{\theta}J(\theta)</script><p>随机梯度下降(SGD)：只选取一个样本进行梯度的更新，加快梯度下降。</p><p>mini-batch: 选取一部分(batch，如64/256)样本进行梯度更新，相比较SGD而言更加稳定，另外也比批梯度下降的训练速度要快。</p><p>问题是，我们通常在一个batch中更新的样本是比较少的，这就导致$\triangledown_{\theta}J(\theta)$会非常稀疏，而事实上我们只会更新真正”出现”的词向量。所以相对的，如果我们的词向量数量非常大，那么就没有必要进行gigantic updates。</p><p><em>Word2Vec的两种模式</em>：</p><ol><li>Skip-grams：给定中心词，预测上下文词；</li><li>CBOW：给定上下文词，预测中心词。</li></ol><p><em>Word2Vec的两种优化</em>:</p><ol><li><p>Negative Sampling(当目前为止，所讲的是naive softmax，即实现起来简单，但是其实训练效率非常低下)。</p><p>主要思想：对true pair(中心词和其对应的上下文词)和noise pairs(中心词和随机选取的词作为负词)训练二元逻辑回归。</p><p>特点：负采样对常见词有利，罕见词不利。（30分）</p><p>skip-gram+负采样 原论文中的最大化目标方程：</p><script type="math/tex; mode=display">J_t(\theta)=\log \sigma(u_o^Tv_c)+\sum_{i=1}^k\mathbb{E}_{j\sim P(w)[\log \sigma(-u_j^Tv_c)]}</script><p>课堂上所展示的最小化目标方程：</p><script type="math/tex; mode=display">J_{neg-sample}(o,v_c,U)=-\log(\sigma(u_o^Tv_c)) - \sum_{k=1}^K\log(\sigma(-u_k^Tv_c))</script><p>在选取负样本的时候，$P(w)=U(w)^{3/4}/Z$(Z是归一化因子)。这个幂次方可以减少采样非常常见的单词的频率。</p></li><li><p>Hierarchical Softmax.</p></li></ol><h3 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h3><p><em>单词共现矩阵</em></p><p>存在的问题：词数量很大、高维（需要大量存储空间）、稀疏</p><p>解决方法：使用低维向量，像word2vec.</p><ol><li>奇异值分解(Singular Value Decompose): $X \sim U\Sigma V^T$，去除较小的奇异值所在维度，从而达到降维。（潜在语义分析：Latent Semantic Analysis）<strong><em>Hacks to X</em></strong>：忽略高频词或者修改对应的词频、采样closer words、使用Pearson相关系数矩阵而不是counts矩阵等等。</li><li>GloVe</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/8636110-da993cce927f57b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:80%;"></p><p>思想： 将两个流派的想法结合起来，<strong>在神经网络中使用计数矩阵</strong>。</p><ol><li><p>Encoding meaning in vector differences：<strong>Ratios of co-occurrence probabilities can encode</strong><br><strong>meaning components</strong>. </p><p>如何在词向量空间中以线性meaning component的形式捕获共现概率比？</p><p><em>log-bilinear模型</em>：$w_i\cdot w_j = \log P(i|j)$</p><p>由此得到向量差异：$w_x\cdot (w_a-w_b)=\log\frac{P(x|a)}{P(x|b)}$</p></li><li><p>Combining the best of both Worlds(<strong>GloVe</strong>)对应公式：</p><script type="math/tex; mode=display">w_i\cdot w_j = \log P(i|j) \\J=\sum_{i,j=1}^V f(X_{ij})(w_i^T\hat{w_j}+b_i+\hat{b}_j-\log X_{ij})^2</script><p>使用平方损失公式。另外是使用了f函数来限制高频词的作用。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-9d8e28dc4f095d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>优点：训练快、可以扩展到大型语料库、对小型语料库和低纬度向量也适用。</p></li></ol><h3 id="评价词向量"><a href="#评价词向量" class="headerlink" title="评价词向量"></a>评价词向量</h3><p>Intrinsic: 如类比(man-king,woman-?)或者相似性（使用余弦距离计算）。</p><p>Extrinsic: 使用真实任务进行评价，如问答系统等。词向量其实是作为一个提升性能的工具。</p><p>参数的设置：</p><ol><li>词向量维度：On the dimensionality of word embedding. 使用矩阵扰动理论进行研究。(即使维度很大，到了上万，词向量的作用也依然稳定)。</li><li>训练时间：越多的训练时间也会有帮助。</li><li>训练数据：越多的数据也有帮助，Wikipedia比news text更有效。</li></ol><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>大部分的词有多种含义，而我们所使用的词向量能够表示多种含义呢？</p><p>方法：</p><ol><li>根据词窗口进行聚类，区分词的不同簇，即不同含义。</li><li>使用加权和-&gt;有效，因为单词的不同含义其实被<strong>稀疏编码</strong>了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前总是半途而废，希望这次不会。只记录关键点。&lt;/p&gt;
&lt;h1 id=&quot;week-1-Introduction-and-Word-Vectors&quot;&gt;&lt;a href=&quot;#week-1-Introduction-and-Word-Vectors&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
      <category term="python" scheme="https://github.com/DesmonDay/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>STL容器基本操作</title>
    <link href="https://github.com/DesmonDay/2020/03/01/STL%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/DesmonDay/2020/03/01/STL容器基本操作/</id>
    <published>2020-03-01T03:09:36.000Z</published>
    <updated>2020-03-04T12:37:51.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 queue"></a>队列 queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">q.push(item);</span><br><span class="line">q.pop();</span><br><span class="line">q.front();</span><br><span class="line">q.back();</span><br><span class="line">q.size();</span><br><span class="line">q.empty();</span><br></pre></td></tr></table></figure><h2 id="双向队列-deque"><a href="#双向队列-deque" class="headerlink" title="双向队列 deque"></a>双向队列 deque</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c.assign(begin, end); 将[beg; end)区间中的数据赋值给c，其中begin和end为其他容器的迭代器</span><br><span class="line">c.assign(n, elem); 将n个elem的拷贝赋值给c。</span><br><span class="line">c.at(idx); 如越界，则抛出异常</span><br><span class="line">c.back(), c.front();</span><br><span class="line">c.begin(), c.end();</span><br><span class="line">c.clear();</span><br><span class="line">c.empty();</span><br><span class="line">c.erase(pos); pos为迭代器</span><br><span class="line">c.insert(pos, elem);</span><br><span class="line">c.insert(pos, n, elme);</span><br><span class="line">c.insert(pos, begin, end);</span><br><span class="line">c.max_size();</span><br><span class="line"></span><br><span class="line">c.pop_back();</span><br><span class="line">c.pop_front();</span><br><span class="line">c.push_back(elem);</span><br><span class="line">c.push_front(elem);</span><br><span class="line">c.rbegin();</span><br><span class="line">c.rend();</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><a href="https://blog.csdn.net/weixin_43930512/article/details/91040416" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43930512/article/details/91040416</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">5</span>); <span class="comment">//声明一个初始大小为5的int向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//声明一个初始大小为10且值都是1的向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(tmp); <span class="comment">// 声明并用tmp向量初始化vec向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(vec.begin(), vec.end()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// vector常见操作</span></span><br><span class="line">vec.push_back(v);</span><br><span class="line">vec.insert(vec.begin(), <span class="number">8</span>); <span class="comment">// 在最前面插入新元素8</span></span><br><span class="line">vec.pop_back();</span><br><span class="line">vec.clear(); <span class="comment">//清空</span></span><br><span class="line">vec.erase(iter); <span class="comment">// 迭代器删除</span></span><br><span class="line">vec.at(<span class="number">0</span>);</span><br><span class="line">vec.front();  <span class="comment">//得到头元素</span></span><br><span class="line">vec.back();</span><br><span class="line">vec.begin(); <span class="comment">//返回头元素的指针</span></span><br><span class="line">vec.end();</span><br><span class="line">vec.size();</span><br><span class="line">vec.max_size(); <span class="comment">// 最大可允许的vector元素数量值</span></span><br><span class="line">vec.capacity(); <span class="comment">// vector实际能容纳的大小</span></span><br><span class="line">vec.empty();</span><br><span class="line"><span class="comment">// swap函数，可用于释放过剩的容量</span></span><br></pre></td></tr></table></figure><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h2><h3 id="C风格"><a href="#C风格" class="headerlink" title="C风格"></a>C风格</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; greeting &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 常见操作</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, s2); <span class="comment">// 把s2的内容复制到s1</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">strlen</span>(s1); <span class="comment">//返回s1的长度（不加'\0'）sizeof(s1)返回字符串数组大小</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2); <span class="comment">//如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch); <span class="comment">//返回一个指针，指向字符串s1中字符ch第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2); <span class="comment">//返回一个指针，指向字符串s1中字符串s2第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用strchr(s1, ch)</span></span><br><span class="line"><span class="keyword">char</span> first[<span class="number">20</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="built_in">strchr</span>(first, <span class="string">'l'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出llo</span></span><br></pre></td></tr></table></figure><h3 id="C-风格"><a href="#C-风格" class="headerlink" title="C++风格"></a>C++风格</h3><p>这里查看详细的用法：<a href="https://blog.csdn.net/weixin_43930512/article/details/91041396" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43930512/article/details/91041396</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"abcd"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="number">5</span>, <span class="string">'a'</span>)</span></span>;   <span class="comment">// 5个a</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">"abc"</span>)</span></span>; <span class="comment">// 5个c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"abcdefg"</span>,<span class="number">3</span>)</span></span>; <span class="comment">//abc</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str5</span><span class="params">(<span class="string">"abcdefghijk"</span>, <span class="number">3</span>, <span class="number">5</span>)</span></span>; <span class="comment">//defgh, 从第3个位置取5个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string常见操作</span></span><br><span class="line">增加：+, append, insert, push_back</span><br><span class="line">删除：clear, pop_back, erase</span><br><span class="line">修改：replace, assign, swap</span><br><span class="line">大小：size, length, capacity, max_size, resize, reserve</span><br><span class="line">判断：empty, compare, &gt;=, &lt;=, &gt;, &lt;</span><br><span class="line">其他：getline, <span class="built_in">string</span>转换, substr, find</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"1234"</span>;</span><br><span class="line"><span class="keyword">int</span> b = atoi(a.c_str());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">string</span> b = to_string(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abc"</span>;</span><br><span class="line">reverse(str.begin(), str.end()); <span class="comment">// cba</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;队列-queue&quot;&gt;&lt;a href=&quot;#队列-queue&quot; class=&quot;headerlink&quot; title=&quot;队列 queue&quot;&gt;&lt;/a&gt;队列 queue&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="C++" scheme="https://github.com/DesmonDay/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>对话系统相关知识与论文</title>
    <link href="https://github.com/DesmonDay/2020/02/29/%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%AE%BA%E6%96%87/"/>
    <id>https://github.com/DesmonDay/2020/02/29/对话系统相关知识与论文/</id>
    <published>2020-02-29T04:20:43.000Z</published>
    <updated>2020-02-29T16:44:28.925Z</updated>
    
    <content type="html"><![CDATA[<p>这里简单记录一下对话系统的各种领域，以及对应的代表论文。参考：<a href="https://zhuanlan.zhihu.com/p/83825070?utm_source=zhihu&amp;utm_medium=social&amp;utm_oi=697119379778727936" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/83825070?utm_source=zhihu&amp;utm_medium=social&amp;utm_oi=697119379778727936</a></p><h2 id="生成式对话"><a href="#生成式对话" class="headerlink" title="生成式对话"></a>生成式对话</h2><p>仍然是一个需要探索的领域，主要原因是，我们尽管可以将对话看作是seq2seq问题，但是这种闲聊对话其实其输出空间是非常大的，因此对于建模成生成问题来看的话，其实比较难。最主要的是缺少一个比较客观的自动评估策略。</p><p>不过，这次参加了一个百度的任务驱动型对话，尽管也算是闲聊，但是其闲聊是带着目的性的，即输出空间有限，因此可以使用生成式对话来解决。生成式对话，我们大多数时候可以参考翻译、文本摘要、语言模型等领域的比较典型的论文。</p><h2 id="检索式对话"><a href="#检索式对话" class="headerlink" title="检索式对话"></a>检索式对话</h2><p><img src="https://pic2.zhimg.com/80/v2-f3bc4f128c2b5595c6def4c70e2458ad_720w.jpg" alt="img"></p><p>检索式对话是工业界比较偏爱的方法，可以用于解决闲聊型对话或FAQ问答型对话问题。FAQ通常是限定域的，比较容易解决，但对于闲聊型对话，即开放域，则需要大量的query-response pairs，即语料需要充足。随后，主要经历两个步骤。</p><h3 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h3><p>首先，在用神经网络深度匹配合适的回复之前，一般要先经过一个“粗筛”的模块召回若干相关的回复，减少q-r匹配的工作量。这个模块一般将用户当前轮的query与语料库里query进行快速匹配（当然你也可以加更多feature提高合适回复的召回率），得到几十上百个候选回复，完成第一轮的匹配。</p><p>因此这就要求q-q粗召模块比较轻量级，且匹配相关度比较好。因此我们可能需要检索模型BM25和一些轻量级文本特征表示模型如BOW。在开源文本匹配方面，可以使用百度的AnyQ开源工具。</p><h3 id="精排"><a href="#精排" class="headerlink" title="精排"></a>精排</h3><p>有了若干候选回复后，我们就需要一个精排模块来挑选合适的回复。这里主要的代表性工作，按照时间先后顺序有：</p><p>Multi-view: Multi-view response selection for human-computer conversation.</p><p>SMN: </p><p>DAM: Multi-turn response selection for chatbots with deep attention matching network</p><p>DGU: <a href="https://link.zhihu.com/?target=https%3A//github.com/baidu/Dialogue/tree/master/DGU" target="_blank" rel="noopener">https://link.zhihu.com/?target=https%3A//github.com/baidu/Dialogue/tree/master/DGU</a></p><h2 id="任务完成型对话"><a href="#任务完成型对话" class="headerlink" title="任务完成型对话"></a>任务完成型对话</h2><p>任务完成型对话的最终目标是完成任务，即需要在每一轮对话都采取合适的决策。这相当于一个多步决策求取reward（对话目标完成情况）最大化的问题，也就是强化学习的问题。（可惜，我没有学RL！！）但是，貌似RL在对话领域里还是有一定地位的，有机会再学习吧。</p><h3 id="对话动作"><a href="#对话动作" class="headerlink" title="对话动作"></a>对话动作</h3><p>用户发出的这个蕴含在自然语言中的命令就称为用户动作user action，我们可以将用户动作看做是用户输入的语义表示。因此，将用户动作从用户的自然语言文本甚至语音信号中解析出来的过程就称为自然语音理解（NLU）或口语理解（SLU）。</p><p>简单的想法是将每个action表示为全局唯一的id，但是action和action之间经常存在很深的耦合关系。比如”预定附近的椰子鸡“与”预定椰子鸡“之间是上下位关系，”预定西二旗附近的椰子鸡“与”预定西三旗附近的椰子鸡“有一个共同的”父action“——预定椰子鸡，我们采取的折中方式为“意图+槽位”，即用意图来表示一个模糊的目标，使用该意图预定义的一系列槽位来限制这个模糊目标，使得目标具体化。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> 意图: 订餐</span><br><span class="line"> 槽位: &#123;</span><br><span class="line">       地点: 西二旗,</span><br><span class="line">       餐厅名: 椰子鸡</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这个自然语言输入到用户动作这种结构化语义表示(frame)的过程称为自然语言理解（NLU）。实际中，意图和槽位设计可能要复杂的多，比如有的槽位是不可枚举的（比如时间），槽位有冲突，甚至槽位内要嵌套槽位等，这些就要具体情况具体分析了。</p><h3 id="理解用户输入"><a href="#理解用户输入" class="headerlink" title="理解用户输入"></a>理解用户输入</h3><p>通常，我们默认一句话最多包含一个意图，因此可以将NLU任务中的意图识别看成简单的<strong>文本分类任务</strong>。</p><blockquote><p>通常，我们在意图识别前，需要加一级领域分类，避免意图识别模型无法cover其他的领域。</p></blockquote><p>而一个意图往往包含多个槽位，因此我们可以自然地将槽位解析任务建模为<strong>序列标注任务</strong>或者简化为<strong>文本多标签分类任务</strong>。由于意图识别和槽位解析任务息息相关，因此经常有将这两个任务进行join training的模型。</p><p>如今，意图识别与槽位解析的SOTA方法是百度对话团队的DGU，基于ERNIE2.0+处理多轮对话的精巧tricks刷爆了绝大多数对话任务。</p><h3 id="记录对话状态"><a href="#记录对话状态" class="headerlink" title="记录对话状态"></a>记录对话状态</h3><p>为了弄清楚用户的具体意图（把该填的槽填上，该解决的取值冲突解决掉），往往需要记下对话的关键信息，以供<strong>对话策略模块</strong>使用，帮助进行每一轮的决策。这里成为<strong>对话状态(dialogue state)</strong>，完成其更新的过程称为<strong>对话状态追踪</strong>（<em>dialogue state tracking，DST，又称 belief tracking</em>）。</p><p>显然，对话状态的描述需要通过frame的方式来描述。而这种结构化的表示并不是在对话记录中显式存在的，很难通过<strong>大规模数据驱动</strong>的方法来学习记录对话状态的DST模型。</p><ol><li>规则方法：最直接的一种策略是直接将NLU的输出结果（意图、槽位概率分布）离散化，直接取概率最高的意图、槽位作为本轮的用户动作，然后更新到DST模块中，这种方法适合DST的冷启动。显然，直接离散化最高概率的规则方法实现的DST会高度依赖NLU的准确性，且只能处理简单情况，并且在DST更新时会完全忽略已经积累的对话状态。所以，使用统计方法来建模ASR（语音识别）和NLU输出的不确定性是非常有必要的。</li><li>统计方法：构建DST数据集，使用有监督学习操作进行学习。比如利用分类器，或者建模成有监督的序列标注问题。然而，显然DST学习到的函数映射是基于NLU输出的概率分布的，一旦更新了NLU，则DST所熟悉的输入分布发生巨大改变，导致性能大打折扣。因此，自然的想法是让NLU和DST<strong>从pipeline结构变成端到端结构</strong>，即让用户自然语言输入直接连接到对话状态上，因此就可以将DST问题建模成“多轮分类”问题。<strong>DGU</strong>解决DST问题就会根据这种多轮分类的思路来做。</li></ol><h3 id="多轮决策完成对话目标"><a href="#多轮决策完成对话目标" class="headerlink" title="多轮决策完成对话目标"></a>多轮决策完成对话目标</h3><p>接下来，系统可以根据当前轮NLU模块解析出来的用户动作和积累的对话状态来完成相应的“推理”（称为对话策略模块），决定下一步是去澄清意图，say goodbye还是其他什么动作，并且后续NLG模块（<strong>自然语言生成</strong>）也会根据DP模块输出的对话决策（系统动作）来决定回复内容（即结构-&gt;文本）。</p><p>要完成对话目标，有监督学习对话策略是不靠谱的，所以对话策略的学习离不开RL。（又是我不会的，唉）经典代表作：A network-based end-to-end trainable task-oriented dialogue system</p><p><img src="https://pic1.zhimg.com/80/v2-b8dc5e4fb0b68a94e3ab8c753c12c9a4_720w.jpg" alt="img"></p><p>Belief Tracker:</p><p><img src="https://pic3.zhimg.com/80/v2-51969c97cec2df472bb9358f65eb6072_720w.jpg" alt="img"></p><h3 id="NLG"><a href="#NLG" class="headerlink" title="NLG"></a>NLG</h3><p>假如我们的pipeline系统终于可以作出合理决策（action）了。比如用户说，“好的，谢谢”，那么我们的系统经过语义理解、对话状态查询和作出决策，得出了“说再见”的系统动作，于是就要有一个模块将系统动作（即结构化语义表示）来翻译成自然语言输出“不客气哦，下次再见啦～”，完成这个结构-&gt;文本的模块就是自然语言生成（NLG）模块。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>多轮对话决策和单轮的意图识别的区别是什么？是因为要考虑上下文做一个更优决策吗？</li></ol><blockquote><p>最主要的是多轮对话涉及到意图的继承以及是否为开启一个新的意图</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里简单记录一下对话系统的各种领域，以及对应的代表论文。参考：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83825070?utm_source=zhihu&amp;amp;utm_medium=social&amp;amp;utm_oi=697119379
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>一些重要知识</title>
    <link href="https://github.com/DesmonDay/2020/02/22/%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86/"/>
    <id>https://github.com/DesmonDay/2020/02/22/一些重要知识/</id>
    <published>2020-02-22T15:21:21.000Z</published>
    <updated>2020-04-08T16:30:02.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1x1卷积核"><a href="#1x1卷积核" class="headerlink" title="1x1卷积核"></a>1x1卷积核</h2><p><a href="https://zhuanlan.zhihu.com/p/40050371" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40050371</a></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-f48e097dd1a9f711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-1fc976e41c8264ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="1x1卷积核作用"><a href="#1x1卷积核作用" class="headerlink" title="1x1卷积核作用"></a><strong>1x1卷积核作用</strong></h3><ul><li><p><strong>降维/升维</strong>：改变通道大小</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-c1ab7da0836e4108.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p><strong>增加非线性</strong></p><p>1*1卷积核，可以在保持feature map尺度不变的（即不损失分辨率）的前提下大幅增加非线性特性（利用后接的非线性激活函数），把网络做的很deep。</p><p>备注：一个filter对应卷积后得到一个feature map，不同的filter(不同的weight和bias)，卷积以后得到不同的feature map，提取不同的特征，得到对应的specialized neuron</p></li><li><p><strong>跨通道信息交互（channal 的变换）</strong></p><p>例子：使用1x1卷积核，实现降维和升维的操作其实就是channel间信息的线性组合变化，3x3，64channels的卷积核后面添加一个1x1，28channels的卷积核，就变成了3x3，28channels的卷积核，原来的64个channels就可以理解为跨通道线性组合变成了28channels，这就是通道间的信息交互[7]。</p></li></ul><h3 id="感受野计算"><a href="#感受野计算" class="headerlink" title="感受野计算"></a>感受野计算</h3><p>从底向上计算。</p><p><img src="https://img-blog.csdn.net/20180708134258973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Byb2dyYW1fZGV2ZWxvcGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>在卷积神经网络中，感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上的像素点在输入图片上映射的区域大小。</p><h2 id="beam-search"><a href="#beam-search" class="headerlink" title="beam search"></a>beam search</h2><p>对于seq2seq，我们实际上是在建模</p><p>$p(Y|X)=p(Y_1|X)p(Y_2|X,Y_1)p(Y_3|X,Y_1,Y_2)p(Y_4|X,Y_1,Y_2,Y_3)…$</p><p>在解码时，我们希望能找到最大概率的$Y$。</p><ul><li>贪心：如果我们在第一步$p(Y_1|X)$时，直接选择最大概率的（期望目标是$P$），然后代入第二步$p(Y_2|X,Y_1)$，再次选择最大概率$Y_2$，依次类推，每一步选择当前最大概率的输出，则称为<strong>贪心搜索</strong>，是一种最低成本的解码方案。但这种方案得到的结果未必是最优的，而假如第一步我们选择了概率不是最大的$Y_1$，代入第二步时也许会得到非常大的条件概率$p(Y_2|X,Y_1)$，从而两者乘积会超过逐位取最大的算法。</li><li>beam search: 如果要枚举所有路径最优，其计算量是无法接受的。因此seq2seq使用了一种折中的方法：beam search。该方法的思想是：<strong>在每步计算时，只保留当前最优的topk个候选结果</strong>。比如取$topk=3$，则第一步时，只保留使得$p(Y_1|X)$最大的前三个$Y_1$，然后分别代入$p(Y_2|X,Y_1)$，然后各取前三个$Y_2$，这样就有了9个组合。这时候计算每一种组合的总概率，仍然只保留前三个，依次递归，直到出现第一个\<end>。普通贪心搜索相当于$topk=1$。</end></li></ul><h2 id="SVD分解原理"><a href="#SVD分解原理" class="headerlink" title="SVD分解原理"></a>SVD分解原理</h2><p>参考资料：<a href="https://www.cnblogs.com/pinard/p/6251584.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6251584.html</a></p><h2 id="文本主题模型-潜在语义索引（LSI）"><a href="#文本主题模型-潜在语义索引（LSI）" class="headerlink" title="文本主题模型-潜在语义索引（LSI）"></a>文本主题模型-潜在语义索引（LSI）</h2><p>参考资料：<a href="https://www.cnblogs.com/pinard/p/6805861.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6805861.html</a></p><h2 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h2><p><a href="https://www.cnblogs.com/pinard/p/6812011.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6812011.html</a></p><h2 id="LDA模型"><a href="#LDA模型" class="headerlink" title="LDA模型"></a>LDA模型</h2><p><a href="https://www.cnblogs.com/pinard/p/6831308.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6831308.html</a></p><h2 id="RNN-LSTM"><a href="#RNN-LSTM" class="headerlink" title="RNN, LSTM"></a>RNN, LSTM</h2><p><a href="https://blog.csdn.net/zhaojc1995/article/details/80572098" target="_blank" rel="noopener">https://blog.csdn.net/zhaojc1995/article/details/80572098</a></p><h2 id="TextCNN"><a href="#TextCNN" class="headerlink" title="TextCNN"></a>TextCNN</h2><p><a href="https://www.cnblogs.com/bymo/p/9675654.html" target="_blank" rel="noopener">https://www.cnblogs.com/bymo/p/9675654.html</a></p><p><img src="https://img2018.cnblogs.com/blog/1182656/201809/1182656-20180919171920103-1233770993.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1182656/201809/1182656-20180920144901341-139977476.png" alt="img"></p><p>通道：</p><ul><li>图像中可以利用（R,G,B）作为不同channel;</li><li>文本的输入的channel通常是<strong>不同方式的embedding方式</strong>（比如 word2vec或Glove），实践中也有利用静态词向量和fine-tunning词向量作为不同channel的做法</li></ul><p>一维卷积（conv-1d）：</p><ul><li>图像是二维数据；</li><li>文本是一维数据，因此<strong>在TextCNN卷积用的是一维卷积</strong>（在<strong>word-level</strong>上是一维卷积；虽然文本经过词向量表达后是二维数据，但是在embedding-level上的二维卷积没有意义）一维卷积带来的问题是需要<strong>通过设计不同 kernel_size 的 filter 获取不同宽度的视野</strong>。</li></ul><p>Pooling层：</p><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1404.2188.pdf" target="_blank" rel="noopener">A Convolutional Neural Network for Modelling Sentences</a> 中将pooling层改成了<strong>(dynamic) k-max pooling</strong>，pooling阶段保留 k 个最大的信息，保留了全局的序列信息。</p><h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><p><a href="https://www.cnblogs.com/pinard/p/7160330.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/7160330.html</a></p><p><a href="https://www.jianshu.com/p/471d9bfbd72f" target="_blank" rel="noopener">https://www.jianshu.com/p/471d9bfbd72f</a> </p><p><a href="https://zhuanlan.zhihu.com/p/35500923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35500923</a> (susht师姐讲得更好)</p><h2 id="减少过拟合"><a href="#减少过拟合" class="headerlink" title="减少过拟合"></a>减少过拟合</h2><ol><li>L1/L2正则化</li><li>交叉验证</li><li>dropout</li><li>增大数据量</li><li>降低模型复杂度</li><li>Batch Norm</li><li>early stop</li><li>bagging</li></ol><h2 id="解决梯度消失"><a href="#解决梯度消失" class="headerlink" title="解决梯度消失"></a>解决梯度消失</h2><ol><li>修改激活函数</li><li>Batch Norm</li><li>使用LSTM</li><li>short cut 残差</li></ol><h2 id="数据不平衡"><a href="#数据不平衡" class="headerlink" title="数据不平衡"></a>数据不平衡</h2><ol><li>欠采样：去除一些样例使得类别均衡；代表型算法是利用集成学习机制，将反例划分为若干各集合供不同学习器使用，这样看起来对每个学习器都进行了欠采样，但在全局不会丢失重要信息。</li><li>过采样：生成合成数据的过程，试图学习少数类样本特征随机地生成新的少数类样本数据。最常见的技术为SMOTE算法，在少数类数据点的特征空间里，根据随机选择的一个K最近邻样本随机地合成新样本。</li></ol><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ol><li><p><a href="https://spaces.ac.cn/archives/5861" target="_blank" rel="noopener">玩转Keras之seq2seq自动生成标题</a> - 特别的一点，这个任务具有先验知识：<strong>标题中的大部分字词都在文章中出现过</strong>（注：仅仅是出现过，并不一定是连续出现，更不能说标题包含在文章中，不然就成为一个普通的序列标注问题了）。因此，可以将文章中的词集作为一个先验分布，加到解码过程的分类模型中，使得模型在解码输出时更倾向选用文章中已有的字词。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-6ebc35177d0a0a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><ol><li><a href="https://zhuanlan.zhihu.com/p/35586145" target="_blank" rel="noopener">文本多分类踩过的坑</a>: 又是susht师姐的文章。很详细的记录了一些文本多分类时的问题，值得深入思考。</li><li>贝叶斯估计、极大似然估计、最大后验估计：</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UnIETViboUMffyV0Q2kDawtBdqGtVezicjd2UPZ7Y3gaEZ04dV4VeERXgdUImvXztPxB0YuCwVs6bMIomiaIzhUbA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1x1卷积核&quot;&gt;&lt;a href=&quot;#1x1卷积核&quot; class=&quot;headerlink&quot; title=&quot;1x1卷积核&quot;&gt;&lt;/a&gt;1x1卷积核&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/40050371&quot; target
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/DesmonDay/2020/02/22/%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/DesmonDay/2020/02/22/预训练语言模型/</id>
    <published>2020-02-22T07:46:28.078Z</published>
    <updated>2020-03-25T04:34:14.320Z</updated>
    
    <content type="html"><![CDATA[<p>title: 预训练语言模型<br>date: 2020-02-25 15:46:28<br>categories: NLP</p><p>本文记录一些关于预训练语言模型讲解比较好的中文博客，有时间再补充自己的理解。</p><h2 id="预训练方式"><a href="#预训练方式" class="headerlink" title="预训练方式"></a>预训练方式</h2><p>传统的模型预训练手段就是语言模型，比如<a href="https://arxiv.org/abs/1802.05365" target="_blank" rel="noopener">ELMo</a>模型就是以BiLSTM为基础架构、用两个方向的语言模型分别预训练两个方向的LSTM的；后面的OpenAI的GPT、<a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language-models.pdf" target="_blank" rel="noopener">GPT-2</a>也是用标准的、单向的语言模型来预训练。</p><p>之后还有更多的预训练方式，比如BERT使用了称为”掩码语言模型(Masked Language Model)”的方式来预训练；而XLNet提出的为更彻底的”Permutation Language Modeling”，称为“乱序语言模型”；还有UNILM模型，直接用当个BERT架构做Seq2seq等等。</p><h2 id="ELMO"><a href="#ELMO" class="headerlink" title="ELMO"></a>ELMO</h2><p><a href="https://zhuanlan.zhihu.com/p/88993965" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88993965</a> 最大的优点是动态词向量，同一个词，出现在不同的语境中，会有不同的词向量。</p><p>分开训练两个语言模型，即正向语言模型和反向语言模型，将对应字通过正向与反向语言模型得到的vector拼接。</p><p><img src="https://pic3.zhimg.com/80/v2-ac881c5eee80e89020e2e001dfdf9722_720w.jpg" alt="img"></p><h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p>OpenAI Transformer是一类可迁移到多种NLP任务的，基于Transformer的语言模型。它的基本思想同ULMFiT相同，都是在尽量不改变模型结构的情况下将预训练的语言模型应用到各种任务。不同的是，OpenAI Transformer主张用Transformer结构，而ULMFiT中使用的是基于RNN的语言模型。文中所用的网络结构如下：</p><p><img src="https://pic3.zhimg.com/80/v2-8a4cbead57525234c6a33b23c96d18c6_720w.jpg" alt="img"></p><p>模型的训练过程分为两步：</p><ol><li><p>Unsupervised pre-training ：第一阶段的目标是预训练语言模型，给定tokens的语料，目标函数为最大化似然函数：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7B1%7D%28U%29+%3D+%5Csum_%7Bi%7DlogP%28u_%7Bi%7D%7Cu_%7Bi-k%7D%2C+...%2C+u_%7Bi-1%7D%3B%5Ctheta%29+%5C%5C" alt="[公式]"></p><p>该模型中应用multi-head self-attention，并在之后增加position-wise的前向传播层，最后输出一个分布：</p><p><img src="https://www.zhihu.com/equation?tex=h_%7B0%7D%3DUW_%7Be%7D%2BW_%7Bp%7D+%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=h_%7Bl%7D+%3D+transformer_block%28h_%7Bl-1%7D%29++%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=P%28u%29+%3D+softmax%28h_%7Bn%7DW_%7Be%7D%5E%7BT%7D%29+%5C%5C" alt="[公式]"></p></li><li><p>Supervised fine-tuning ：有了预训练的语言模型之后，对于有标签的训练集，给定输入序列$x^1,x^2,…,x^m$和标签$y$，可以通过语言模型得到$h_l^m$，经过输出层后对$y$进行预测：</p><p><img src="https://www.zhihu.com/equation?tex=P%28y%7Cx%5E%7B1%7D%2C...%2Cx%5E%7Bm%7D%29%3Dsoftmax%28h_%7Bl%7D%5E%7Bm%7DW_%7By%7D%29++%5C%5C" alt="[公式]"></p><p>目标函数为：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7B2%7D%28C%29%3D+%5Csum_%7B%28x%2Cy%29%7DlogP%28y%7Cx%5E%7B1%7D...%2Cx%5E%7Bm%7D%29+%5C%5C" alt="[公式]"></p><p>则整个任务的目标函数为：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7B3%7D%28C%29%3D+L_%7B2%7D%28C%29%2B%5Clambda+%2A+L_%7B1%7D%28C%29+%5C%5C" alt="[公式]"></p></li></ol><h2 id="fasttext"><a href="#fasttext" class="headerlink" title="fasttext"></a>fasttext</h2><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>其中$x_1,x_2,…,x_{N-1},x_N$表示一个文本中的n-gram向量，每个特征是词向量的平均值。这和前文中提到的cbow相似，cbow用上下文去预测中心词，而此处<strong>用全部的n-gram去预测指定类别</strong>。</p><h3 id="层次softmax"><a href="#层次softmax" class="headerlink" title="层次softmax"></a>层次softmax</h3><p>对于有大量类别的数据集，fasttext使用了一个分层分类器。不同的类别被整合进树形结构中（想象下二叉树而非 list）。在某些文本分类任务中类别很多，计算线性分类器的复杂度高。为了改善运行时间，fastText 模型使用了层次 Softmax 技巧。层次 Softmax 技巧建立在哈弗曼编码的基础上，对标签进行编码，能够极大地缩小模型预测目标的数量。</p><p>fastText 也利用了<strong>类别（class）不均衡</strong>这个事实（一些类别出现次数比其他的更多），通过使用 Huffman 算法建立用于表征类别的树形结构。因此，<strong>频繁出现类别的树形结构的深度要比不频繁出现类别的树形结构的深度要小</strong>，这也使得进一步的计算效率更高。</p><p>fastText适合类别非常多的分类问题，如果类别比较少，容易过拟合。</p><p>在fastText中，由于最终的输出是预测句子的标签，这是一个监督学习过程，所以在训练过程中已经知道了要计算哪一条路径的概率，这样在计算霍夫曼树的路径时只需要计算一条路径而不用计算全部路径，大大提高了计算效率，而在测试过程中，由于没有标签，不知道真实的路径，仍然需要将霍夫曼树的每一个叶节点对应的路径的概率算出来。</p><p><img src="https://note.youdao.com/yws/api/personal/file/A5695F25596D4311835B2DA25AE8269B?method=download&amp;shareKey=f97031192717a3d0c76c80f649a4344e" alt="image"></p><p>与word2vec的区别：</p><ul><li>相似处：</li></ul><ol><li>图模型结构很像，都是采用embedding向量的形式，得到word的隐向量表达。</li><li>都采用很多相似的优化方法，比如使用Hierarchical softmax优化训练和预测中的打分速度。</li></ol><ul><li>不同处：</li></ul><ol><li>模型的输出层：word2vec的输出层，对应的是每一个term，计算某term的概率最大；而fasttext的输出层对应的是分类的label。不过不管输出层对应的是什么内容，其对应的vector都不会被保留和使用。</li><li>模型的输入层：word2vec的输出层，是 context window 内的term；而fasttext 对应的整个sentence的内容，包括term，也包括 n-gram的内容。</li></ol><ul><li>两者本质的不同，体现在 h-softmax的使用：</li></ul><ol><li>Word2vec的目的是得到词向量，该词向量最终是在输入层得到，输出层对应的 h-softmax也会生成一系列的向量，但最终都被抛弃，不会使用。</li><li>fastText则充分利用了h-softmax的分类功能，遍历分类树的所有叶节点，找到概率最大的label（一个或者N个）</li><li>fastText是是一个文本分类算法，是一个<strong>有监督模型</strong>，有额外标注的标签；CBOW是一个训练词向量的算法，是一个无监督模型，没有额外的标签，其标准是语料本身，无需额外标注。</li></ol><h2 id="ULMFiT-源码值得学习"><a href="#ULMFiT-源码值得学习" class="headerlink" title="ULMFiT 源码值得学习"></a>ULMFiT 源码值得学习</h2><p>ULMFiT是一种有效的NLP迁移学习方法，核心思想是通过精调预训练的语言模型完成其他NLP任务。文中所用的语言模型参考了<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1708.02182" target="_blank" rel="noopener">Merity et al. 2017a</a>的<strong>AWD-LSTM</strong>模型，即没有attention或shortcut的<strong>三层LSTM模型</strong>。</p><p>ULMFit的过程分三步：</p><p><img src="https://pic3.zhimg.com/80/v2-757fc68dcb577afacc6d8a7f635c12ee_720w.jpg" alt="img"></p><ol><li><p>General-domain LM pre-train</p><ul><li><p>在Wikitext-103上进行语言模型的预训练。</p></li><li><p>预训练的语料要求：large &amp; capture general properties of language</p></li><li>预训练对小数据集十分有效，之后仅有少量样本就可以使模型泛化。</li></ul></li><li><p>Target task LM fine-tuning</p><ul><li><p>Discriminative fine-tuning: 因为网络中不同层可以捕获不同类型的信息，因此在精调时也应该使用不同的learning rate。作者为每一层赋予一个学习率$\delta^l$，实验后发现，首先通过精调模型的最后一层L确定学习率$\delta^L$，递推地选择上一层学习率进行精调的效果最好，递推公式为$\delta^{l-1}=\delta^l / 2.6$</p></li><li><p>Slanted triangular learning rates(STLR)</p><p>为了针对特定任务选择参数，理想情况下需要在训练开始时让参数快速收敛到一个合适的区域，之后进行精调。为了达到这种效果，作者提出STLR方法，即让LR在训练初期短暂递增，在之后下降。</p><p><img src="https://img-blog.csdnimg.cn/20190424144737769.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190424144811923.png" alt="img"></p></li><li><p><strong>Target task classifier fine-tuning</strong></p><p>为了完成分类任务的精调，作者在最后一层添加了两个线性block，每个都有batch-norm和dropout，使用ReLU作为中间层激活函数，最后经过softmax输出分类的概率分布。</p></li></ul><p>ULMFit适用领域：分类</p></li></ol><h2 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h2><p><a href="https://zhuanlan.zhihu.com/p/46652512" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46652512</a></p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="https://pic1.zhimg.com/80/v2-d942b566bde7c44704b7d03a1b596c0c_720w.jpg" alt="img"></p><p>对比OpenAI GPT(Generative pre-trained transformer)，BERT是双向的Transformer block连接；就像单向rnn和双向rnn的区别，直觉上来讲效果会好一些。</p><p>对比ELMo，虽然都是“双向”，但目标函数其实是不同的。ELMO是实际上是以$P(w_i|w1,…,w_{i-1})$和$P(w_i|w_{i+1},…w_n)$作为目标函数，独立训练出两个representation然后拼接，而BERT则是以$P(w_i|w_1,…,w_{i-1},w_{i+1},…,w_n)$作为目标函数训练LM。</p><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p>embedding是由三种embedding求和而成：</p><p><img src="https://pic2.zhimg.com/80/v2-11505b394299037e999d12997e9d1789_720w.jpg" alt="img"></p><p>其中：</p><ul><li>Token Embeddings是词向量，第一个单词是<strong>CLS标志</strong>，可以用于之后的分类任务</li><li><strong>Segment Embeddings</strong>用来区别两种句子，因为预训练不光做LM还要做以两个句子为输入的分类任务</li><li><strong>Position Embeddings</strong>和之前文章中的Transformer不一样，不是三角函数而是<strong>学习出来</strong>的</li></ul><h3 id="预训练任务1-Masked-LM"><a href="#预训练任务1-Masked-LM" class="headerlink" title="预训练任务1-Masked LM"></a>预训练任务1-Masked LM</h3><p>第一步预训练的目标就是做语言模型，从上文模型结构中看到了这个模型的不同，即bidirectional。</p><blockquote><p>为什么要这样做bidirectional，作者的解释如下：</p><p>如果使用预训练模型处理其他任务，那人们想要的肯定不止某个词左边的信息，而是左右两边的信息。而考虑到这点的模型ELMo只是将left-to-right和right-to-left分别训练拼接起来。直觉上来讲我们其实想要一个deeply bidirectional的模型，但是普通的LM又无法做到，因为在训练时可能会“穿越”。所以作者用了一个加mask的trick。</p></blockquote><p>在训练过程中作者<strong>随机mask 15%的token</strong>，而不是把像cbow一样把每个词都预测一遍。<strong>最终的损失函数只计算被mask掉那个token。</strong>Mask如何做也是有技巧的，如果一直用标记[MASK]代替（在实际预测时是碰不到这个标记的）会影响模型，所以随机mask的时候10%的单词会被替代成其他单词，10%的单词不替换，剩下80%才被替换为[MASK]。要注意的是Masked LM预训练阶段模型是不知道真正被mask的是哪个词，所以<strong>模型每个词都要关注</strong>。</p><h3 id="预训练任务2-Next-Sentence-Prediction"><a href="#预训练任务2-Next-Sentence-Prediction" class="headerlink" title="预训练任务2-Next Sentence Prediction"></a>预训练任务2-Next Sentence Prediction</h3><p>因为涉及到QA和NLI之类的任务，增加了第二个预训练任务，目的是让模型理解两个句子之间的联系。训练的输入是句子A和B，B有一半的几率是A的下一句，输入这两个句子，<strong>模型预测B是不是A的下一句</strong>。</p><blockquote><p><strong>作者特意说了语料的选取很关键，要选用document-level的而不是sentence-level的，这样可以具备抽象连续长序列特征的能力。</strong></p></blockquote><h3 id="Fine-tunning"><a href="#Fine-tunning" class="headerlink" title="Fine-tunning"></a>Fine-tunning</h3><p>分类：对于sequence-level的分类任务，BERT直接取第一个[CLS]token的final hidden state $C\in \mathbb{R}H$，加一层权重$W$后softmax预测label proba:</p><script type="math/tex; mode=display">P = softmax(CW^T)</script><p>与文本中已有的其它字/词相比，这个无明显语义信息的符号会<strong>更“公平”地融合文本中各个字/词的语义信息</strong>。</p><p><img src="https://pic2.zhimg.com/80/v2-b054e303cdafa0ce41ad761d5d0314e1_720w.jpg" alt="img"></p><h3 id="BERT缺点"><a href="#BERT缺点" class="headerlink" title="BERT缺点"></a>BERT缺点</h3><ol><li>预训练阶段因为采取引入[Mask]标记来Mask掉部分单词的训练模式，而Fine-tuning阶段是看不到这种被强行加入的Mask标记的，所以两个阶段存在使用模式不一致的情形，这可能会带来一定的性能损失；</li><li>Bert在第一个预训练阶段，假设句子中多个单词被Mask掉，这些被Mask掉的单词之间没有任何关系，是条件独立的，而有时候这些单词之间是有关系的，XLNet则考虑了这种关系。</li></ol><h2 id="XLNet"><a href="#XLNet" class="headerlink" title="XLNet"></a>XLNet</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/70257427" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/70257427</a></p><p>针对GPT/ELMO进行对比：使用到的是自回归语言模型（<strong>Autoregressive LM</strong>），即通常所讲的根据上文内容预测下一个可能跟随的单词。GPT 就是典型的自回归语言模型。ELMO尽管看上去利用了上文，也利用了下文，但是本质上仍然是自回归LM。</p><p>针对BERT进行对比：Bert通过在输入X中随机Mask掉一部分单词，然后预训练过程的主要任务之一是根据上下文单词来预测这些被Mask掉的单词，类似这种预训练模式被称为<strong>DAE LM</strong>。其缺点是在输入侧引入[Mask]标记，导致预训练阶段和Fine-tuning阶段不一致的问题，因为Fine-tuning阶段是看不到[Mask]标记的。</p><p>XLNet的出发点就是：<strong>能否融合自回归LM和DAE LM两者的优点</strong>。就是说如果站在自回归LM的角度，如何引入和双向语言模型等价的效果；如果站在DAE LM的角度看，它本身是融入双向语言模型的，如何抛掉表面的那个[Mask]标记，让预训练和Fine-tuning保持一致。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XLNet仍然遵循两阶段的过程，第一个阶段是语言模型预训练阶段；第二阶段是任务数据Fine-tuning阶段。</p><p>它主要希望改动第一个阶段，就是说不像Bert那种带Mask符号的Denoising-autoencoder的模式，而是采用自回归LM的模式。也就是，<strong>能够比较充分地在自回归语言模型中，引入双向语言模型</strong>。即看上去输入句子$X$仍然是自左向右的输入，看到$T_i$单词的上文context_before，来预测$T_i$这个单词；但又希望在context_before里，不仅仅看到上文单词，也能看到$T_i$单词后面的下文context_after中的下文单词。</p><h3 id="Permutation-Language-Model"><a href="#Permutation-Language-Model" class="headerlink" title="Permutation Language Model"></a>Permutation Language Model</h3><p>这个部分是XLNet的主要理论创新。</p><p>如何解决的思路：XLNet在预训练阶段，引入Permutation Language Model的训练目标。即，比如包含单词$T_i$的当前输入句子$X$，由顺序的几个单词构成，比如$x_1,x_2,x_3,x_4$四个单词顺序构成。我们假设，要预测的单词$T_i$是$x_3$，位置在position 3，我们希望在context_before中也能看到position 4的单词$x_4$。因此可以这么做：<strong>假设我们固定住$x_3$所在位置，然后随机排列组合句子中的4个单词，在随机排列组合后的各种可能里再选择一部分作为模型预训练的输入$X$。</strong> 比如，随机排列组合后，抽取出$x_4,x_2,x_3,x_1$这一个排列组合作为模型的输入$X$。这就是XLNet的基本思想。</p><p>难点是如何实现上述思想：首先要强调，尽管上面讲的是把句子X的单词排列组合后，再随机抽取例子作为输入，但是，实际上你是不能这么做的，因为<strong>Fine-tuning阶段你不可能也去排列组合原始输入</strong>。所以，必须让预训练阶段的输入部分，看上去仍然是x1,x2,x3,x4这个输入顺序，但是可以在Transformer部分做些工作，来达成希望的目标。其实，就是利用了Transformer内部的<strong>Attention mask</strong>掩码。通过Attention Mask，把其它没有被选到的单词Mask掉，不让它们在预测单词Ti的时候发生作用，如此而已。一个简单图示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-4cbf76012c776bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>假设随机的一种生成顺序为“\<s>-&gt;迎-&gt;京-&gt;你-&gt;欢-&gt;北-&gt;\<e>“，那么可以使用上图第二个子图中的方式去Mask掉Attention矩阵。这个训练方案源于纯Attention的模型本质上是一个无序的模型，它里边的词序实际上是通过position embedding加上去的。因此实际上，我们输入的不仅只有token本身，还包括token所在位置id。</e></s></p><p><img src="https://pic1.zhimg.com/80/v2-2bb1a60af4fe2fa751647fdce48e337c_720w.jpg" alt="img"></p><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><blockquote><p>XLNet开启了自回归语言模型如何引入下文的一个思路，相信对于后续工作会有启发。当然，XLNet不仅仅做了这些，它还引入了其它的因素，也算是一个当前有效技术的集成体。</p><p>感觉XLNet就是Bert、GPT 2.0和Transformer XL的综合体变身，首先，它通过PLM预训练目标，吸收了Bert的双向语言模型；然后，GPT2.0的核心其实是更多更高质量的预训练数据，这个明显也被XLNet吸收进来了；再然后，Transformer XL的主要思想也被吸收进来，它的主要目标是解决Transformer对于长文档NLP应用不够友好的问题。</p></blockquote><h3 id="与BERT的预训练过程的异同"><a href="#与BERT的预训练过程的异同" class="headerlink" title="与BERT的预训练过程的异同"></a>与BERT的预训练过程的异同</h3><blockquote><p> 区别主要在于：Bert是直接在<strong>输入端显示</strong>地通过引入Mask标记，在输入侧隐藏掉一部分单词，让这些单词在预测的时候不发挥作用，要求利用上下文中其它单词去预测某个被Mask掉的单词；而XLNet则抛弃掉输入侧的Mask标记，通过Attention Mask机制，在<strong>Transformer内部</strong>随机Mask掉一部分单词（这个被Mask掉的单词比例跟当前单词在句子中的位置有关系，位置越靠前，被Mask掉的比例越高，位置越靠后，被Mask掉的比例越低），让这些被Mask掉的单词在预测某个单词的时候不发生作用。本质上两者并没什么太大的不同，只是Mask的位置，<strong>Bert更表面化一些，XLNet则把这个过程隐藏在了Transformer内部而已</strong>。这样，就可以抛掉表面的[Mask]标记，解决它所说的<strong>预训练里带有[Mask]标记导致的和Fine-tuning过程不一致的问题</strong>。</p><p>XLNet这种改造，维持了表面看上去的自回归语言模型的从左向右的模式，这个Bert做不到，这个有明显的好处，就是对于<strong>生成类</strong>的任务，能够在维持表面从左向右的生成过程前提下，模型里隐含了上下文的信息。所以看上去，XLNet貌似应该对于生成类型的NLP任务，会比Bert有明显优势。另外，因为XLNet还引入了Transformer XL的机制，所以对于长文档输入类型的NLP任务，也会比Bert有明显优势。</p></blockquote><h3 id="XLNet起作用的三个因素"><a href="#XLNet起作用的三个因素" class="headerlink" title="XLNet起作用的三个因素"></a>XLNet起作用的三个因素</h3><ol><li>新的预训练目标：Permutation Language Model。这个可以理解为在自回归LM模式下，如何采取具体手段，来融入<strong>双向语言模型</strong>。这个是XLNet在模型角度比较大的贡献，确实也打开了NLP中两阶段模式潮流的一个新思路。</li><li>引入了<strong>Transformer-XL</strong>的主要思路：<strong>相对位置编码以及分段RNN机制</strong>。实践已经证明这两点对于长文档任务是很有帮助的；</li><li>加大增加了预训练阶段使用的数据规模；</li></ol><p>接下来摘抄一下张俊林老师的结论：</p><blockquote><p>XLNet综合而言，效果是优于Bert的，尤其是在长文档类型任务，效果提升明显。Bert生成做不好根本还是预训练的mask模式同时看到上文和下文，decoder没法达到这一点，原因应该还是在mask这种模式上.</p></blockquote><h2 id="ALBERT"><a href="#ALBERT" class="headerlink" title="ALBERT"></a>ALBERT</h2><p>参考：<a href="https://blog.csdn.net/u012526436/article/details/101924049" target="_blank" rel="noopener">https://blog.csdn.net/u012526436/article/details/101924049</a></p><h3 id="相对于BERT的改进"><a href="#相对于BERT的改进" class="headerlink" title="相对于BERT的改进"></a>相对于BERT的改进</h3><p>ALBERT也是采用和BERT一样的Transformer的encoder结果，激活函数使用的也是GELU。我们规定几个参数，词的embedding我们设置为E，encoder的层数我们设置为L，hidden size即encoder的输出值的维度我们设置为H，前馈神经网络的节点数设置为4H，attention的head个数设置为H/64。</p><p>在ALBERT中主要有三个改进方向。</p><h4 id="对Embedding因式分解"><a href="#对Embedding因式分解" class="headerlink" title="对Embedding因式分解"></a>对Embedding因式分解</h4><p>在BERT中，词embedding与encoder输出的embedding维度是一样的都是768。但是ALBERT认为，词级别的embedding是没有上下文依赖的表述，而隐藏层的输出值不仅包括了词本生的意思还包括一些上下文信息，<strong>理论上来说隐藏层的表述包含的信息应该更多一些，因此应该让H&gt;&gt;E</strong>，所以ALBERT的词向量的维度是小于encoder输出值维度的。</p><p>在NLP任务中，通常词典都会很大，embedding matrix的大小是E×V，如果和BERT一样让H=E，那么embedding matrix的参数量会很大，并且反向传播的过程中，更新的内容也比较稀疏。</p><p>结合上述说的两个点，ALBERT采用了一种因式分解的方法来降低参数量。首先把one-hot向量映射到一个低维度的空间，大小为E，然后再映射到一个高维度的空间，说白了就是<strong>先经过一个维度很低的embedding matrix，然后再经过一个高维度matrix把维度变到隐藏层的空间内</strong>，从而把参数量从O(V×H)降低到了O(V×E+E×H)，当E&lt;&lt;H时参数量减少的很明显。</p><h4 id="跨层的参数共享（Cross-layer-parameters）"><a href="#跨层的参数共享（Cross-layer-parameters）" class="headerlink" title="跨层的参数共享（Cross-layer parameters）"></a>跨层的参数共享（Cross-layer parameters）</h4><p>在ALBERT还提出了一种参数共享的方法，Transformer中共享参数有多种方案，只共享全连接层，只共享attention层，ALBERT结合了上述两种方案，全连接层与attention层都进行参数共享，也就是说<strong>共享encoder内的所有参数</strong>，同样量级下的Transformer采用该方案后实际上效果是有下降的，但是参数量减少了很多，训练速度也提升了很多。</p><h4 id="句间连贯（Inter-sentence-coherence-loss）"><a href="#句间连贯（Inter-sentence-coherence-loss）" class="headerlink" title="句间连贯（Inter-sentence coherence loss）"></a>句间连贯（Inter-sentence coherence loss）</h4><p>BERT的NSP任务实际上是一个<strong>二分类</strong>，训练数据的正样本是通过采样同一个文档中的两个连续的句子，而负样本是通过采用两个不同的文档的句子。该任务主要是希望能提高下游任务的效果，例如NLI自然语言推理任务。但是后续的研究发现该任务效果并不好，主要原因是因为其任务过于简单。NSP其实包含了两个子任务，主题预测与关系一致性预测，但是主题预测相比于关系一致性预测简单太多了，并且在MLM任务中其实也有类型的效果。</p><p>在ALBERT中，为了只保留一致性任务去除主题识别的影响，提出了一个新的任务 sentence-order prediction（SOP）。SOP因为是在同一个文档中选的，其只关注句子的顺序并没有主题方面的影响。并且SOP能解决NSP的任务，但是NSP并不能解决SOP的任务，该任务的添加给最终的结果提升了一个点。</p><h4 id="移除dropout"><a href="#移除dropout" class="headerlink" title="移除dropout"></a>移除dropout</h4><p>ALBERT在训练了100w步之后，模型依旧没有过拟合，于是乎作者果断移除了dropout，没想到对下游任务的效果竟然有一定的提升。这也是业界第一次发现dropout对大规模的预训练模型会造成负面影响。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ALBERT实际上是通过参数共享的方式降低了内存，预测阶段还是需要和BERT一样的时间，如果采用了xxlarge版本的ALBERT，那实际上预测速度会更慢。</p><p>ALBERT解决的是<strong>训练时候的速度提升</strong>，如果要真的做到总体运算量的减少，的确是一个复杂且艰巨的任务，毕竟鱼与熊掌不可兼得。不过话说回来，ALBERT也更加适合采用feature base或者模型蒸馏等方式来提升最终效果。</p><h2 id="Transformer-XL"><a href="#Transformer-XL" class="headerlink" title="Transformer-XL"></a>Transformer-XL</h2><ol><li>XL是”extra-long”的意思，即Transformer-XL做了长度延伸的工作；</li><li><strong>Transformer</strong>规定输入大小为512，原始的输入需要进行裁剪或者填充，即将一个长的文本序列截断为几百个字符的固定长度片段，然后分别处理每个片段；这存在着文章跨片段依赖不能学习到的问题，也<strong>限制了长距离依赖</strong>。因此，提出Transformer-XL。</li><li>Transformer-XL所做改进：<ul><li>与Transformer的基本思路相同，Transformer-XL仍然是使用分段的方式进行建模，但其的本质不同时引入了段与段之间的循环机制，使得当前段在建模的时候能够利用之前段的信息来实现长期依赖性。（简略版：使用分段RNN且存储上一次处理的片段信息）</li><li>为了适应分段的情况，提出了相对位置编码方案。</li></ul></li></ol><h2 id="ERNIE-百度"><a href="#ERNIE-百度" class="headerlink" title="ERNIE(百度)"></a>ERNIE(百度)</h2><p>主要改进是在mask的机制上做了改进，它的mask不是基本的word piece的mask，而是在pretraining阶段增加了外部的知识，由三种level的mask组成，分别是<code>basic-level masking(word piece)</code>+<code>phrase level masking(WWM style)</code> + <code>entity level masking</code>。在此基础上，借助百度在中文社区的强大能力，中文的ERNIE还使用了各种异质的数据集。另外为了适应多轮的贴吧数据，所以ERNIE引入了DLM(Dialogue Language Model)任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-3247b61cea43bf2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="Knowledge-masking"><a href="#Knowledge-masking" class="headerlink" title="Knowledge masking"></a>Knowledge masking</h3><p>ERNIE的mask的策略是通过三个阶段学习的，在第一个阶段，采用的是BERT的模式，用的是basic-level masking，然后加入词组的mask(phrase-level masking)，然后再加入实体级别(entity-level的mask)。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-545f3007389343a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="Heterogeneous-Corpus-Pre-training"><a href="#Heterogeneous-Corpus-Pre-training" class="headerlink" title="Heterogeneous Corpus Pre-training"></a>Heterogeneous Corpus Pre-training</h3><p>训练集包括：Chinese Wiki, Baidu Baike, Baidu news, Baidu Tieba.</p><h3 id="DLM-Dialogue-Language-Model-task"><a href="#DLM-Dialogue-Language-Model-task" class="headerlink" title="DLM(Dialogue Language Model) task"></a>DLM(Dialogue Language Model) task</h3><p>对话的数据对语义表示很重要，因为对于相同回答的提问一般都是具有类似语义的，ERNIE修改BERT的输入形式，使之能够使用多轮对话的形式，采用的是三个句子的组合<code>[CLS]S1[SEP]S2[SEP]S3[SEP]</code>的格式。这种组合可以表示多轮对话，例如QRQ、QRR、QQR。为了表示dialogue的属性，句子添加了dialog embedding组合，这个和segment embedding很类似。</p><ul><li><img src="https://upload-images.jianshu.io/upload_images/8636110-ab53db66abbab24b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>DLM还增加了任务来判断这个多轮对话是真的还是假的。</li></ul><h3 id="NSP-MLM"><a href="#NSP-MLM" class="headerlink" title="NSP+MLM"></a>NSP+MLM</h3><p>在贴吧外多轮对话数据外都采用普通的NSP+MLM的预训练任务。</p><h2 id="ERNIE2-0"><a href="#ERNIE2-0" class="headerlink" title="ERNIE2.0"></a>ERNIE2.0</h2><p><code>动机</code>：在学习一个新语言的时候，我们需要很多之前的知识，在这些知识的基础上，我们可以获取对其他的任务的学习有<strong>迁移学习</strong>的效果。百度不满足于堆叠任务，而是提出了一个持续学习的框架。利用这个框架，模型可以持续添加任务但又不降低之前任务的精度，从而能够更好更有效地获得词法lexical、句法syntactic和语义semantic上的表达。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-8b177ea9b63c246f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>其在ERNIE1.0的基础上，利用大量数据和先验知识，提出了多个任务，用来做预训练，最后根据特定任务fine-tune。框架的提出是针对life-long learning，即终生学习，因为我们的任务叠加不是一次性进行的(multi-tasking learning)，而是持续学习(continual pretraining)。因此为避免模型在学了新的任务后忘记旧任务，即旧的任务上loss变高，因此百度提出了一个包含pretraining和fine-tuning的持续学习框架。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-2c625bc1afb89f31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="Continual-pre-training"><a href="#Continual-pre-training" class="headerlink" title="Continual pre-training"></a>Continual pre-training</h3><ul><li><p>任务的构建</p><p>百度把语言模型的任务归为三大类，包括字层级的任务(word-aware pretraining)、句结构层级的任务(structure-aware pretraining task)和语义层级的任务(semantic-aware pretraining task)。</p></li><li><p>持续的多任务学习</p><p>需要攻克两个难点：</p><ol><li>如何保证模型不忘记之前的任务：常规的持续学习框架采用的是一个任务接一个任务的训练，这样导致的后果是模型在最新的任务上得到了好效果但在之前的任务获得差效果(knowledge retention)。</li><li>模型如何有效地训练：有人提出有新的任务进行，则从头开始训练一个新模型，但这样效率很低。</li></ol><p>百度提出的方案（sequential multi-task learning）：复用之前学到的模型的参数作为初始化，然后再训练。但这样似乎训练效率不够高，因为我们还是要每一轮都要同时训练多个任务。因此百度的解决方案是：框架自动在训练的过程中为每个任务安排训练N轮。</p><ul><li>初始化optimized initialization: 每次有新任务过来，持续学习的框架使用的之前学习到的模型参数作为初始化，然后将新的任务与旧的任务一起训练；</li><li>训练任务安排task allocating: 对于多个任务，框架将自动地为每个任务在模型训练的不同阶段安排N个训练轮次，这样保证了有效率地学习到多任务。（部分任务的语义信息建模适合递进式，比如ernie1.0突破完形填空，ernie2.0突破选择题、句子排序题等，适合递进式的语音建模任务。）</li></ul></li></ul><h3 id="Continual-Fine-tuning"><a href="#Continual-Fine-tuning" class="headerlink" title="Continual Fine-tuning"></a>Continual Fine-tuning</h3><p>在模型预训练完成后，可以根据特定任务进行fine-tuning，这个和BERT一样。</p><h3 id="模型架构-1"><a href="#模型架构-1" class="headerlink" title="模型架构"></a>模型架构</h3><p><img src="https://upload-images.jianshu.io/upload_images/8636110-2aff5b382101d278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>模型的结构和BERT一致，但在预训练的阶段，除了正常的position embedding、segment embedding，token embedding外，还增加了<code>task embedding</code>，用来区分训练的任务。但在fine-tuning阶段，可以使用任意值作为初始化。</p><h3 id="Pre-training-tasks"><a href="#Pre-training-tasks" class="headerlink" title="Pre-training tasks"></a>Pre-training tasks</h3><ul><li>词法级别任务：大小写预测(对NER有用)、词频关系</li><li>语法级别任务：句子排序，让模型预测文章的句子属于哪种排序组合，就是多分类问题；句子距离预测：三分类问题（相邻，相同文章但不相邻，不同文章）</li><li>语义级别任务：三分类问题，0代表提问和标题强相关，1代表弱相关，2代表不相关</li><li>篇章句间关系任务：判断句子的语义关系，例如logical relationship。</li><li>信息检索关系任务：三分类。同语义级别。</li></ul><p>模型输出：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-734f9c6738cb6ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: 预训练语言模型&lt;br&gt;date: 2020-02-25 15:46:28&lt;br&gt;categories: NLP&lt;/p&gt;
&lt;p&gt;本文记录一些关于预训练语言模型讲解比较好的中文博客，有时间再补充自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;预训练方式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Attention机制-NLP领域小结</title>
    <link href="https://github.com/DesmonDay/2020/02/20/Attention%E6%9C%BA%E5%88%B6-NLP%E9%A2%86%E5%9F%9F%E5%B0%8F%E7%BB%93/"/>
    <id>https://github.com/DesmonDay/2020/02/20/Attention机制-NLP领域小结/</id>
    <published>2020-02-20T15:42:25.000Z</published>
    <updated>2020-02-23T16:09:27.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Attention用于NLP的小结"><a href="#Attention用于NLP的小结" class="headerlink" title="Attention用于NLP的小结"></a>Attention用于NLP的小结</h1><p>基本转载susht师姐的知乎博文，真是优秀的师姐啊，向她学习！</p><p><a href="https://zhuanlan.zhihu.com/p/35739040" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35739040</a></p><p><img src="https://pic1.zhimg.com/80/v2-ef2e241114ab58a033e31f76b598a898_hd.jpg" alt="img"></p><p>定义：参考<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention is All You Need</a>中的说法，假设当前时刻t下，我们有一个query向量，和一段key向量，这里query可以理解为一个包含比较多信息的全局向量，我们利用这个query对所有key向量进行加权求和，学习到一个更合适的新向量去做分类或者预测等任务。</p><p>假设$q_t$是时刻$t$下的query，$K$是key，$k_s$是其中一个key向量，$v$是value矩阵。我们先对$q_t$$和每个key进行相似度计算得到一个非归一化的score分数：</p><script type="math/tex; mode=display">s(q_t,k_s)=\frac{<q_t,k_s>}{\sqrt{d_k}}</script><p>这里用到了点乘，分母则是为了调整内积结果，使得内积不那么大，避免softmax结果过于专一。然后对score进行softmax归一化，作为attention概率权重：</p><script type="math/tex; mode=display">a(q_t,k_s) = \frac{exp(s(q_t,k_s))}{\sum_{i=1}^N exp(s(q_t,k_i))}​</script><p>最后我们对每个位置key所对应的权重和value进行加权求和，得到最终的输出向量：</p><script type="math/tex; mode=display">Attention(q_t,K,V)=\sum_{s=1}^ma(q_t,k_s)v_s</script><p>对应到具体任务上可以理解更加清晰：</p><ol><li>在机器翻译任务中，query可以定义成decoder中某一步的hidden state，key是encoder中每一步的hidden state，我们用每一个query对所有key都做一个对齐，decoder每一步都会得到一个不一样的对齐向量。</li><li>在文本分类任务中，query可以定义成一个可学的随机变量（参数），key就是输入文本每一步的hidden state，通过加权求和得到句向量，再进行分类。Attention机制用在文本分类中，我们可以看做是对句子进行加权，提高重要词语的注意力，减小其它词语的关注度。</li></ol><h2 id="根据Attention的计算区域"><a href="#根据Attention的计算区域" class="headerlink" title="根据Attention的计算区域"></a>根据Attention的计算区域</h2><ol><li>Soft Attention: 这是比较常见的Attention方式，对所有key求权重概率，每个key都有一个对应的权重，是一种全局的计算方式（也可以叫Global Attention）</li><li>Hard Attention: 这种方式是直接精准定位到某个key，其余key就都不管了，相当于这个key的概率是1，其余key的概率全部是0。因此这种对齐方式要求很高，要求一步到位，如果没有正确对齐，会带来很大的影响。另一方面，因为不可导，一般需要用强化学习的方法进行训练。（或者使用gumbel softmax之类的）</li><li><strong>Local</strong> Attention，这种方式其实是以上两种方式的一个折中，对一个窗口区域进行计算。先用Hard方式定位到某个地方，以这个点为中心可以得到一个窗口区域，在这个小区域内用Soft方式来算Attention。</li></ol><h2 id="根据Attention的所用信息"><a href="#根据Attention的所用信息" class="headerlink" title="根据Attention的所用信息"></a>根据Attention的所用信息</h2><p>假设我们要对一段原文计算Attention，这里原文指的是我们要做attention的文本，那么所用信息包括内部信息和外部信息，内部信息指的是原文本身的信息，而外部信息指的是除原文以外的额外信息：</p><ol><li><strong>General</strong> Attention：这种方式利用到了外部信息，常用于需要构建两段文本关系的任务，query一般包含了额外信息，根据外部query对原文进行对齐。</li><li><strong>Local</strong> Attention：这种方式只使用内部信息，key和value以及query只和输入原文有关，在<strong>self attention</strong>中，key=value=query。既然没有外部信息，那么在原文中的每个词可以跟该句子中的所有词进行Attention计算，相当于寻找原文内部的关系。</li></ol><h2 id="根据Attention的结构层次"><a href="#根据Attention的结构层次" class="headerlink" title="根据Attention的结构层次"></a>根据Attention的结构层次</h2><p>分为单层attention，多层attention和多头attention:</p><ol><li>单层Attention，这是比较普遍的做法，用一个query对一段原文进行一次attention。</li><li>多层Attention，一般用于<strong>文本具有层次关系(比如包括多个句子的文档)</strong>的模型，假设我们把一个document划分成多个句子，在第一层，我们分别对每个句子使用attention计算出一个句向量（也就是单层attention）；在第二层，我们对所有句向量再做attention计算出一个文档向量（也是一个单层attention），最后再用这个文档向量去做任务。</li><li>多头Attention，这是Attention is All You Need中提到的multi-head attention，用到了多个query对一段原文进行了多次attention，每个query都关注到原文的不同部分，相当于<strong>重复做多次单层attention</strong>。</li></ol><h2 id="从模型方面看"><a href="#从模型方面看" class="headerlink" title="从模型方面看"></a>从模型方面看</h2><p>Attention一般用在CNN和LSTM上，也可以直接进行纯Attention计算:</p><ol><li><p>CNN+Attention: </p><p>CNN的卷积操作可以提取重要特征，也算是Attention的思想，但是CNN的卷积感受视野是局部的，需要通过<strong>叠加多层卷积区</strong>去扩大视野。另外，Max Pooling直接提取数值最大的特征，也像是<strong>hard attention</strong>的思想，直接选中某个特征。</p><p>可以应用这几个方面：</p><ul><li>在卷积操作前做attention，比如Attention-Based BCNN-1，这个任务是文本蕴含任务需要处理两段文本，同时对两段输入的序列向量进行attention，计算出特征向量，再拼接到原始向量中，作为卷积层的输入。</li><li>在卷积操作后做attention，比如Attention-Based BCNN-2，对两段文本的卷积层的输出做attention，作为pooling层的输入。</li><li>在pooling层做attention，代替max pooling。比如<strong>Attention pooling</strong>，首先我们用LSTM学到一个比较好的句向量，作为query，然后用CNN先学习到一个特征矩阵作为key，再用query对key产生权重，进行attention，得到最后的句向量。</li></ul></li><li><p>LSTM+Attention</p><p>LSTM内部有Gate机制，其中input gate选择哪些当前信息进行输入，forget gate选择遗忘哪些过去信息，这算是一定程度的Attention了，而且号称可以解决长期依赖问题，实际上LSTM需要一步一步去捕捉序列信息，在长文本上的表现是会随着step增加而慢慢衰减，难以保留全部的有用信息。</p><p>LSTM通常需要得到一个向量，再去做任务，常用的方式有：</p><ul><li>直接使用最后的hidden state(可能会损失一定的前文信息，难以表达全文)</li><li>对所有step下的hidden state进行等权平均（对所有step一视同仁）</li><li>Attention机制，对所有step的hidden state进行加权，把注意力集中到整段文本中比较重要的hidden state信息。性能比前面两种要好一点，而方便可视化观察哪些step是重要的，但是要小心过拟合，而且也增加了计算量。</li></ul></li><li><p><strong>纯Attention</strong>: Attention is all you need，没有用到CNN/RNN，乍一听也是一股清流了，但是仔细一看，本质上还是一堆向量去计算attention。  </p></li></ol><h2 id="相似度计算方式"><a href="#相似度计算方式" class="headerlink" title="相似度计算方式"></a>相似度计算方式</h2><p>做attention时，我们需要计算query和某个key的相似度（分数），常用的方法有：</p><ol><li>点乘：最简单的方法，$s(q,k) = q^Tk$</li><li>矩阵相乘：$s(q,k)=q^TWk$</li><li>cos相似度：$s(q,k)=\frac{q^Tk}{||q||\cdot||k||}$</li><li>串联方式：把q,k拼接起来，$s(q,k)=W[q;k]$</li><li>用多层感知机：$s(q,k)=v^T_atanh(Wq+Uk)$</li></ol><h2 id="Attention适合的任务"><a href="#Attention适合的任务" class="headerlink" title="Attention适合的任务"></a>Attention适合的任务</h2><ol><li>长文本任务：document级别，因为长文本本身所携带的信息量比较大，可能会带来信息过载问题，很多任务可能只需要用到其中一些<strong>关键信息</strong>（比如文本分类），所以Attention机制用在这里正适合capture这些关键信息。</li><li><strong>涉及到两段的相关文本</strong>，可能会需要对两段内容进行对齐，找到这两段文本之间的一些相关关系。比如机器翻译，将英文翻译成中文，英文和中文明显是有对齐关系的，Attention机制可以找出，在翻译到某个中文字的时候，需要对齐到哪个英文单词。又比如阅读理解，给出问题和文章，其实问题中也可以对齐到文章相关的描述，比如“什么时候”可以对齐到文章中相关的时间部分。</li><li>任务很大部分取决于<strong>某些特征</strong>。我举个例子，比如在AI+法律领域，根据初步判决文书来预测所触犯的法律条款，在文书中可能会有一些罪名判定，而这种特征对任务是非常重要的，所以用Attention来capture到这种特征就比较有用。（CNN也可以）</li></ol><p>常见的task:</p><ol><li>机器翻译：encoder用于对原文建模，decoder用于生成译文，attention用于连接原文和译文，在每一步翻译的时候关注不同的原文信息。</li><li>摘要生成：encoder用于对原文建模，decoder用于生成新文本，从形式上和机器翻译都是seq2seq任务，但是从任务特点上看，机器翻译可以具体对齐到某几个词，但这里是由长文本生成短文本，decoder可能需要capture到encoder更多的内容，进行总结。（对话系统也可）</li><li>图文互搜：encoder对图片建模，decoder生成相关文本，在decoder生成每个词的时候，用attention机制来关注图片的不同部分。</li><li>文本蕴含：判断前提和假设是否相关，attention机制用来对前提和假设进行对齐。</li><li>阅读理解：可以对文本进行self attention，也可以对文章和问题进行对齐。</li><li>文本分类：一般是对一段句子进行attention，得到一个句向量去做分类。</li><li>序列标注：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1712.01586" target="_blank" rel="noopener">Deep Semantic Role Labeling with Self-Attention</a>，这篇论文在softmax前用到了self attention，学习句子结构信息，和利用到标签依赖关系的CRF进行pk。</li><li>关系抽取：也可以用到self attention</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我这次参加了百度常规赛：知识驱动对话，也是利用了Attention作为decoder的一部分，比赛效果还可以。之后再写一篇文章作为总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Attention用于NLP的小结&quot;&gt;&lt;a href=&quot;#Attention用于NLP的小结&quot; class=&quot;headerlink&quot; title=&quot;Attention用于NLP的小结&quot;&gt;&lt;/a&gt;Attention用于NLP的小结&lt;/h1&gt;&lt;p&gt;基本转载susht师
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>特征工程</title>
    <link href="https://github.com/DesmonDay/2020/02/19/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <id>https://github.com/DesmonDay/2020/02/19/特征工程/</id>
    <published>2020-02-19T13:20:53.000Z</published>
    <updated>2020-02-19T13:55:09.773Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记参考二水马的rebirth。</p><h1 id="1-特征选择"><a href="#1-特征选择" class="headerlink" title="1. 特征选择"></a>1. 特征选择</h1><h2 id="1-1-特征来源"><a href="#1-1-特征来源" class="headerlink" title="1.1 特征来源"></a>1.1 特征来源</h2><ol><li>业务已整理好的数据，需要找出适合问题的特征</li><li>高级特征，需要从业务特征中去寻找⾼级数据特征</li></ol><h2 id="1-2-选择合适的特征"><a href="#1-2-选择合适的特征" class="headerlink" title="1.2 选择合适的特征"></a>1.2 选择合适的特征</h2><p>第⼀步是找到该领域懂业务的<strong>专家</strong>，让他们给⼀些建议，这些特征就是我们的特征的第⼀候选集。</p><p>在尝试降维之前，有必要用特征工程的方法选择出较重要的特征结合，这些方法不会用到领域知识，而仅是统计学的方法。</p><p>特征选择方法一般分为三类：</p><ul><li><p>过滤法选择特征</p><ol><li><strong>方差筛选</strong>：方差越大的特征，则认为是比较有用；若方差较小，如小于1，则该特征对算法作用没那么大。若某特征方差为0，则其所有样本的特征取值相同，应当舍弃该特征。实际应用中，应指定方差阈值，当方差小于该阈值特征则筛选掉。</li><li><strong>相关系数</strong>：主要⽤于输出连续值的监督学习算法中。我们分别计算所有训练集中各个特征与输出值之间的相关系数，设定⼀个阈值，选择相关系数较⼤的部分特征。</li><li>假设检验：如卡方检验。卡方检验可以检验某个特征分布和输出值分布之间的相关性。除此之外，还可以用F检验和t检验。</li><li>互信息：从信息熵角度分析各个特征和输出值之间的关系评分。互信息值越大，说明该特征和输出值之间的相关性越⼤，越需要保留。</li></ol></li><li><p>包装法选择特征</p><p>思想是选择⼀个⽬标函数来⼀步步的筛选特征。最常⽤的包装法是递归消除特征法(recursive feature elimination, 以下简称RFE)。递归消除特征法使⽤⼀个机器学习模型来进⾏多轮训练，每轮训练后，消除若干权值系数的对应的特征，再基于新的特征集进⾏下⼀轮训练。</p><p>经典方法：SVM-RFE方法。以⽀持向量机来做RFE 的机器学习模型选择特征，假设有n 个特征。</p><ol><li>它在第⼀轮训练的时候，会选择所有的特征来训练，得到分类的超平⾯$wx+b$；</li><li>选择出$w$中分量的平⽅值$w_i^2$最小的那个序号$i$对应的特征，将其排除；</li><li>对剩下的$n-1$个特征和输出值，重新训练SVM，直到剩下的特征数满足需求。</li></ol></li><li><p>嵌入法选择特征</p><ol><li>使⽤全部特征，使⽤L1 正则化和L2 正则化来选择特征。正则化惩罚项越⼤，那么模型的系数就会越⼩。</li><li>当正则化惩罚项⼤到⼀定的程度的时候，部分特征系数会变成0，当正则化惩罚项继续增⼤到⼀定程度时，所有的特征系数都会趋于0。⼀部分特征系数会更容易先变成0，这部分系数就是可以筛掉的。即选择特征系数较⼤的特征。</li><li>⽤的L1 正则化和L2 正则化来选择特征的基学习器是逻辑回归，此外也可以使⽤决策树或者GBDT。</li><li>可以得到特征系数coef或者得到特征重要度(feature importances)的算法才可以作为嵌入法的基学习器。</li></ol></li></ul><h2 id="1-3-寻找高级特征（交叉特征）"><a href="#1-3-寻找高级特征（交叉特征）" class="headerlink" title="1.3 寻找高级特征（交叉特征）"></a>1.3 寻找高级特征（交叉特征）</h2><p>⽐如有车的路程特征和时间间隔特征，我们就可以得到车的平均速度这个⼆级特征。根据车的速度特征，我们就可以得到车的加速度这个三级特征，根据车的加速度特征，我们就可以得到车的加加<br>速度这个四级特征。也就是说，⾼级特征可以⼀直寻找下去。</p><ol><li>特征加和：计算累积</li><li>特征之差：计算增量</li><li>特征乘积：价格与销量得到营业额</li><li>特征除商：销售额除以商品数量得到均价</li></ol><h2 id="1-4-特征选择小结"><a href="#1-4-特征选择小结" class="headerlink" title="1.4 特征选择小结"></a>1.4 特征选择小结</h2><p>特征选择是特征⼯程的第⼀步，它关系到机器学习算法的上限。因此原则是<strong>尽量不错过⼀个可能有⽤的特征，但是也不滥⽤太多的特征</strong>。</p><h1 id="2-特征表达"><a href="#2-特征表达" class="headerlink" title="2. 特征表达"></a>2. 特征表达</h1><h2 id="2-1-缺失值处理"><a href="#2-1-缺失值处理" class="headerlink" title="2.1 缺失值处理"></a>2.1 缺失值处理</h2><p>连续值：均值填充、中位数填充</p><p>离散值：选择所有有该特征值的样本中出现最频繁的类别值，填充缺失值。</p><h2 id="2-2-特殊特征处理"><a href="#2-2-特殊特征处理" class="headerlink" title="2.2 特殊特征处理"></a>2.2 特殊特征处理</h2><ol><li>日期时间<ul><li><strong>时间差值法</strong>：计算出所有样本的时间到某⼀个未来时间（或过去时间）之间的数值差距，转换成<strong>连续值</strong>；</li><li><strong>细分特征</strong>：年、⽉、⽇、周、时，将⼀个时间特征转化为若⼲个<strong>离散特征</strong>，这种⽅法在分析具有明显时间趋势的问题⽐较好⽤。</li><li><strong>权重法</strong>：即根据时间的新旧得到⼀个权重值。⽐如对于商品，三个⽉前购买的设置⼀个较低的权重，最近三天购买的设置⼀个中等的权重，在三个⽉内但是三天前的设置⼀个较⼤的权重。还有其他的设置权重的⽅法，这个要根据要解决的问题来灵活确定。</li></ul></li><li>地理位置<ul><li>细分特征：城市、区县、街道</li><li>经纬度：如果需要判断用户分布区域，一般处理成连续值比较好，这时可以将地址处理成经度和纬度的连续特征。</li></ul></li></ol><h2 id="2-3-离散特征的连续化处理"><a href="#2-3-离散特征的连续化处理" class="headerlink" title="2.3 离散特征的连续化处理"></a>2.3 离散特征的连续化处理</h2><ol><li>one-hot向量</li><li>embedding</li></ol><h2 id="2-4-离散特征的离散化处理"><a href="#2-4-离散特征的离散化处理" class="headerlink" title="2.4 离散特征的离散化处理"></a>2.4 离散特征的离散化处理</h2><ol><li>one-hot向量</li><li>dummy coding</li><li>根据背景知识划分：⽐如，商品的销量对应的特征，原始特征是季节春夏秋冬。可以将其转化为淡季和旺季这样的⼆值特征，⽅便建模。</li></ol><h2 id="2-5-连续特征的离散化处理"><a href="#2-5-连续特征的离散化处理" class="headerlink" title="2.5 连续特征的离散化处理"></a>2.5 连续特征的离散化处理</h2><ol><li>等频分桶</li><li>等值分桶</li><li>GBDT+LR</li></ol><h1 id="3-数据归一化"><a href="#3-数据归一化" class="headerlink" title="3. 数据归一化"></a>3. 数据归一化</h1><h2 id="3-1-为什么需要数据归一化"><a href="#3-1-为什么需要数据归一化" class="headerlink" title="3.1 为什么需要数据归一化"></a>3.1 为什么需要数据归一化</h2><ol><li>归⼀化后加快了梯度下降求最优解的速度</li><li>归⼀化有可能提⾼精度</li></ol><h2 id="3-2-常见数据归一化方法"><a href="#3-2-常见数据归一化方法" class="headerlink" title="3.2 常见数据归一化方法"></a>3.2 常见数据归一化方法</h2><ol><li><p>线性归一化：</p><script type="math/tex; mode=display">x' = \frac{x-min}{max-min}</script><p>缺点：一旦测试集有特征小于min或大于max的数据，则会导致max和min发生变化，需要重新计算。</p></li><li><p>标准化：z-score标准化。</p><script type="math/tex; mode=display">x' = \frac{x - mean}{std}</script></li></ol><ol><li><p>非线性归一化：取指数、对数、正切、等频分桶、等值分桶</p></li><li><p>L1/L2范数标准化：如果只是为了统⼀量纲，那么可以通过L2 范数整体标准化。</p></li><li><p>中心化：PCA 降维时候的预处理，均值变为零，⽅差不变</p><script type="math/tex; mode=display">x' = x-mean</script></li></ol><h3 id="3-3-PCA-主成分分析"><a href="#3-3-PCA-主成分分析" class="headerlink" title="3.3 PCA(主成分分析)"></a>3.3 PCA(主成分分析)</h3><p>两种推导：</p><ol><li>样本点到这个超平面的距离足够近</li><li>样本点在这个超平面的投影能尽可能地分开</li></ol><p>PCA算法流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-110fb4b24415592a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:67%;"></p><p><strong>问题</strong>：能否用PCA 代替隐含层的降维操作</p><p>假设我们有⼀个如下图所⽰的隐藏层。隐藏层在这个⽹络中起到了⼀定的降维作⽤。假如现在我们⽤另⼀种维度下降的⽅法，⽐如说主成分分析法(PCA) 来替代这个隐藏层。那么，这两者的输出效果是⼀样的吗？</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-7f81a305f78c2195.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>答：不一样。因为PCA 提取的是<strong>数据分布⽅差⽐较⼤</strong>的⽅向，隐藏层可以提取有预测能⼒的特征。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本笔记参考二水马的rebirth。&lt;/p&gt;
&lt;h1 id=&quot;1-特征选择&quot;&gt;&lt;a href=&quot;#1-特征选择&quot; class=&quot;headerlink&quot; title=&quot;1. 特征选择&quot;&gt;&lt;/a&gt;1. 特征选择&lt;/h1&gt;&lt;h2 id=&quot;1-1-特征来源&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="找工作" scheme="https://github.com/DesmonDay/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="work" scheme="https://github.com/DesmonDay/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>实习复习过程</title>
    <link href="https://github.com/DesmonDay/2020/02/19/%E5%AE%9E%E4%B9%A0%E5%A4%8D%E4%B9%A0%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.com/DesmonDay/2020/02/19/实习复习过程/</id>
    <published>2020-02-19T02:11:46.000Z</published>
    <updated>2020-03-04T06:19:38.840Z</updated>
    
    <content type="html"><![CDATA[<p>3/14</p><ol><li>按专题刷leetcode</li><li>复习CS-Notes(操作系统) - 面试网易开发岗</li><li>cs224n</li><li>继续复习机器学习、深度学习、NLP</li><li>项目-对话系统（深入了解：文本匹配、多轮对话、对话生成、图网络）</li></ol><p>实习公司消息：</p><ol><li>腾讯3.5开始</li><li>阿里已投，未面试</li><li>虎牙已投，未面试</li><li>美团：4.20截止</li><li>网易：争取3月中旬投简历（分别投两个）</li></ol><p>2/19</p><p>目前的复习进度：</p><ol><li>剑指offer已刷完</li><li>机器学习复习中</li><li>项目继续准备中</li><li>需要开始刷leetcode</li></ol><p>机器学习所用复习资料：</p><ol><li>西瓜书</li><li>二水马的笔记rebirth</li><li>susht师姐的知乎专栏</li><li>各种博客：刘建平Pinard</li></ol><p>深度学习复习：</p><ol><li>二水马的笔记rebirth</li><li>之前看吴恩达课程所做的笔记</li><li>还需自己再熟悉pytorch和tensorflow常用函数</li></ol><p>项目：</p><ol><li>驱动型对话数据集</li><li>文本对抗比赛</li><li>本科毕设——推荐相关</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3/14&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按专题刷leetcode&lt;/li&gt;
&lt;li&gt;复习CS-Notes(操作系统) - 面试网易开发岗&lt;/li&gt;
&lt;li&gt;cs224n&lt;/li&gt;
&lt;li&gt;继续复习机器学习、深度学习、NLP&lt;/li&gt;
&lt;li&gt;项目-对话系统（深入了解：文本匹配、
      
    
    </summary>
    
      <category term="找工作" scheme="https://github.com/DesmonDay/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="work" scheme="https://github.com/DesmonDay/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>PointerNet and CopyNet</title>
    <link href="https://github.com/DesmonDay/2020/02/15/PointerNet-and-CopyNet/"/>
    <id>https://github.com/DesmonDay/2020/02/15/PointerNet-and-CopyNet/</id>
    <published>2020-02-15T15:04:55.000Z</published>
    <updated>2020-03-11T08:51:09.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PointerNet和CopyNet"><a href="#PointerNet和CopyNet" class="headerlink" title="PointerNet和CopyNet"></a>PointerNet和CopyNet</h1><p>参考：<a href="https://cloud.tencent.com/developer/article/1537657" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1537657</a></p><p>由于时间问题，这里只是简单做个记录，有机会再回来补充。这两个算法是比较经典的解决OOV问题的方法，之后也有很多基于此的工作。应对OOV的三个主要方法：</p><ol><li>扩大词表：扩大词表后，可以将部分低频词纳入了词表，但是这些低频词由于缺乏足够数量的语料，训练出来的词向量往往效果不佳，所以扩大词表在提升模型的效果方面，存在一定的瓶颈。</li><li>指针拷贝网络</li><li>字向量/n-gram：中文任务使用字向量（例如BERT），英文任务使用n-gram。</li></ol><p>这两个算法的思想基本都是利用了Attention机制里的对齐向量a。</p><h2 id="Pointer-Networks"><a href="#Pointer-Networks" class="headerlink" title="Pointer Networks"></a>Pointer Networks</h2><p>论文提出了当前文本序列生成模型的三个问题，这三个问题都可以通过使用PtrNet解决：</p><p>（1）目标序列的词表，和源序列的词语内容是<strong>强相关</strong>的。面对不同语言、不同应用场景的任务，往往需要重新构造词表。</p><p>（2）词表的长度需要在模型构建之前作为超参数进行配置。如果需要变更词表的长度，就需要重新训练模型。</p><p>（3）在部分任务场景里，不允许有OOV的存在</p><p>本论文的思路，就是让decoder输出一个由目标序列指向源序列的指针序列。Pointer Networks利用了Attention模型的一个中间变量：对齐系数a。因为对齐系数a表示目标序列当前step和源序列所有step之间的相关性大小，所以我们可以<strong>通过选取对齐系数向量a（向量a长度为源序列的step长度）中数值最大的那个维度（每个维度指向源序列的一个step）</strong>，实现一个从目标序列step到源序列step的指针。最后，根据这个指针指向的源序列的词，直接提取这个词进行输出。</p><h2 id="Pointing-the-Unknown-Words"><a href="#Pointing-the-Unknown-Words" class="headerlink" title="Pointing the Unknown Words"></a>Pointing the Unknown Words</h2><p>这篇论文将pointer networks在NLP领域的文本摘要任务和翻译任务上进行了落地实践（上一篇并没有）。</p><p>论文提出的Pointer Softmax Network模型包含三个主要模块。用通俗的语言解释，如果传统模型效果好，就选择传统模型的输出值进行输出，如果PtrNet模型效果好，就选择PtrNet模型的输出值进行输出，然后需要有一个开关网络来判断，传统模型效果好还是PtrNet模型效果好。这三个模块的描述如下：</p><ol><li>Shortlist Softmax：这个模块由传统的Attention Mechanism实现，输出一个在词表里的词的条件概率。这个模块需要维护一个<strong>固定大小的词表</strong>。</li><li>Location Softmax：这个模块利用了Attention Mechanism的对齐系数a。对齐系数a的向量长度是源序列的step长度，并且对齐系数a每个维度的值，表示decoder当前step输出源序列每个step的概率大小。我们就可以在对齐系数a的各个维度中，取出数值最大的那个维度，作为decoder当前step的指针，这个维度上的值就是其概率大小。</li><li>Switching Network：前面两个模块的公式里的<em>p(z)</em>项，就是由SwitchingNetwork模块生成输出的。Switching Network模型通过<em>p(z)</em>选择是采纳ShortlistSoftmax输出的预测词，还是采纳Location Softmax输出的预测词。Switching Network由一个多层感知机MLP实现，并在最后接一个sigmoid激活函数。</li></ol><p><img src="https://ask.qcloudimg.com/http-save/6552462/5jvu97d12o.png?imageView2/2/w/1620" alt="img"></p><p>额外说明的点：</p><ol><li>在decoder的公式中，每个step有且仅有一个softmax会生效并输出预测值。这个比较理想化，因为开关网络最后一层接的是sigmoid，不能完全保证输出的是0或者1。所以工程实践估计是采用0.5作为判决门限，来选择使用哪个softmax。</li><li>虽然引入PtrNet机制会扩大网络规模，增加网络的参数，但是在模型训练环节，反而会让模型收敛得更快。这一点深有体会。</li><li>要将PtrNet用于翻译任务，需要做一些额外的工作：遇到OOV词时，在使用Location Softmax模块前，会进行两个判定，一个是对OOV词进行查表（法语-英语字典）<strong>判断相应的词是否在target和source中同时出现</strong>，另一个是查找OOV词是否直接在target和source中同时出现，如果其中一个判定成功，则模型可以使用Location Softmax（逻辑上很麻烦对不对，特别是还要额外引入一个词典）。</li></ol><h2 id="Incorporating-Copying-Mechanism-in-Seq2Seq-Learning"><a href="#Incorporating-Copying-Mechanism-in-Seq2Seq-Learning" class="headerlink" title="Incorporating Copying Mechanism in Seq2Seq Learning"></a>Incorporating Copying Mechanism in Seq2Seq <strong>Learning</strong></h2><p>这篇论文提出的CopyNet模型包含两个具有创新点的模块（encoder模块不算在内）:</p><ol><li><p>Generate-Mode &amp; Copy-Mode</p><p>Generate-Mode&amp; Copy-Mode模块会维护两个词表，一个是传统的词表（但是这个词表不包含UNK），一个是源序列中的词构成的词表。</p></li></ol><ul><li>对于传统词表中的词和UNK，模型采用Generate-Mode计算词语输出概率：</li></ul><p><img src="https://ask.qcloudimg.com/http-save/6552462/bqra6ml3ih.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/6552462/vjbnouaunr.png?imageView2/2/w/1620" alt="img"></p><p>​    其中v是词的onehot表示，W是Generate-Mode的词向量表，s是decoder的状态。公式的意思也就是拿词向量乘以状态s，得到一个分数，再进行归一化，获得概率值。</p><ul><li>对于源序列词表中的词，模型采用Copy-Mode计算词语输出概率：</li></ul><p><img src="https://ask.qcloudimg.com/http-save/6552462/2mpmuazlud.png?imageView2/2/w/1620" alt="img"></p><p><img src="C:\Users\90866\Desktop\1620" alt="img"></p><p>​    其中h是encoder输出的output，w是待训练矩阵，s是decoder的状态。</p><p>​    第一点是：这里词表的长度是源序列中的词<strong>去重</strong>后的数量，和[2]中源序列的长度不一样。</p><p>​    第二点是：如果目标序列中的词y有在源序列词表中，那么Copy-Mode输出的概率就不为0。y在源序列的各个step中每出现一次，就要根据公式计算一次概率值，最后Copy-Mode输出的概率，等于源序列的所有step中有出现y的概率值之和。</p><ul><li>最后，模型会将Generate-Mode和Copy-Mode输出的词语概率进行相加汇总，得到最终的词语概率分布。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/6552462/4fnpg6jyyz.png?imageView2/2/w/1620" alt="img"></p><ol><li>State Update</li></ol><p><img src="https://ask.qcloudimg.com/http-save/6552462/fhd0jn1hzh.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/6552462/ma1wsuo7zo.png?imageView2/2/w/1620" alt="img"></p><p>t-1时刻的单词被用来更新t时刻的状态，但是copynet不仅用t-1时刻单词的word_embedding,也用t-1时刻的单词在M中隐藏层状态的具体位置有关。</p><p>思路：</p><blockquote><p>（1）CopyNet模型融合了生成式（abstractive）摘要任务和抽取型（extractive）摘要任务的思想。decoder输出的大部分关键词来源于Copy-Mode，这体现了abstractive summarization。然后再由Generate-Mode把语句撸通顺，这体现了extractive summarization。</p><p>（2）拷贝机制的本质是提取关键词，这个输出可以作为上游模块，和其它任务相结合，例如文本分类任务。</p></blockquote><h2 id="Get-To-The-Point-Summarization-with-Pointer-Generator-Networks"><a href="#Get-To-The-Point-Summarization-with-Pointer-Generator-Networks" class="headerlink" title="Get To The Point: Summarization with Pointer-Generator Networks"></a><strong>Get To The Point: Summarization with Pointer-Generator Networks</strong></h2><p><img src="https://img-blog.csdnimg.cn/20190215101435790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMjEyNjY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最好的一篇工作。<a href="https://blog.csdn.net/appleml/article/details/87105488" target="_blank" rel="noopener">https://blog.csdn.net/appleml/article/details/87105488</a></p><p>模型结构包含以下几个部分：</p><ol><li><p>传统的带Attention机制的Generator Network:</p><script type="math/tex; mode=display">e_i^t = v^Ttanh(W_hh_i+W_ss_t+b_{attn}) \\a^t = softmax(e^t) \\h^*_t = \sum_i a^t_ih_i \\P_{vocab}=softmax(V'(V[s_t,h_t^*]+b)+b')</script><p>计算公式和Bahdanau Attention基本一致，差异是：输出层P_vocab用了个两层的MLP。</p></li><li><p>用于从源序列拷贝词语的Pointer Network：</p></li></ol><script type="math/tex; mode=display">\sum_{}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PointerNet和CopyNet&quot;&gt;&lt;a href=&quot;#PointerNet和CopyNet&quot; class=&quot;headerlink&quot; title=&quot;PointerNet和CopyNet&quot;&gt;&lt;/a&gt;PointerNet和CopyNet&lt;/h1&gt;&lt;p&gt;参考：&lt;a 
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://github.com/DesmonDay/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>XGBoosts和GBDT简单对比</title>
    <link href="https://github.com/DesmonDay/2020/02/10/xgboost%E5%92%8CGBDT%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>https://github.com/DesmonDay/2020/02/10/xgboost和GBDT简单对比/</id>
    <published>2020-02-10T07:08:49.000Z</published>
    <updated>2020-04-08T14:34:13.559Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://www.cnblogs.com/pinard/p/11114748.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/11114748.html</a></p><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><p>GBDT在每一次迭代的时候，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。尤其面对工业级海量的数据，普通的GBDT算法是不能满足其需求的。</p><h2 id="XGBoots和GBDT简单对比"><a href="#XGBoots和GBDT简单对比" class="headerlink" title="XGBoots和GBDT简单对比"></a>XGBoots和GBDT简单对比</h2><p>XGBoost作为GBDT的高效实现，在算法竞赛中很受欢迎。对比GBDT，XGBoost主要在三个方面做了优化：</p><ol><li><p>算法本身的优化</p><ul><li>在算法的弱学习器模型选择上，对比GBDT只支持决策树，还可以支持线性学习器；</li><li>在算法的损失函数上，除了本身的损失，还加上了正则化的部分（$L_t=\sum_{i=1}^m L(y_i,f_{t-1}(x_i))+\gamma J+\frac{\lambda}{2}\sum_{j=1}^Jw^2_{tj}$）</li><li>在算法的优化方式上，GBDT的损失函数只对误差部分做负梯度（一阶泰勒）展开，而XGBoost损失函数对误差部分做二阶泰勒展开，更加准确。</li></ul></li><li><p>算法运行效率的优化</p><p>对每个弱学习器，比如决策树建立的过程做并行选择，找到合适的子树分裂特征和特征值。在并行选择之前，先对所有的特征的值进行排序分组，方便进行并行选择；对分组的特征，选择合适的分组大小，使用CPU缓存进行读取加速。将各个分组保存到多个硬盘以提高IO速度。</p></li><li><p>算法健壮性的优化</p><p>对于缺失值的特征，通过枚举所有缺失值在当前节点是否进入左子树还是右子树来决定缺失值的处理方式。算法本身加入了L1和L2正则化项，可以防止过拟合，泛化能力更强。</p></li></ol><h2 id="XGBoost的优点"><a href="#XGBoost的优点" class="headerlink" title="XGBoost的优点"></a>XGBoost的优点</h2><ul><li>精度更高：GBDT只用到一阶泰勒展开，而XGBoost对损失函数进行了二阶泰勒展开。XGBoost引入二阶导，一方面是为了增加精度，另一方面是为了能够自定义损失函数，二阶泰勒展开可以近似大量损失函数。</li><li>灵活性更强：GBDT以CART作为弱学习器，XGBoost不仅支持CART，还支持线性分类器。使用线性分类器的XGBoost相当于带正则化向的逻辑斯蒂回归（分类问题）和线性回归（回归问题）。此外，XGBoost还支持自定义损失函数，只需要函数支持一阶和二阶求导。</li><li>正则化：XGBoost在目标函数中加入了正则项，用于控制模型的复杂度。正则项包含了树的叶子节点个数、叶子节点权重的范式。正则项降低了模型的方差，使学习出来的模型更加简单，有助于防止过拟合。</li><li>Shrinkage(缩减)：相当于学习速率。XGBoost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让其后面有更大的学习空间。传统GBDT也有这个实现。</li><li>列抽样：XGBoost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算。</li><li>XGBoost工具支持并行：XGBoost的并行不是tree粒度的并行，而是在特征粒度上的。决策树学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost在训练之前，预先对数据进行了排序，然后保存为块结构，随后在迭代中重复地使用这个结构，大大减少计算量。这个块结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，则各个特征的增益计算可以开多线程进行。</li><li>可并行的近似算法：树节点在进行分裂时，需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率会变得很低。所以XGBoost提出了一种可并行的近似算法，用于高效地生成候选的分割点。</li><li>对缺失值能自动学习出对应的处理策略。</li></ul><h2 id="XGBoost的缺点"><a href="#XGBoost的缺点" class="headerlink" title="XGBoost的缺点"></a>XGBoost的缺点</h2><p>XGBoost是基于预排序方法的决策树算法。这种构建决策树的算法基本思想是：首先，对所有特征都按照特征的数值进行预排序。其次，在遍历分割点的时候用O(#data)（遍历数据集）的代价找到一个特征上的最好分割点。最后，在找到一个特征的最好分割点后，将数据分裂成左右子节点。</p><p>这种预排序算法的优点是能精确地找到分割点。</p><p>缺点也很明显：</p><ol><li><strong>空间</strong>消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（预排序过程不仅需要存储特征值，还需要存储特征对应样本的梯度统计值的索引），这就需要消耗训练数据两倍的内存。</li><li><strong>时间</strong>上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。</li><li>对<strong>cache</strong>优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的<strong>cache miss</strong>。</li></ol><h2 id="LightGBM原理"><a href="#LightGBM原理" class="headerlink" title="LightGBM原理"></a>LightGBM原理</h2><p>参考推文：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNzc2NTk0NQ==&amp;mid=2247485750&amp;idx=2&amp;sn=b9d024592a38daac5a8f88a5ce17b24f&amp;chksm=970c21e0a07ba8f6e0c4a8702d564adbca8ccc0580f3adec49e81292f85b8c80d3b6a7eb5885&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1582702883906&amp;sharer_shareid=92ce7d436f5cb488a5c13e20e344e867&amp;key=5dcdf35eccaf36f7ecc5f253915dd66ef16aa5ef38be519e584990c97051929d494c82d05710ef1a4eab0b4d972e08a222289103576eb06ee12a69c849fb83d638912b4ed44e6454be8c3ced9e6de5c8&amp;ascene=1&amp;uin=MjQ2OTEwMDI0Mg%3D%3D&amp;devicetype=Windows+10&amp;version=62080079&amp;lang=zh_CN&amp;exportkey=AX3TDJHX%2B5g%2F%2F1hH6qMIgNU%3D&amp;pass_ticket=YOQR6c8AlwkTgL3wewLa8JhPutxWfxJQLmw1zPNKYnF07R8u5kuJEld%2BSBEBd3rq" target="_blank" rel="noopener">夕小瑶的卖萌屋</a></p><h3 id="LightGBM的优化"><a href="#LightGBM的优化" class="headerlink" title="LightGBM的优化"></a>LightGBM的优化</h3><ul><li>基于直方图的决策树算法：<strong>将连续特征值离散化为k个整数</strong>，存储在直方图中，遍历一次数据后，可根据直方图的离散值遍历寻找最优分割点。最直接的优点：1. 内存占用更小，不需要额外存储预排序的结果，而可以只保存特征离散化后的值；2. 计算代价更小，预排序算法XGBoost每遍历一个特征值就需要计算一次分裂的增益，而LightGBM只需要计算k次。（粗糙的分割点有正则化效果）</li><li>带<strong>深度限制</strong>的Leaf-wise的叶子生长策略：大多数GBDT工具使用低效的按层生长 (level-wise) 的决策树生长策略，<strong>该策略遍历一次数据可以同时分裂同一层的叶子，容易进行多线程优化</strong>。因为它<strong>不加区分的对待同一层的叶子</strong>，带来了很多没必要的开销。实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。LightGBM使用了带有深度限制的按叶子生长 (leaf-wise) 算法，该策略每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。（需要加上最大深度的限制，防止过拟合）</li><li>单边梯度采样 Gradient-based One-Side Sampling(GOSS)：使用GOSS可以<strong>减少大量只具有小梯度的数据实例</strong>，这样在计算信息增益的时候只利用剩下的具有高梯度的数据就可以了，相比XGBoost遍历所有特征值节省了不少时间和空间上的开销。</li><li>互斥特征捆绑 Exclusive Feature Bundling(EFB)：使用EFB可以将许多互斥的特征绑定为一个特征，这样达到了降维的目的。</li><li>直接支持类别特征(Categorical Feature)：大多数机器学习工具都无法直接支持类别特征，一般需要把类别特征通过ont-hot编码，转化到多维的特征，降低了空间和时间的效率。</li><li>支持高效并行：在每台机器上保存全部训练数据，在得到最佳划分方案后可在本地执行划分而减少了不必要的通信。比如，不需要传其他节点划分的样本的索引，只需要把最优特征以及分裂点告诉其他节点即可。</li><li>Cache命中率优化</li></ul><h2 id="XGBoost类库参数"><a href="#XGBoost类库参数" class="headerlink" title="XGBoost类库参数"></a>XGBoost类库参数</h2><h3 id="XGBoost框架参数"><a href="#XGBoost框架参数" class="headerlink" title="XGBoost框架参数"></a>XGBoost框架参数</h3><ol><li><strong>booster</strong>决定了XGBoost使用的弱学习器类型。可以是默认的gbtree, 也就是CART决策树，还可以是线性弱学习器gblinear以及DART。一般来说，我们使用gbtree就可以了，不需要调参。</li><li><strong>n_estimators</strong>则是非常重要的要调的参数，它关系到我们XGBoost模型的复杂度，因为它代表了我们决策树弱学习器的个数。这个参数对应sklearn GBDT的n_estimators。n_estimators太小，容易欠拟合，n_estimators太大，模型会过于复杂，一般需要调参选择一个适中的数值。</li><li><strong>objective</strong>代表了我们要解决的问题是分类还是回归，或其他问题，以及对应的损失函数。具体可以取的值很多，一般我们只关心在分类和回归的时候使用的参数。在回归问题objective一般使用reg:squarederror ，即MSE均方误差。二分类问题一般使用binary:logistic, 多分类问题一般使用multi:softmax。</li></ol><h3 id="XGBoost弱学习器参数"><a href="#XGBoost弱学习器参数" class="headerlink" title="XGBoost弱学习器参数"></a>XGBoost弱学习器参数</h3><p>使用gbtree默认弱学习器的参数。</p><ol><li><p>max_depth：使用网格搜索调参。</p></li><li><p>min_child_weight: 最小的子节点权重阈值. 使用网格搜索调参。</p></li><li><p>gamma: XGBoost的决策树分裂所带来的损失减小阈值。也就会我们在尝试树结构分裂时，会尝试最大化下式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-2f948b702cd06344.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这个最大化后的值需要大于我们的gamma，才能继续分裂子树。这个值需要使用网格搜索调参。</p></li><li><p>subsample: 子采样参数，不放回抽样。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。初期可以取值1，如果发现过拟合后可以网格搜索调参找一个相对小一些的值。</p></li><li><p>colsample_bytree/colsample_bylevel/colsample_bynode: 这三个参数都是用于特征采样的，默认都是不做采样，即使用所有的特征建立决策树。colsample_bytree控制整棵树的特征采样比例，colsample_bylevel控制某一层的特征采样比例，而colsample_bynode控制某一个树节点的特征采样比例。</p></li><li><p>reg_alpha/reg_lambda: XGBoost的正则化参数。</p></li></ol><p>上面这些参数都是需要调参的，不过一般先调max_depth，min_child_weight和gamma。如果发现有过拟合的情况下，再尝试调后面几个参数。</p><h3 id="XGBoost其他参数"><a href="#XGBoost其他参数" class="headerlink" title="XGBoost其他参数"></a>XGBoost其他参数</h3><ol><li>learning_rate: 控制每个弱学习器的权重缩减系数，较小的learning_rate意味着我们需要更多的弱学习器的迭代次数。所以这两个参数n_estimators和learning_rate要一起调参才有效果。</li><li>n_jobs: 控制算法的并发线程数</li><li>scale_pos_weight: 用于类别不平衡的时候，负例和正例的比例</li><li>importance_type: 可以查询各个特征的重要性程度。可以选择“gain”, “weight”, “cover”, “total_gain” 或者 “total_cover”。最后可以通过调用booster的get_score方法获取对应的特征权重。“weight”通过特征被选中作为分裂特征的计数来计算重要性，“gain”和“total_gain”则通过分别计算特征被选中做分裂特征时带来的平均增益和总增益来计算重要性。“cover”和 “total_cover”通过计算特征被选中做分裂时的平均样本覆盖度和总体样本覆盖度来来计算重要性。</li></ol><p>我们可以通过验证集的准确率来判断我们前面网格搜索调参是否起到了效果。实际处理的时候需要反复搜索参数并验证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;a href=&quot;https://www.cnblogs.com/pinard/p/11114748.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/pinard/p/11114748.html&lt;
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>Tensorflow的记忆</title>
    <link href="https://github.com/DesmonDay/2019/12/25/Tensorflow%E7%9A%84%E8%AE%B0%E5%BF%86/"/>
    <id>https://github.com/DesmonDay/2019/12/25/Tensorflow的记忆/</id>
    <published>2019-12-25T06:40:52.000Z</published>
    <updated>2020-02-28T04:18:44.420Z</updated>
    
    <content type="html"><![CDATA[<p>一般，我们在参加某个比赛或者实现某种算法的时候，需要经历以下几个过程：</p><ol><li>数据集收集、清洗</li><li>特征构建</li><li>模型实现</li><li>得到结果，再根据反馈在2-4进行多次想法的迭代</li></ol><p>其中，在模型实现上，比如我主要方向是NLP，而NLP如今基本是深度学习时代（特别是预训练模型BERT出来后），因此多需要对深度学习框架有比较深的了解和使用经验。而Tensorflow和Pytorch两家经常被用来做对比。Tensorflow其实更适合用在工业界（静态图，TensorFlow的运行机制属于”定义”与”运行“相分离。），而Pytorch由于其方便性（动态图）而广泛流行于学术界。所以往往，实际操作时，我们通常会使用Pytorch快速实现模型，在对结果进行多次尝试找到最优参数后，再将使用Tensorflow进行复现。也就是说，Tensorflow很重要！！</p><p>Tensorflow的概念：</p><ol><li>张量（tensor）：TensorFlow程序使用tensor数据结构来代表所有的数据，计算图中，操作间传递的数据都是tensor，你可以把TensorFlow tensor看做一个n维的数组或者列表。</li><li>变量（variable）：常用于定义模型中的参数，是通过不断训练得到的值。比如权重和偏置。</li><li>占位符（placeholder）：输入变量的载体。也可以理解成定义函数时的参数。</li><li>图中的节点操作（op）：一个op获得0个或者多个Tensor，执行计算，产生0个或者多个Tensor<strong>。op是描述张量中的运算关系，是网络中真正结构。</strong></li></ol><p>一个TensorFlow图描述了计算的过程，为了进行计算，图必须在会话里启动，会话将图的op分发到诸如CPU或者GPU的设备上，同时提供执行op的方法，这些方法执行后，将产生的tensor返回，在python语言中，返回的tensor是numpy array对象，在C或者C++语言中，返回的tensor是tensorflow:Tensor实例。</p><p>session与图的交互过程中定义了以下两种数据的流向机制：</p><ul><li>注入机制（feed）：通过占位符向模式中传入数据</li><li>取回机制（fetch）：从模式中取得结果</li></ul><p>所以，这里就是记录一些，Tensorflow常用的函数之类的，也当做我的小小笔记本好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NLP类Tensorflow常用导入包</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.seq2seq <span class="keyword">as</span> seq2seq</span><br></pre></td></tr></table></figure><p>关于tensowflow中的会话相关操作，参考博客：<a href="https://www.cnblogs.com/zyly/p/8869763.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyly/p/8869763.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set GPU fraction</span></span><br><span class="line">gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=args.gpu_fraction)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># build model or load model, 以我参加的一个比赛为例</span></span><br><span class="line">    model = Seq2SeqModel(args, word2id, embeddings)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果有训练好的模型，则导入</span></span><br><span class="line">    <span class="comment"># load checkpoint if exists</span></span><br><span class="line">    ckpt = tf.train.get_checkpoint_state(args.model_dir)</span><br><span class="line">    <span class="keyword">if</span> ckpt <span class="keyword">and</span> tf.train.checkpoint_exists(ckpt.model_checkpoint_path):</span><br><span class="line">        model.saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 如果没有模型，则初始化参数，进行训练</span></span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br></pre></td></tr></table></figure><p>Tensorflow的summary用法参考博客：<a href="https://www.cnblogs.com/lyc-seu/p/8647792.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyc-seu/p/8647792.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定一个文件用来保存图，之后可以使用tensorboard查看训练过程</span></span><br><span class="line">summary_writer = tf.summary.FileWriter(args.model_dir, sess=sess.graph)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 训练过程中</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(batches, desc=<span class="string">'Training'</span>):</span><br><span class="line">    <span class="comment"># 如果我们需要记录某个step的图，则调用summary_writer</span></span><br><span class="line">    summary_writer.add_summary(summary, cur_step)</span><br></pre></td></tr></table></figure><p>构建多层RNN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_rnn_cell</span><span class="params">(self, hidden_size, rnn_type=<span class="string">'lstm'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create multi-layer rnn with dropout layer, called by decoder</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_cell</span><span class="params">(hidden_size, rnn_type)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> rnn_type == <span class="string">'lstm'</span>:</span><br><span class="line">            single_cell = tf.contrib.rnn.LSTMCell(hidden_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            single_cell = tf.contrib.rnn.GRUCell(hidden_size)</span><br><span class="line">        cell = tf.contrib.rnn.DropoutWrapper(single_cell, output_keep_prob=self.keep_prob)</span><br><span class="line">                <span class="keyword">return</span> cell</span><br><span class="line"></span><br><span class="line">    rnn_cell = tf.contrib.rnn.MultiRNNCell([a_cell(hidden_size, rnn_type) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.num_layers)])</span><br><span class="line">    <span class="keyword">return</span> rnn_cell</span><br></pre></td></tr></table></figure><p>创建模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seq2SeqModel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args)</span>:</span></span><br><span class="line">        self.num_layers = args.num_layers</span><br><span class="line">        <span class="comment"># 初始化参数...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_model</span><span class="params">(self, embedding)</span>:</span></span><br><span class="line">        <span class="comment">## 设置占位符（</span></span><br><span class="line">        self.keep_prob = tf.placeholder(tf.float32, [], name=<span class="string">'keep_prob'</span>)</span><br><span class="line">        self.src_enc_input = tf.placeholder(tf.int32, [<span class="keyword">None</span>, <span class="keyword">None</span>], name=<span class="string">'src_enc_input'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.train_wordvec:</span><br><span class="line">            self.word_embed = tf.get_variable(<span class="string">'embedding'</span>, [self.vocab_size, self.emb_size], dtype=tf.float32)</span><br><span class="line">            self.word_embed.assign(embedding)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.word_embed = tf.get_variable(<span class="string">'embedding'</span>, [self.vocab_size, self.emb_size], trainable=<span class="keyword">False</span>, dtype=tf.float32)</span><br><span class="line">            self.word_embed.assign(embedding)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">## embedding_lookup</span></span><br><span class="line">        self.src_enc_emb = tf.nn.embedding_lookup(self.word_embed, self.src_enc_input)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">##### encoder</span></span><br><span class="line">        src_enc_output, src_enc_state = self.cudnn_rnn(self.num_dirs, self.src_input_emb, self.src_enc_length, self.hidden_size, <span class="string">'src_enc'</span>, self.rnn_type)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        self.tgt_dec_input = tf.placeholder(tf.int32, [<span class="keyword">None</span>, <span class="keyword">None</span>], name=<span class="string">'tgt_dec_input'</span>)</span><br><span class="line">        self.tgt_dec_length = tf.placeholder(tf.int32, [<span class="keyword">None</span>], name=<span class="string">'tgt_dec_length'</span>)</span><br><span class="line">        self.max_target_length = tf.reduce_max(self.tgt_dec_length, name=<span class="string">'max_target_length'</span>)</span><br><span class="line">        <span class="comment"># 序列掩码，用于decoder部分</span></span><br><span class="line">        self.mask = tf.sequence_mask(self.tgt_dec_length, self.max_target_length, dtype=tf.float32, name=<span class="string">'mask'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">##### decoder</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">optimizer = tf.train.AdamOptimizer(self.learning_rate)</span><br><span class="line">trainable_params = tf.trainable_variables()</span><br><span class="line">gradients = tf.gradients(self.loss, trainable_params)</span><br><span class="line">clip_gradients, _ = tf.clip_by_global_norm(gradients, self.max_grad_norm)</span><br><span class="line">self.train_op = optimizer.apply_gradients(zip(clip_gradients, trainable_params))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般，我们在参加某个比赛或者实现某种算法的时候，需要经历以下几个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据集收集、清洗&lt;/li&gt;
&lt;li&gt;特征构建&lt;/li&gt;
&lt;li&gt;模型实现&lt;/li&gt;
&lt;li&gt;得到结果，再根据反馈在2-4进行多次想法的迭代&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，在
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://github.com/DesmonDay/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>对话系统中的推荐-论文调研</title>
    <link href="https://github.com/DesmonDay/2019/09/29/%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%8E%A8%E8%8D%90-%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/"/>
    <id>https://github.com/DesmonDay/2019/09/29/对话系统中的推荐-论文调研/</id>
    <published>2019-09-29T04:07:59.000Z</published>
    <updated>2020-02-29T04:12:08.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对话系统-推荐-论文调研"><a href="#对话系统-推荐-论文调研" class="headerlink" title="对话系统+推荐 论文调研"></a>对话系统+推荐 论文调研</h1><h2 id="相关数据集"><a href="#相关数据集" class="headerlink" title="相关数据集"></a>相关数据集</h2><ul><li><p>REDIAL(REcommendations through DIALog)[1]: 电影对话推荐数据集，由作者通过Amazon Mechanical Turk(AMT)构建，共包含10004个对话。举例如下：</p><hr><p><strong>SEEKER</strong>: hi ! i ’m looking for an action filled movie similar to jurassic park</p><p><em>HUMAN</em>: ok , have you seen jurassic world ?</p><p><strong>SEEKER</strong>: yes i loved that movie as well . are there any good movies without dinosaurs ?</p><p><em>HUMAN</em>: have you seen king kong ?</p><p><strong>SEEKER</strong>: yes ! that was another great giant monster movie : )</p><p><em>HUMAN</em>: what about jaws &amp; amp ; jaws 2 ? oldies but goodies scary action ? suspense gives me the rumblies</p><p><strong>SEEKER</strong>: i absolutely loved the first one . one of my favorite movies ever : ) honestly i ca n’t say i remember much about the second one . jaws 3-d was quite funny and jaws : the revenge was just weird . i do love suspense too …</p><p><em>HUMAN</em>: i like suspense but sometimes i can barely handle it ! it gives me anxiety ! lol</p><p><strong>SEEKER</strong>: that ’s understandable . as long as it ’s not too gory i do n’t generally have a problem with those things .</p><p><em>HUMAN</em>: well , it was great chatting with you ! have a great one !</p><p><strong>SEEKER</strong>: you too! thanks!</p><hr></li><li><p>REDIAL + DBpedia[2]: 增加了电影的相关实体，如导演、电影风格等。(实际上是利用REDIAL对话数据集中提及的实体，然后自己到DBpedia中对应查找相关联实体)</p></li><li><p>QA+Recommendation dataset[3]: 同样是电影领域，但是对应的回复只有电影名称，不适用于对话领域。</p></li><li><p>Reddit dataset[3]: 相比之下对话更加流畅，但对话的目的并不是推荐电影，不适用。</p></li><li><p>target-guided dataset[4]: 对话的目的是引导对话中出现提前设置的目标词或相关词，但对话本身为开放领域。</p></li><li><p>E-commerce Conversational Search and Recommendation Dataset[5]: 其领域是电子商务中的产品推荐，为半合成数据集。包括Electronics, CDs &amp; Vinyl, Kindle Store和Cell Phones。但目前数据下载链接无法访问，下图为论文中的样例。对应论文提出的模型是针对对话中的问题生成。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-d8cea23942297ff0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><p>相对而言，目前只有REDIAL是比较完整的涉及对话加推荐的数据集，但是其<strong>仅限于电影领域</strong>。</p><p>而另一个Amazon的数据集则针对电子产品，但是作者设计出数据集主要用于<strong>提出问题</strong>(System Ask, user respond，具体论文还没有细看)。同时，与我们所想的用在“售前机器人”这样的场景差别比较大，更加适合用在<strong>日常对话中的推荐</strong>，即缺乏“售前对话”的数据集。</p><h2 id="论文方法"><a href="#论文方法" class="headerlink" title="论文方法"></a>论文方法</h2><ul><li><p>REDIAL baseline[1]: 第一篇考虑多轮推荐对话的论文，相当于baseline。包含一个基于<strong>HRED</strong>的对话生成系统以及一个基于autoencoder的推荐系统，通过对话中的mentioned items将两个系统连接起来。</p><p><img src="https://upload-images.jianshu.io/upload_images/8636110-ece6d62054b62f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ul><ul><li><p>Transformer: [2]论文实现的一个baseline模型，与REDIAL类似，但是其对话生成系统是基于Transformer结构完成的，其余部分不变。</p></li><li><p>KBRD[2]: 端到端框架，通过知识图谱将对话系统和推荐系统连接起来。在生成推荐时，不仅仅考虑在对话中提及的items，还将与这些items相关的实体一并链接到知识图谱中，通过entity attention来得到推荐系统对于所有items的推荐概率；通过推荐系统对应用户的hidden representation可以计算得到一个vocabulary bias($b_u$)，随后对话系统基于Transformer框架且结合$b_u$，从而生成对话中词的概率，从而生成response。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/8636110-30fa7937a71647a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>推荐系统+强化学习的相关数据集均没有涉及对话方面。</p><h2 id="论文列表"><a href="#论文列表" class="headerlink" title="论文列表"></a>论文列表</h2><p>[1] Towards deep conversational recommendations, NeurlPS2018</p><p>[2] Towards Knowledge-Based Recommender Dialog System, emnlp2019</p><p>[3] Evaluating Prerequisite Qualities for Learning End-to-End Dialog Systems, ICLR2016</p><p>[4] Target-Guided Open-Domain Conversation, ACL2019</p><p>[5] Towards conversational search and recommendation: System Ask, user respond， CIKM2018</p><p>其他相关的未列举，大多数是比较久远的年份了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对话系统-推荐-论文调研&quot;&gt;&lt;a href=&quot;#对话系统-推荐-论文调研&quot; class=&quot;headerlink&quot; title=&quot;对话系统+推荐 论文调研&quot;&gt;&lt;/a&gt;对话系统+推荐 论文调研&lt;/h1&gt;&lt;h2 id=&quot;相关数据集&quot;&gt;&lt;a href=&quot;#相关数据集&quot; c
      
    
    </summary>
    
      <category term="NLP" scheme="https://github.com/DesmonDay/categories/NLP/"/>
    
    
  </entry>
  
</feed>
